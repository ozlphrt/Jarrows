const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/physics-CelHDFek.js","assets/preload-helper-Si1OKCYg.js"])))=>i.map(i=>d[i]);
import { _ as x0 } from "./preload-helper-Si1OKCYg.js";
import { createPhysicsBlock as _0, isPhysicsStepping as ds, deferBodyModification as y0, removePhysicsBody as M0, deferBodyCreation as b0, initPhysics as S0, hasPendingOperations as w0, updatePhysics as T0, isPhysicsProcessing as E0, __tla as __tla_0 } from "./physics-CelHDFek.js";
Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  const vl = "164", A0 = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
  }, C0 = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
  }, wp = 0, Kc = 1, Tp = 2, R0 = 3, P0 = 0, Io = 1, xl = 2, Gn = 3, mi = 0, Zt = 1, Qt = 2, di = 0, bs = 1, jc = 2, Qc = 3, eh = 4, Ep = 5, Di = 100, Ap = 101, Cp = 102, Rp = 103, Pp = 104, Ip = 200, Lp = 201, Dp = 202, Np = 203, qa = 204, $a = 205, Up = 206, Op = 207, zp = 208, Fp = 209, Bp = 210, kp = 211, Vp = 212, Hp = 213, Gp = 214, Wp = 0, Xp = 1, Yp = 2, no = 3, qp = 4, $p = 5, Zp = 6, Jp = 7, Lo = 0, Kp = 1, jp = 2, fi = 0, Qp = 1, em = 2, tm = 3, nm = 4, im = 5, sm = 6, rm = 7, th = "attached", om = "detached", _l = 300, gi = 301, Bi = 302, cr = 303, io = 304, xr = 306, so = 1e3, wn = 1001, ro = 1002, At = 1003, Qh = 1004, I0 = 1004, Qs = 1005, L0 = 1005, Mt = 1006, $r = 1007, D0 = 1007, Xn = 1008, N0 = 1008, vi = 1009, am = 1010, lm = 1011, eu = 1012, tu = 1013, Ts = 1014, Tn = 1015, Do = 1016, nu = 1017, iu = 1018, _r = 1020, cm = 35902, hm = 1021, um = 1022, dn = 1023, dm = 1024, fm = 1025, Ss = 1026, hr = 1027, su = 1028, ru = 1029, pm = 1030, ou = 1031, au = 1033, ka = 33776, Va = 33777, Ha = 33778, Ga = 33779, nh = 35840, ih = 35841, sh = 35842, rh = 35843, oh = 36196, ah = 37492, lh = 37496, ch = 37808, hh = 37809, uh = 37810, dh = 37811, fh = 37812, ph = 37813, mh = 37814, gh = 37815, vh = 37816, xh = 37817, _h = 37818, yh = 37819, Mh = 37820, bh = 37821, Wa = 36492, Sh = 36494, wh = 36495, mm = 36283, Th = 36284, Eh = 36285, Ah = 36286, gm = 2200, vm = 2201, xm = 2202, oo = 2300, ao = 2301, Xa = 2302, gs = 2400, vs = 2401, lo = 2402, yl = 2500, lu = 2501, U0 = 0, O0 = 1, z0 = 2, _m = 3200, ym = 3201, Wi = 0, Mm = 1, ai = "", Mn = "srgb", yi = "srgb-linear", Ml = "display-p3", No = "display-p3-linear", co = "linear", lt = "srgb", ho = "rec709", uo = "p3", F0 = 0, fs = 7680, B0 = 7681, k0 = 7682, V0 = 7683, H0 = 34055, G0 = 34056, W0 = 5386, X0 = 512, Y0 = 513, q0 = 514, $0 = 515, Z0 = 516, J0 = 517, K0 = 518, Ch = 519, bm = 512, Sm = 513, wm = 514, cu = 515, Tm = 516, Em = 517, Am = 518, Cm = 519, fo = 35044, j0 = 35048, Q0 = 35040, ev = 35045, tv = 35049, nv = 35041, iv = 35046, sv = 35050, rv = 35042, ov = "100", Rh = "300 es", Yn = 2e3, po = 2001;
  class Mi {
    addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      const n = this._listeners;
      n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
    }
    hasEventListener(e, t) {
      if (this._listeners === void 0) return false;
      const n = this._listeners;
      return n[e] !== void 0 && n[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
      if (this._listeners === void 0) return;
      const i = this._listeners[e];
      if (i !== void 0) {
        const r = i.indexOf(t);
        r !== -1 && i.splice(r, 1);
      }
    }
    dispatchEvent(e) {
      if (this._listeners === void 0) return;
      const n = this._listeners[e.type];
      if (n !== void 0) {
        e.target = this;
        const i = n.slice(0);
        for (let r = 0, o = i.length; r < o; r++) i[r].call(this, e);
        e.target = null;
      }
    }
  }
  const Ot = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff"
  ];
  let sd = 1234567;
  const ws = Math.PI / 180, ur = 180 / Math.PI;
  function fn() {
    const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
    return (Ot[s & 255] + Ot[s >> 8 & 255] + Ot[s >> 16 & 255] + Ot[s >> 24 & 255] + "-" + Ot[e & 255] + Ot[e >> 8 & 255] + "-" + Ot[e >> 16 & 15 | 64] + Ot[e >> 24 & 255] + "-" + Ot[t & 63 | 128] + Ot[t >> 8 & 255] + "-" + Ot[t >> 16 & 255] + Ot[t >> 24 & 255] + Ot[n & 255] + Ot[n >> 8 & 255] + Ot[n >> 16 & 255] + Ot[n >> 24 & 255]).toLowerCase();
  }
  function mt(s, e, t) {
    return Math.max(e, Math.min(t, s));
  }
  function hu(s, e) {
    return (s % e + e) % e;
  }
  function av(s, e, t, n, i) {
    return n + (s - e) * (i - n) / (t - e);
  }
  function lv(s, e, t) {
    return s !== e ? (t - s) / (e - s) : 0;
  }
  function Zr(s, e, t) {
    return (1 - t) * s + t * e;
  }
  function cv(s, e, t, n) {
    return Zr(s, e, 1 - Math.exp(-t * n));
  }
  function hv(s, e = 1) {
    return e - Math.abs(hu(s, e * 2) - e);
  }
  function uv(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
  }
  function dv(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
  }
  function fv(s, e) {
    return s + Math.floor(Math.random() * (e - s + 1));
  }
  function pv(s, e) {
    return s + Math.random() * (e - s);
  }
  function mv(s) {
    return s * (0.5 - Math.random());
  }
  function gv(s) {
    s !== void 0 && (sd = s);
    let e = sd += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
  }
  function vv(s) {
    return s * ws;
  }
  function xv(s) {
    return s * ur;
  }
  function _v(s) {
    return (s & s - 1) === 0 && s !== 0;
  }
  function yv(s) {
    return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
  }
  function Mv(s) {
    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
  }
  function bv(s, e, t, n, i) {
    const r = Math.cos, o = Math.sin, a = r(t / 2), l = o(t / 2), c = r((e + n) / 2), u = o((e + n) / 2), d = r((e - n) / 2), h = o((e - n) / 2), f = r((n - e) / 2), m = o((n - e) / 2);
    switch (i) {
      case "XYX":
        s.set(a * u, l * d, l * h, a * c);
        break;
      case "YZY":
        s.set(l * h, a * u, l * d, a * c);
        break;
      case "ZXZ":
        s.set(l * d, l * h, a * u, a * c);
        break;
      case "XZX":
        s.set(a * u, l * m, l * f, a * c);
        break;
      case "YXY":
        s.set(l * f, a * u, l * m, a * c);
        break;
      case "ZYZ":
        s.set(l * m, l * f, a * u, a * c);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
    }
  }
  function $t(s, e) {
    switch (e.constructor) {
      case Float32Array:
        return s;
      case Uint32Array:
        return s / 4294967295;
      case Uint16Array:
        return s / 65535;
      case Uint8Array:
        return s / 255;
      case Int32Array:
        return Math.max(s / 2147483647, -1);
      case Int16Array:
        return Math.max(s / 32767, -1);
      case Int8Array:
        return Math.max(s / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function Be(s, e) {
    switch (e.constructor) {
      case Float32Array:
        return s;
      case Uint32Array:
        return Math.round(s * 4294967295);
      case Uint16Array:
        return Math.round(s * 65535);
      case Uint8Array:
        return Math.round(s * 255);
      case Int32Array:
        return Math.round(s * 2147483647);
      case Int16Array:
        return Math.round(s * 32767);
      case Int8Array:
        return Math.round(s * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const Sv = {
    DEG2RAD: ws,
    RAD2DEG: ur,
    generateUUID: fn,
    clamp: mt,
    euclideanModulo: hu,
    mapLinear: av,
    inverseLerp: lv,
    lerp: Zr,
    damp: cv,
    pingpong: hv,
    smoothstep: uv,
    smootherstep: dv,
    randInt: fv,
    randFloat: pv,
    randFloatSpread: mv,
    seededRandom: gv,
    degToRad: vv,
    radToDeg: xv,
    isPowerOfTwo: _v,
    ceilPowerOfTwo: yv,
    floorPowerOfTwo: Mv,
    setQuaternionFromProperEuler: bv,
    normalize: Be,
    denormalize: $t
  };
  class ee {
    constructor(e = 0, t = 0) {
      ee.prototype.isVector2 = true, this.x = e, this.y = t;
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return this.x = e, this.y = t, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x, n = this.y, i = e.elements;
      return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const n = this.dot(e) / t;
      return Math.acos(mt(n, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x, n = this.y - e.y;
      return t * t + n * n;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }
    rotateAround(e, t) {
      const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
      return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class Fe {
    constructor(e, t, n, i, r, o, a, l, c) {
      Fe.prototype.isMatrix3 = true, this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, c);
    }
    set(e, t, n, i, r, o, a, l, c) {
      const u = this.elements;
      return u[0] = e, u[1] = i, u[2] = a, u[3] = t, u[4] = r, u[5] = l, u[6] = n, u[7] = o, u[8] = c, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const t = this.elements, n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
    }
    extractBasis(e, t, n) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[3], l = n[6], c = n[1], u = n[4], d = n[7], h = n[2], f = n[5], m = n[8], v = i[0], g = i[3], p = i[6], _ = i[1], x = i[4], b = i[7], E = i[2], S = i[5], w = i[8];
      return r[0] = o * v + a * _ + l * E, r[3] = o * g + a * x + l * S, r[6] = o * p + a * b + l * w, r[1] = c * v + u * _ + d * E, r[4] = c * g + u * x + d * S, r[7] = c * p + u * b + d * w, r[2] = h * v + f * _ + m * E, r[5] = h * g + f * x + m * S, r[8] = h * p + f * b + m * w, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }
    determinant() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], u = e[8];
      return t * o * u - t * a * c - n * r * u + n * a * l + i * r * c - i * o * l;
    }
    invert() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], u = e[8], d = u * o - a * c, h = a * l - u * r, f = c * r - o * l, m = t * d + n * h + i * f;
      if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const v = 1 / m;
      return e[0] = d * v, e[1] = (i * c - u * n) * v, e[2] = (a * n - i * o) * v, e[3] = h * v, e[4] = (u * t - i * l) * v, e[5] = (i * r - a * t) * v, e[6] = f * v, e[7] = (n * l - c * t) * v, e[8] = (o * t - n * r) * v, this;
    }
    transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }
    setUvTransform(e, t, n, i, r, o, a) {
      const l = Math.cos(r), c = Math.sin(r);
      return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1), this;
    }
    scale(e, t) {
      return this.premultiply(tc.makeScale(e, t)), this;
    }
    rotate(e) {
      return this.premultiply(tc.makeRotation(-e)), this;
    }
    translate(e, t) {
      return this.premultiply(tc.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
      return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
    }
    makeRotation(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
      const t = this.elements, n = e.elements;
      for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return false;
      return true;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const tc = new Fe();
  function Rm(s) {
    for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return true;
    return false;
  }
  const wv = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  function er(s, e) {
    return new wv[s](e);
  }
  function mo(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s);
  }
  function Pm() {
    const s = mo("canvas");
    return s.style.display = "block", s;
  }
  const rd = {};
  function Im(s) {
    s in rd || (rd[s] = true, console.warn(s));
  }
  const od = new Fe().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), ad = new Fe().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), qo = {
    [yi]: {
      transfer: co,
      primaries: ho,
      toReference: (s) => s,
      fromReference: (s) => s
    },
    [Mn]: {
      transfer: lt,
      primaries: ho,
      toReference: (s) => s.convertSRGBToLinear(),
      fromReference: (s) => s.convertLinearToSRGB()
    },
    [No]: {
      transfer: co,
      primaries: uo,
      toReference: (s) => s.applyMatrix3(ad),
      fromReference: (s) => s.applyMatrix3(od)
    },
    [Ml]: {
      transfer: lt,
      primaries: uo,
      toReference: (s) => s.convertSRGBToLinear().applyMatrix3(ad),
      fromReference: (s) => s.applyMatrix3(od).convertLinearToSRGB()
    }
  }, Tv = /* @__PURE__ */ new Set([
    yi,
    No
  ]), st = {
    enabled: true,
    _workingColorSpace: yi,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(s) {
      if (!Tv.has(s)) throw new Error(`Unsupported working color space, "${s}".`);
      this._workingColorSpace = s;
    },
    convert: function(s, e, t) {
      if (this.enabled === false || e === t || !e || !t) return s;
      const n = qo[e].toReference, i = qo[t].fromReference;
      return i(n(s));
    },
    fromWorkingColorSpace: function(s, e) {
      return this.convert(s, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function(s, e) {
      return this.convert(s, e, this._workingColorSpace);
    },
    getPrimaries: function(s) {
      return qo[s].primaries;
    },
    getTransfer: function(s) {
      return s === ai ? co : qo[s].transfer;
    }
  };
  function rr(s) {
    return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
  }
  function nc(s) {
    return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
  }
  let Is;
  class Lm {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        Is === void 0 && (Is = mo("canvas")), Is.width = e.width, Is.height = e.height;
        const n = Is.getContext("2d");
        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Is;
      }
      return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
        const t = mo("canvas");
        t.width = e.width, t.height = e.height;
        const n = t.getContext("2d");
        n.drawImage(e, 0, 0, e.width, e.height);
        const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
        for (let o = 0; o < r.length; o++) r[o] = rr(r[o] / 255) * 255;
        return n.putImageData(i, 0, 0), t;
      } else if (e.data) {
        const t = e.data.slice(0);
        for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(rr(t[n] / 255) * 255) : t[n] = rr(t[n]);
        return {
          data: t,
          width: e.width,
          height: e.height
        };
      } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
    }
  }
  let Ev = 0;
  class xs {
    constructor(e = null) {
      this.isSource = true, Object.defineProperty(this, "id", {
        value: Ev++
      }), this.uuid = fn(), this.data = e, this.dataReady = true, this.version = 0;
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      const n = {
        uuid: this.uuid,
        url: ""
      }, i = this.data;
      if (i !== null) {
        let r;
        if (Array.isArray(i)) {
          r = [];
          for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? r.push(ic(i[o].image)) : r.push(ic(i[o]));
        } else r = ic(i);
        n.url = r;
      }
      return t || (e.images[this.uuid] = n), n;
    }
  }
  function ic(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Lm.getDataURL(s) : s.data ? {
      data: Array.from(s.data),
      width: s.width,
      height: s.height,
      type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let Av = 0;
  class gt extends Mi {
    constructor(e = gt.DEFAULT_IMAGE, t = gt.DEFAULT_MAPPING, n = wn, i = wn, r = Mt, o = Xn, a = dn, l = vi, c = gt.DEFAULT_ANISOTROPY, u = ai) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", {
        value: Av++
      }), this.uuid = fn(), this.name = "", this.source = new xs(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new ee(0, 0), this.repeat = new ee(1, 1), this.center = new ee(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Fe(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
    }
    get image() {
      return this.source.data;
    }
    set image(e = null) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [
          this.repeat.x,
          this.repeat.y
        ],
        offset: [
          this.offset.x,
          this.offset.y
        ],
        center: [
          this.center.x,
          this.center.y
        ],
        rotation: this.rotation,
        wrap: [
          this.wrapS,
          this.wrapT
        ],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    transformUv(e) {
      if (this.mapping !== _l) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case so:
          e.x = e.x - Math.floor(e.x);
          break;
        case wn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case ro:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case so:
          e.y = e.y - Math.floor(e.y);
          break;
        case wn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case ro:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === true && (this.version++, this.source.needsUpdate = true);
    }
    set needsPMREMUpdate(e) {
      e === true && this.pmremVersion++;
    }
  }
  gt.DEFAULT_IMAGE = null;
  gt.DEFAULT_MAPPING = _l;
  gt.DEFAULT_ANISOTROPY = 1;
  class rt {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      rt.prototype.isVector4 = true, this.x = e, this.y = t, this.z = n, this.w = i;
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, n, i) {
      return this.x = e, this.y = t, this.z = n, this.w = i, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this.w = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setW(e) {
      return this.w = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this.w += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
    }
    applyMatrix4(e) {
      const t = this.x, n = this.y, i = this.z, r = this.w, o = e.elements;
      return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      const t = Math.sqrt(1 - e.w * e.w);
      return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
    }
    setAxisAngleFromRotationMatrix(e) {
      let t, n, i, r;
      const l = e.elements, c = l[0], u = l[4], d = l[8], h = l[1], f = l[5], m = l[9], v = l[2], g = l[6], p = l[10];
      if (Math.abs(u - h) < 0.01 && Math.abs(d - v) < 0.01 && Math.abs(m - g) < 0.01) {
        if (Math.abs(u + h) < 0.1 && Math.abs(d + v) < 0.1 && Math.abs(m + g) < 0.1 && Math.abs(c + f + p - 3) < 0.1) return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        const x = (c + 1) / 2, b = (f + 1) / 2, E = (p + 1) / 2, S = (u + h) / 4, w = (d + v) / 4, A = (m + g) / 4;
        return x > b && x > E ? x < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(x), i = S / n, r = w / n) : b > E ? b < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(b), n = S / i, r = A / i) : E < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(E), n = w / r, i = A / r), this.set(n, i, r, t), this;
      }
      let _ = Math.sqrt((g - m) * (g - m) + (d - v) * (d - v) + (h - u) * (h - u));
      return Math.abs(_) < 1e-3 && (_ = 1), this.x = (g - m) / _, this.y = (d - v) / _, this.z = (h - u) / _, this.w = Math.acos((c + f + p - 1) / 2), this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class Dm extends Mi {
    constructor(e = 1, t = 1, n = {}) {
      super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new rt(0, 0, e, t), this.scissorTest = false, this.viewport = new rt(0, 0, e, t);
      const i = {
        width: e,
        height: t,
        depth: 1
      };
      n = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: Mt,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, n);
      const r = new gt(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
      r.flipY = false, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
      const o = n.count;
      for (let a = 0; a < o; a++) this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = true;
      this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
    }
    get texture() {
      return this.textures[0];
    }
    set texture(e) {
      this.textures[0] = e;
    }
    setSize(e, t, n = 1) {
      if (this.width !== e || this.height !== t || this.depth !== n) {
        this.width = e, this.height = t, this.depth = n;
        for (let i = 0, r = this.textures.length; i < r; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
        this.dispose();
      }
      this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
      for (let n = 0, i = e.textures.length; n < i; n++) this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = true;
      const t = Object.assign({}, e.texture.image);
      return this.texture.source = new xs(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  class zn extends Dm {
    constructor(e = 1, t = 1, n = {}) {
      super(e, t, n), this.isWebGLRenderTarget = true;
    }
  }
  class bl extends gt {
    constructor(e = null, t = 1, n = 1, i = 1) {
      super(null), this.isDataArrayTexture = true, this.image = {
        data: e,
        width: t,
        height: n,
        depth: i
      }, this.magFilter = At, this.minFilter = At, this.wrapR = wn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class Cv extends zn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
      super(e, t, i), this.isWebGLArrayRenderTarget = true, this.depth = n, this.texture = new bl(null, e, t, n), this.texture.isRenderTargetTexture = true;
    }
  }
  class uu extends gt {
    constructor(e = null, t = 1, n = 1, i = 1) {
      super(null), this.isData3DTexture = true, this.image = {
        data: e,
        width: t,
        height: n,
        depth: i
      }, this.magFilter = At, this.minFilter = At, this.wrapR = wn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class Rv extends zn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
      super(e, t, i), this.isWebGL3DRenderTarget = true, this.depth = n, this.texture = new uu(null, e, t, n), this.texture.isRenderTargetTexture = true;
    }
  }
  class en {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      this.isQuaternion = true, this._x = e, this._y = t, this._z = n, this._w = i;
    }
    static slerpFlat(e, t, n, i, r, o, a) {
      let l = n[i + 0], c = n[i + 1], u = n[i + 2], d = n[i + 3];
      const h = r[o + 0], f = r[o + 1], m = r[o + 2], v = r[o + 3];
      if (a === 0) {
        e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d;
        return;
      }
      if (a === 1) {
        e[t + 0] = h, e[t + 1] = f, e[t + 2] = m, e[t + 3] = v;
        return;
      }
      if (d !== v || l !== h || c !== f || u !== m) {
        let g = 1 - a;
        const p = l * h + c * f + u * m + d * v, _ = p >= 0 ? 1 : -1, x = 1 - p * p;
        if (x > Number.EPSILON) {
          const E = Math.sqrt(x), S = Math.atan2(E, p * _);
          g = Math.sin(g * S) / E, a = Math.sin(a * S) / E;
        }
        const b = a * _;
        if (l = l * g + h * b, c = c * g + f * b, u = u * g + m * b, d = d * g + v * b, g === 1 - a) {
          const E = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
          l *= E, c *= E, u *= E, d *= E;
        }
      }
      e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d;
    }
    static multiplyQuaternionsFlat(e, t, n, i, r, o) {
      const a = n[i], l = n[i + 1], c = n[i + 2], u = n[i + 3], d = r[o], h = r[o + 1], f = r[o + 2], m = r[o + 3];
      return e[t] = a * m + u * d + l * f - c * h, e[t + 1] = l * m + u * h + c * d - a * f, e[t + 2] = c * m + u * f + a * h - l * d, e[t + 3] = u * m - a * d - l * h - c * f, e;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      this._w = e, this._onChangeCallback();
    }
    set(e, t, n, i) {
      return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
    }
    setFromEuler(e, t = true) {
      const n = e._x, i = e._y, r = e._z, o = e._order, a = Math.cos, l = Math.sin, c = a(n / 2), u = a(i / 2), d = a(r / 2), h = l(n / 2), f = l(i / 2), m = l(r / 2);
      switch (o) {
        case "XYZ":
          this._x = h * u * d + c * f * m, this._y = c * f * d - h * u * m, this._z = c * u * m + h * f * d, this._w = c * u * d - h * f * m;
          break;
        case "YXZ":
          this._x = h * u * d + c * f * m, this._y = c * f * d - h * u * m, this._z = c * u * m - h * f * d, this._w = c * u * d + h * f * m;
          break;
        case "ZXY":
          this._x = h * u * d - c * f * m, this._y = c * f * d + h * u * m, this._z = c * u * m + h * f * d, this._w = c * u * d - h * f * m;
          break;
        case "ZYX":
          this._x = h * u * d - c * f * m, this._y = c * f * d + h * u * m, this._z = c * u * m - h * f * d, this._w = c * u * d + h * f * m;
          break;
        case "YZX":
          this._x = h * u * d + c * f * m, this._y = c * f * d + h * u * m, this._z = c * u * m - h * f * d, this._w = c * u * d - h * f * m;
          break;
        case "XZY":
          this._x = h * u * d - c * f * m, this._y = c * f * d - h * u * m, this._z = c * u * m + h * f * d, this._w = c * u * d + h * f * m;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
      }
      return t === true && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      const n = t / 2, i = Math.sin(n);
      return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e) {
      const t = e.elements, n = t[0], i = t[4], r = t[8], o = t[1], a = t[5], l = t[9], c = t[2], u = t[6], d = t[10], h = n + a + d;
      if (h > 0) {
        const f = 0.5 / Math.sqrt(h + 1);
        this._w = 0.25 / f, this._x = (u - l) * f, this._y = (r - c) * f, this._z = (o - i) * f;
      } else if (n > a && n > d) {
        const f = 2 * Math.sqrt(1 + n - a - d);
        this._w = (u - l) / f, this._x = 0.25 * f, this._y = (i + o) / f, this._z = (r + c) / f;
      } else if (a > d) {
        const f = 2 * Math.sqrt(1 + a - n - d);
        this._w = (r - c) / f, this._x = (i + o) / f, this._y = 0.25 * f, this._z = (l + u) / f;
      } else {
        const f = 2 * Math.sqrt(1 + d - n - a);
        this._w = (o - i) / f, this._x = (r + c) / f, this._y = (l + u) / f, this._z = 0.25 * f;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let n = e.dot(t) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(mt(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      const n = this.angleTo(e);
      if (n === 0) return this;
      const i = Math.min(1, t / n);
      return this.slerp(e, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let e = this.length();
      return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
    }
    multiply(e) {
      return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      const n = e._x, i = e._y, r = e._z, o = e._w, a = t._x, l = t._y, c = t._z, u = t._w;
      return this._x = n * u + o * a + i * c - r * l, this._y = i * u + o * l + r * a - n * c, this._z = r * u + o * c + n * l - i * a, this._w = o * u - n * a - i * l - r * c, this._onChangeCallback(), this;
    }
    slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      const n = this._x, i = this._y, r = this._z, o = this._w;
      let a = o * e._w + n * e._x + i * e._y + r * e._z;
      if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
      const l = 1 - a * a;
      if (l <= Number.EPSILON) {
        const f = 1 - t;
        return this._w = f * o + t * this._w, this._x = f * n + t * this._x, this._y = f * i + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
      }
      const c = Math.sqrt(l), u = Math.atan2(c, a), d = Math.sin((1 - t) * u) / c, h = Math.sin(t * u) / c;
      return this._w = o * d + this._w * h, this._x = n * d + this._x * h, this._y = i * d + this._y * h, this._z = r * d + this._z * h, this._onChangeCallback(), this;
    }
    slerpQuaternions(e, t, n) {
      return this.copy(e).slerp(t, n);
    }
    random() {
      const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), r = Math.sqrt(n);
      return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
    }
    fromArray(e, t = 0) {
      return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
    }
    fromBufferAttribute(e, t) {
      return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class P {
    constructor(e = 0, t = 0, n = 0) {
      P.prototype.isVector3 = true, this.x = e, this.y = t, this.z = n;
    }
    set(e, t, n) {
      return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this;
    }
    multiplyVectors(e, t) {
      return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
    }
    applyEuler(e) {
      return this.applyQuaternion(ld.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(ld.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      const t = this.x, n = this.y, i = this.z, r = e.elements;
      return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      const t = this.x, n = this.y, i = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
      return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this;
    }
    applyQuaternion(e) {
      const t = this.x, n = this.y, i = this.z, r = e.x, o = e.y, a = e.z, l = e.w, c = 2 * (o * i - a * n), u = 2 * (a * t - r * i), d = 2 * (r * n - o * t);
      return this.x = t + l * c + o * d - a * u, this.y = n + l * u + a * c - r * d, this.z = i + l * d + r * u - o * c, this;
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
    }
    transformDirection(e) {
      const t = this.x, n = this.y, i = this.z, r = e.elements;
      return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
    }
    cross(e) {
      return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      const n = e.x, i = e.y, r = e.z, o = t.x, a = t.y, l = t.z;
      return this.x = i * l - r * a, this.y = r * o - n * l, this.z = n * a - i * o, this;
    }
    projectOnVector(e) {
      const t = e.lengthSq();
      if (t === 0) return this.set(0, 0, 0);
      const n = e.dot(this) / t;
      return this.copy(e).multiplyScalar(n);
    }
    projectOnPlane(e) {
      return sc.copy(this).projectOnVector(e), this.sub(sc);
    }
    reflect(e) {
      return this.sub(sc.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const n = this.dot(e) / t;
      return Math.acos(mt(n, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
      return t * t + n * n + i * i;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, n) {
      const i = Math.sin(t) * e;
      return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, n) {
      return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
    }
    setFromMatrixPosition(e) {
      const t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this;
    }
    setFromMatrixScale(e) {
      const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
      return this.x = t, this.y = n, this.z = i, this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
      return this.x = e._x, this.y = e._y, this.z = e._z, this;
    }
    setFromColor(e) {
      return this.x = e.r, this.y = e.g, this.z = e.b, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
      return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const sc = new P(), ld = new en();
  class Bt {
    constructor(e = new P(1 / 0, 1 / 0, 1 / 0), t = new P(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = true, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(An.fromArray(e, t));
      return this;
    }
    setFromBufferAttribute(e) {
      this.makeEmpty();
      for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(An.fromBufferAttribute(e, t));
      return this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const n = An.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    setFromObject(e, t = false) {
      return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = false) {
      e.updateWorldMatrix(false, false);
      const n = e.geometry;
      if (n !== void 0) {
        const r = n.getAttribute("position");
        if (t === true && r !== void 0 && e.isInstancedMesh !== true) for (let o = 0, a = r.count; o < a; o++) e.isMesh === true ? e.getVertexPosition(o, An) : An.fromBufferAttribute(r, o), An.applyMatrix4(e.matrixWorld), this.expandByPoint(An);
        else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), $o.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), $o.copy(n.boundingBox)), $o.applyMatrix4(e.matrixWorld), this.union($o);
      }
      const i = e.children;
      for (let r = 0, o = i.length; r < o; r++) this.expandByObject(i[r], t);
      return this;
    }
    containsPoint(e) {
      return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
    }
    getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e) {
      return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
    }
    intersectsSphere(e) {
      return this.clampPoint(e.center, An), An.distanceToSquared(e.center) <= e.radius * e.radius;
    }
    intersectsPlane(e) {
      let t, n;
      return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return false;
      this.getCenter(Rr), Zo.subVectors(this.max, Rr), Ls.subVectors(e.a, Rr), Ds.subVectors(e.b, Rr), Ns.subVectors(e.c, Rr), wi.subVectors(Ds, Ls), Ti.subVectors(Ns, Ds), Ki.subVectors(Ls, Ns);
      let t = [
        0,
        -wi.z,
        wi.y,
        0,
        -Ti.z,
        Ti.y,
        0,
        -Ki.z,
        Ki.y,
        wi.z,
        0,
        -wi.x,
        Ti.z,
        0,
        -Ti.x,
        Ki.z,
        0,
        -Ki.x,
        -wi.y,
        wi.x,
        0,
        -Ti.y,
        Ti.x,
        0,
        -Ki.y,
        Ki.x,
        0
      ];
      return !rc(t, Ls, Ds, Ns, Zo) || (t = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], !rc(t, Ls, Ds, Ns, Zo)) ? false : (Jo.crossVectors(wi, Ti), t = [
        Jo.x,
        Jo.y,
        Jo.z
      ], rc(t, Ls, Ds, Ns, Zo));
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return this.clampPoint(e, An).distanceTo(e);
    }
    getBoundingSphere(e) {
      return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(An).length() * 0.5), e;
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return this.isEmpty() ? this : (ti[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ti[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ti[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ti[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ti[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ti[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ti[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ti[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ti), this);
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  const ti = [
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P()
  ], An = new P(), $o = new Bt(), Ls = new P(), Ds = new P(), Ns = new P(), wi = new P(), Ti = new P(), Ki = new P(), Rr = new P(), Zo = new P(), Jo = new P(), ji = new P();
  function rc(s, e, t, n, i) {
    for (let r = 0, o = s.length - 3; r <= o; r += 3) {
      ji.fromArray(s, r);
      const a = i.x * Math.abs(ji.x) + i.y * Math.abs(ji.y) + i.z * Math.abs(ji.z), l = e.dot(ji), c = t.dot(ji), u = n.dot(ji);
      if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return false;
    }
    return true;
  }
  const Pv = new Bt(), Pr = new P(), oc = new P();
  class kt {
    constructor(e = new P(), t = -1) {
      this.isSphere = true, this.center = e, this.radius = t;
    }
    set(e, t) {
      return this.center.copy(e), this.radius = t, this;
    }
    setFromPoints(e, t) {
      const n = this.center;
      t !== void 0 ? n.copy(t) : Pv.setFromPoints(e).getCenter(n);
      let i = 0;
      for (let r = 0, o = e.length; r < o; r++) i = Math.max(i, n.distanceToSquared(e[r]));
      return this.radius = Math.sqrt(i), this;
    }
    copy(e) {
      return this.center.copy(e.center), this.radius = e.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      const n = this.center.distanceToSquared(e);
      return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
    }
    getBoundingBox(e) {
      return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
    }
    translate(e) {
      return this.center.add(e), this;
    }
    expandByPoint(e) {
      if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
      Pr.subVectors(e, this.center);
      const t = Pr.lengthSq();
      if (t > this.radius * this.radius) {
        const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
        this.center.addScaledVector(Pr, i / n), this.radius += i;
      }
      return this;
    }
    union(e) {
      return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (oc.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Pr.copy(e.center).add(oc)), this.expandByPoint(Pr.copy(e.center).sub(oc))), this);
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const ni = new P(), ac = new P(), Ko = new P(), Ei = new P(), lc = new P(), jo = new P(), cc = new P();
  class yr {
    constructor(e = new P(), t = new P(0, 0, -1)) {
      this.origin = e, this.direction = t;
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return t.copy(this.origin).addScaledVector(this.direction, e);
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, ni)), this;
    }
    closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      const n = t.dot(this.direction);
      return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      const t = ni.subVectors(e, this.origin).dot(this.direction);
      return t < 0 ? this.origin.distanceToSquared(e) : (ni.copy(this.origin).addScaledVector(this.direction, t), ni.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, n, i) {
      ac.copy(e).add(t).multiplyScalar(0.5), Ko.copy(t).sub(e).normalize(), Ei.copy(this.origin).sub(ac);
      const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(Ko), a = Ei.dot(this.direction), l = -Ei.dot(Ko), c = Ei.lengthSq(), u = Math.abs(1 - o * o);
      let d, h, f, m;
      if (u > 0) if (d = o * l - a, h = o * a - l, m = r * u, d >= 0) if (h >= -m) if (h <= m) {
        const v = 1 / u;
        d *= v, h *= v, f = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c;
      } else h = r, d = Math.max(0, -(o * h + a)), f = -d * d + h * (h + 2 * l) + c;
      else h = -r, d = Math.max(0, -(o * h + a)), f = -d * d + h * (h + 2 * l) + c;
      else h <= -m ? (d = Math.max(0, -(-o * r + a)), h = d > 0 ? -r : Math.min(Math.max(-r, -l), r), f = -d * d + h * (h + 2 * l) + c) : h <= m ? (d = 0, h = Math.min(Math.max(-r, -l), r), f = h * (h + 2 * l) + c) : (d = Math.max(0, -(o * r + a)), h = d > 0 ? r : Math.min(Math.max(-r, -l), r), f = -d * d + h * (h + 2 * l) + c);
      else h = o > 0 ? -r : r, d = Math.max(0, -(o * h + a)), f = -d * d + h * (h + 2 * l) + c;
      return n && n.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(ac).addScaledVector(Ko, h), f;
    }
    intersectSphere(e, t) {
      ni.subVectors(e.center, this.origin);
      const n = ni.dot(this.direction), i = ni.dot(ni) - n * n, r = e.radius * e.radius;
      if (i > r) return null;
      const o = Math.sqrt(r - i), a = n - o, l = n + o;
      return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      const t = e.normal.dot(this.direction);
      if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
      const n = -(this.origin.dot(e.normal) + e.constant) / t;
      return n >= 0 ? n : null;
    }
    intersectPlane(e, t) {
      const n = this.distanceToPlane(e);
      return n === null ? null : this.at(n, t);
    }
    intersectsPlane(e) {
      const t = e.distanceToPoint(this.origin);
      return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let n, i, r, o, a, l;
      const c = 1 / this.direction.x, u = 1 / this.direction.y, d = 1 / this.direction.z, h = this.origin;
      return c >= 0 ? (n = (e.min.x - h.x) * c, i = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c, i = (e.min.x - h.x) * c), u >= 0 ? (r = (e.min.y - h.y) * u, o = (e.max.y - h.y) * u) : (r = (e.max.y - h.y) * u, o = (e.min.y - h.y) * u), n > o || r > i || ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), d >= 0 ? (a = (e.min.z - h.z) * d, l = (e.max.z - h.z) * d) : (a = (e.max.z - h.z) * d, l = (e.min.z - h.z) * d), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t);
    }
    intersectsBox(e) {
      return this.intersectBox(e, ni) !== null;
    }
    intersectTriangle(e, t, n, i, r) {
      lc.subVectors(t, e), jo.subVectors(n, e), cc.crossVectors(lc, jo);
      let o = this.direction.dot(cc), a;
      if (o > 0) {
        if (i) return null;
        a = 1;
      } else if (o < 0) a = -1, o = -o;
      else return null;
      Ei.subVectors(this.origin, e);
      const l = a * this.direction.dot(jo.crossVectors(Ei, jo));
      if (l < 0) return null;
      const c = a * this.direction.dot(lc.cross(Ei));
      if (c < 0 || l + c > o) return null;
      const u = -a * Ei.dot(cc);
      return u < 0 ? null : this.at(u / o, r);
    }
    applyMatrix4(e) {
      return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class De {
    constructor(e, t, n, i, r, o, a, l, c, u, d, h, f, m, v, g) {
      De.prototype.isMatrix4 = true, this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, c, u, d, h, f, m, v, g);
    }
    set(e, t, n, i, r, o, a, l, c, u, d, h, f, m, v, g) {
      const p = this.elements;
      return p[0] = e, p[4] = t, p[8] = n, p[12] = i, p[1] = r, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = u, p[10] = d, p[14] = h, p[3] = f, p[7] = m, p[11] = v, p[15] = g, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new De().fromArray(this.elements);
    }
    copy(e) {
      const t = this.elements, n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
    }
    copyPosition(e) {
      const t = this.elements, n = e.elements;
      return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
    }
    setFromMatrix3(e) {
      const t = e.elements;
      return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e, t, n) {
      return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e, t, n) {
      return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e) {
      const t = this.elements, n = e.elements, i = 1 / Us.setFromMatrixColumn(e, 0).length(), r = 1 / Us.setFromMatrixColumn(e, 1).length(), o = 1 / Us.setFromMatrixColumn(e, 2).length();
      return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromEuler(e) {
      const t = this.elements, n = e.x, i = e.y, r = e.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(i), c = Math.sin(i), u = Math.cos(r), d = Math.sin(r);
      if (e.order === "XYZ") {
        const h = o * u, f = o * d, m = a * u, v = a * d;
        t[0] = l * u, t[4] = -l * d, t[8] = c, t[1] = f + m * c, t[5] = h - v * c, t[9] = -a * l, t[2] = v - h * c, t[6] = m + f * c, t[10] = o * l;
      } else if (e.order === "YXZ") {
        const h = l * u, f = l * d, m = c * u, v = c * d;
        t[0] = h + v * a, t[4] = m * a - f, t[8] = o * c, t[1] = o * d, t[5] = o * u, t[9] = -a, t[2] = f * a - m, t[6] = v + h * a, t[10] = o * l;
      } else if (e.order === "ZXY") {
        const h = l * u, f = l * d, m = c * u, v = c * d;
        t[0] = h - v * a, t[4] = -o * d, t[8] = m + f * a, t[1] = f + m * a, t[5] = o * u, t[9] = v - h * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
      } else if (e.order === "ZYX") {
        const h = o * u, f = o * d, m = a * u, v = a * d;
        t[0] = l * u, t[4] = m * c - f, t[8] = h * c + v, t[1] = l * d, t[5] = v * c + h, t[9] = f * c - m, t[2] = -c, t[6] = a * l, t[10] = o * l;
      } else if (e.order === "YZX") {
        const h = o * l, f = o * c, m = a * l, v = a * c;
        t[0] = l * u, t[4] = v - h * d, t[8] = m * d + f, t[1] = d, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = f * d + m, t[10] = h - v * d;
      } else if (e.order === "XZY") {
        const h = o * l, f = o * c, m = a * l, v = a * c;
        t[0] = l * u, t[4] = -d, t[8] = c * u, t[1] = h * d + v, t[5] = o * u, t[9] = f * d - m, t[2] = m * d - f, t[6] = a * u, t[10] = v * d + h;
      }
      return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromQuaternion(e) {
      return this.compose(Iv, e, Lv);
    }
    lookAt(e, t, n) {
      const i = this.elements;
      return on.subVectors(e, t), on.lengthSq() === 0 && (on.z = 1), on.normalize(), Ai.crossVectors(n, on), Ai.lengthSq() === 0 && (Math.abs(n.z) === 1 ? on.x += 1e-4 : on.z += 1e-4, on.normalize(), Ai.crossVectors(n, on)), Ai.normalize(), Qo.crossVectors(on, Ai), i[0] = Ai.x, i[4] = Qo.x, i[8] = on.x, i[1] = Ai.y, i[5] = Qo.y, i[9] = on.y, i[2] = Ai.z, i[6] = Qo.z, i[10] = on.z, this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[4], l = n[8], c = n[12], u = n[1], d = n[5], h = n[9], f = n[13], m = n[2], v = n[6], g = n[10], p = n[14], _ = n[3], x = n[7], b = n[11], E = n[15], S = i[0], w = i[4], A = i[8], M = i[12], y = i[1], C = i[5], N = i[9], I = i[13], D = i[2], O = i[6], z = i[10], B = i[14], U = i[3], G = i[7], V = i[11], K = i[15];
      return r[0] = o * S + a * y + l * D + c * U, r[4] = o * w + a * C + l * O + c * G, r[8] = o * A + a * N + l * z + c * V, r[12] = o * M + a * I + l * B + c * K, r[1] = u * S + d * y + h * D + f * U, r[5] = u * w + d * C + h * O + f * G, r[9] = u * A + d * N + h * z + f * V, r[13] = u * M + d * I + h * B + f * K, r[2] = m * S + v * y + g * D + p * U, r[6] = m * w + v * C + g * O + p * G, r[10] = m * A + v * N + g * z + p * V, r[14] = m * M + v * I + g * B + p * K, r[3] = _ * S + x * y + b * D + E * U, r[7] = _ * w + x * C + b * O + E * G, r[11] = _ * A + x * N + b * z + E * V, r[15] = _ * M + x * I + b * B + E * K, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
    }
    determinant() {
      const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], o = e[1], a = e[5], l = e[9], c = e[13], u = e[2], d = e[6], h = e[10], f = e[14], m = e[3], v = e[7], g = e[11], p = e[15];
      return m * (+r * l * d - i * c * d - r * a * h + n * c * h + i * a * f - n * l * f) + v * (+t * l * f - t * c * h + r * o * h - i * o * f + i * c * u - r * l * u) + g * (+t * c * d - t * a * f - r * o * d + n * o * f + r * a * u - n * c * u) + p * (-i * a * u - t * l * d + t * a * h + i * o * d - n * o * h + n * l * u);
    }
    transpose() {
      const e = this.elements;
      let t;
      return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
    }
    setPosition(e, t, n) {
      const i = this.elements;
      return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
    }
    invert() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], c = e[7], u = e[8], d = e[9], h = e[10], f = e[11], m = e[12], v = e[13], g = e[14], p = e[15], _ = d * g * c - v * h * c + v * l * f - a * g * f - d * l * p + a * h * p, x = m * h * c - u * g * c - m * l * f + o * g * f + u * l * p - o * h * p, b = u * v * c - m * d * c + m * a * f - o * v * f - u * a * p + o * d * p, E = m * d * l - u * v * l - m * a * h + o * v * h + u * a * g - o * d * g, S = t * _ + n * x + i * b + r * E;
      if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const w = 1 / S;
      return e[0] = _ * w, e[1] = (v * h * r - d * g * r - v * i * f + n * g * f + d * i * p - n * h * p) * w, e[2] = (a * g * r - v * l * r + v * i * c - n * g * c - a * i * p + n * l * p) * w, e[3] = (d * l * r - a * h * r - d * i * c + n * h * c + a * i * f - n * l * f) * w, e[4] = x * w, e[5] = (u * g * r - m * h * r + m * i * f - t * g * f - u * i * p + t * h * p) * w, e[6] = (m * l * r - o * g * r - m * i * c + t * g * c + o * i * p - t * l * p) * w, e[7] = (o * h * r - u * l * r + u * i * c - t * h * c - o * i * f + t * l * f) * w, e[8] = b * w, e[9] = (m * d * r - u * v * r - m * n * f + t * v * f + u * n * p - t * d * p) * w, e[10] = (o * v * r - m * a * r + m * n * c - t * v * c - o * n * p + t * a * p) * w, e[11] = (u * a * r - o * d * r - u * n * c + t * d * c + o * n * f - t * a * f) * w, e[12] = E * w, e[13] = (u * v * i - m * d * i + m * n * h - t * v * h - u * n * g + t * d * g) * w, e[14] = (m * a * i - o * v * i - m * n * l + t * v * l + o * n * g - t * a * g) * w, e[15] = (o * d * i - u * a * i + u * n * l - t * d * l - o * n * h + t * a * h) * w, this;
    }
    scale(e) {
      const t = this.elements, n = e.x, i = e.y, r = e.z;
      return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
    }
    getMaxScaleOnAxis() {
      const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, n, i));
    }
    makeTranslation(e, t, n) {
      return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      const n = Math.cos(t), i = Math.sin(t), r = 1 - n, o = e.x, a = e.y, l = e.z, c = r * o, u = r * a;
      return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, u * a + n, u * l - i * o, 0, c * l - i * a, u * l + i * o, r * l * l + n, 0, 0, 0, 0, 1), this;
    }
    makeScale(e, t, n) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, n, i, r, o) {
      return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, n) {
      const i = this.elements, r = t._x, o = t._y, a = t._z, l = t._w, c = r + r, u = o + o, d = a + a, h = r * c, f = r * u, m = r * d, v = o * u, g = o * d, p = a * d, _ = l * c, x = l * u, b = l * d, E = n.x, S = n.y, w = n.z;
      return i[0] = (1 - (v + p)) * E, i[1] = (f + b) * E, i[2] = (m - x) * E, i[3] = 0, i[4] = (f - b) * S, i[5] = (1 - (h + p)) * S, i[6] = (g + _) * S, i[7] = 0, i[8] = (m + x) * w, i[9] = (g - _) * w, i[10] = (1 - (h + v)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
    }
    decompose(e, t, n) {
      const i = this.elements;
      let r = Us.set(i[0], i[1], i[2]).length();
      const o = Us.set(i[4], i[5], i[6]).length(), a = Us.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Cn.copy(this);
      const c = 1 / r, u = 1 / o, d = 1 / a;
      return Cn.elements[0] *= c, Cn.elements[1] *= c, Cn.elements[2] *= c, Cn.elements[4] *= u, Cn.elements[5] *= u, Cn.elements[6] *= u, Cn.elements[8] *= d, Cn.elements[9] *= d, Cn.elements[10] *= d, t.setFromRotationMatrix(Cn), n.x = r, n.y = o, n.z = a, this;
    }
    makePerspective(e, t, n, i, r, o, a = Yn) {
      const l = this.elements, c = 2 * r / (t - e), u = 2 * r / (n - i), d = (t + e) / (t - e), h = (n + i) / (n - i);
      let f, m;
      if (a === Yn) f = -(o + r) / (o - r), m = -2 * o * r / (o - r);
      else if (a === po) f = -o / (o - r), m = -o * r / (o - r);
      else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
      return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = u, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = f, l[14] = m, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
    }
    makeOrthographic(e, t, n, i, r, o, a = Yn) {
      const l = this.elements, c = 1 / (t - e), u = 1 / (n - i), d = 1 / (o - r), h = (t + e) * c, f = (n + i) * u;
      let m, v;
      if (a === Yn) m = (o + r) * d, v = -2 * d;
      else if (a === po) m = r * d, v = -1 * d;
      else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
      return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = v, l[14] = -m, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
    }
    equals(e) {
      const t = this.elements, n = e.elements;
      for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return false;
      return true;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
    }
  }
  const Us = new P(), Cn = new De(), Iv = new P(0, 0, 0), Lv = new P(1, 1, 1), Ai = new P(), Qo = new P(), on = new P(), cd = new De(), hd = new en();
  class mn {
    constructor(e = 0, t = 0, n = 0, i = mn.DEFAULT_ORDER) {
      this.isEuler = true, this._x = e, this._y = t, this._z = n, this._order = i;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      this._order = e, this._onChangeCallback();
    }
    set(e, t, n, i = this._order) {
      return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e, t = this._order, n = true) {
      const i = e.elements, r = i[0], o = i[4], a = i[8], l = i[1], c = i[5], u = i[9], d = i[2], h = i[6], f = i[10];
      switch (t) {
        case "XYZ":
          this._y = Math.asin(mt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(h, c), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-mt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(mt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
          break;
        case "ZYX":
          this._y = Math.asin(-mt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(h, f), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
          break;
        case "YZX":
          this._z = Math.asin(mt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(a, f));
          break;
        case "XZY":
          this._z = Math.asin(-mt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, f), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
      }
      return this._order = t, n === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, n) {
      return cd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(cd, t, n);
    }
    setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
      return hd.setFromEuler(this), this.setFromQuaternion(hd, e);
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
    }
    fromArray(e) {
      return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  mn.DEFAULT_ORDER = "XYZ";
  class Sl {
    constructor() {
      this.mask = 1;
    }
    set(e) {
      this.mask = (1 << e | 0) >>> 0;
    }
    enable(e) {
      this.mask |= 1 << e | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e) {
      this.mask ^= 1 << e | 0;
    }
    disable(e) {
      this.mask &= ~(1 << e | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
      return (this.mask & (1 << e | 0)) !== 0;
    }
  }
  let Dv = 0;
  const ud = new P(), Os = new en(), ii = new De(), ea = new P(), Ir = new P(), Nv = new P(), Uv = new en(), dd = new P(1, 0, 0), fd = new P(0, 1, 0), pd = new P(0, 0, 1), md = {
    type: "added"
  }, Ov = {
    type: "removed"
  }, zs = {
    type: "childadded",
    child: null
  }, hc = {
    type: "childremoved",
    child: null
  };
  class Qe extends Mi {
    constructor() {
      super(), this.isObject3D = true, Object.defineProperty(this, "id", {
        value: Dv++
      }), this.uuid = fn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Qe.DEFAULT_UP.clone();
      const e = new P(), t = new mn(), n = new en(), i = new P(1, 1, 1);
      function r() {
        n.setFromEuler(t, false);
      }
      function o() {
        t.setFromQuaternion(n, void 0, false);
      }
      t._onChange(r), n._onChange(o), Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: e
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: t
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: n
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: i
        },
        modelViewMatrix: {
          value: new De()
        },
        normalMatrix: {
          value: new Fe()
        }
      }), this.matrix = new De(), this.matrixWorld = new De(), this.matrixAutoUpdate = Qe.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Qe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Sl(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeShadow() {
    }
    onAfterShadow() {
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
      return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, true);
    }
    setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
      this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
      return Os.setFromAxisAngle(e, t), this.quaternion.multiply(Os), this;
    }
    rotateOnWorldAxis(e, t) {
      return Os.setFromAxisAngle(e, t), this.quaternion.premultiply(Os), this;
    }
    rotateX(e) {
      return this.rotateOnAxis(dd, e);
    }
    rotateY(e) {
      return this.rotateOnAxis(fd, e);
    }
    rotateZ(e) {
      return this.rotateOnAxis(pd, e);
    }
    translateOnAxis(e, t) {
      return ud.copy(e).applyQuaternion(this.quaternion), this.position.add(ud.multiplyScalar(t)), this;
    }
    translateX(e) {
      return this.translateOnAxis(dd, e);
    }
    translateY(e) {
      return this.translateOnAxis(fd, e);
    }
    translateZ(e) {
      return this.translateOnAxis(pd, e);
    }
    localToWorld(e) {
      return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
      return this.updateWorldMatrix(true, false), e.applyMatrix4(ii.copy(this.matrixWorld).invert());
    }
    lookAt(e, t, n) {
      e.isVector3 ? ea.copy(e) : ea.set(e, t, n);
      const i = this.parent;
      this.updateWorldMatrix(true, false), Ir.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ii.lookAt(Ir, ea, this.up) : ii.lookAt(ea, Ir, this.up), this.quaternion.setFromRotationMatrix(ii), i && (ii.extractRotation(i.matrixWorld), Os.setFromRotationMatrix(ii), this.quaternion.premultiply(Os.invert()));
    }
    add(e) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(md), zs.child = e, this.dispatchEvent(zs), zs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
    }
    remove(e) {
      if (arguments.length > 1) {
        for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
        return this;
      }
      const t = this.children.indexOf(e);
      return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Ov), hc.child = e, this.dispatchEvent(hc), hc.child = null), this;
    }
    removeFromParent() {
      const e = this.parent;
      return e !== null && e.remove(this), this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(e) {
      return this.updateWorldMatrix(true, false), ii.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), ii.multiply(e.parent.matrixWorld)), e.applyMatrix4(ii), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(md), zs.child = e, this.dispatchEvent(zs), zs.child = null, this;
    }
    getObjectById(e) {
      return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
      return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const o = this.children[n].getObjectByProperty(e, t);
        if (o !== void 0) return o;
      }
    }
    getObjectsByProperty(e, t, n = []) {
      this[e] === t && n.push(this);
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) i[r].getObjectsByProperty(e, t, n);
      return n;
    }
    getWorldPosition(e) {
      return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Ir, e, Nv), e;
    }
    getWorldScale(e) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Ir, Uv, e), e;
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(true, false);
      const t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {
    }
    traverse(e) {
      e(this);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
    }
    traverseVisible(e) {
      if (this.visible === false) return;
      e(this);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
    }
    traverseAncestors(e) {
      const t = this.parent;
      t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) {
        const r = t[n];
        (r.matrixWorldAutoUpdate === true || e === true) && r.updateMatrixWorld(e);
      }
    }
    updateWorldMatrix(e, t) {
      const n = this.parent;
      if (e === true && n !== null && n.matrixWorldAutoUpdate === true && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === true) {
        const i = this.children;
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r];
          a.matrixWorldAutoUpdate === true && a.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string", n = {};
      t && (e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }, n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      const i = {};
      i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === true && (i.castShadow = true), this.receiveShadow === true && (i.receiveShadow = true), this.visible === false && (i.visible = false), this.frustumCulled === false && (i.frustumCulled = false), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === false && (i.matrixAutoUpdate = false), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((a) => ({
        boxInitialized: a.boxInitialized,
        boxMin: a.box.min.toArray(),
        boxMax: a.box.max.toArray(),
        sphereInitialized: a.sphereInitialized,
        sphereRadius: a.sphere.radius,
        sphereCenter: a.sphere.center.toArray()
      })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = {
        center: i.boundingSphere.center.toArray(),
        radius: i.boundingSphere.radius
      }), this.boundingBox !== null && (i.boundingBox = {
        min: i.boundingBox.min.toArray(),
        max: i.boundingBox.max.toArray()
      }));
      function r(a, l) {
        return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
      }
      if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (i.environment = this.environment.toJSON(e).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(e.geometries, this.geometry);
        const a = this.geometry.parameters;
        if (a !== void 0 && a.shapes !== void 0) {
          const l = a.shapes;
          if (Array.isArray(l)) for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c];
            r(e.shapes, d);
          }
          else r(e.shapes, l);
        }
      }
      if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++) a.push(r(e.materials, this.material[l]));
        i.material = a;
      } else i.material = r(e.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let a = 0; a < this.animations.length; a++) {
          const l = this.animations[a];
          i.animations.push(r(e.animations, l));
        }
      }
      if (t) {
        const a = o(e.geometries), l = o(e.materials), c = o(e.textures), u = o(e.images), d = o(e.shapes), h = o(e.skeletons), f = o(e.animations), m = o(e.nodes);
        a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), d.length > 0 && (n.shapes = d), h.length > 0 && (n.skeletons = h), f.length > 0 && (n.animations = f), m.length > 0 && (n.nodes = m);
      }
      return n.object = i, n;
      function o(a) {
        const l = [];
        for (const c in a) {
          const u = a[c];
          delete u.metadata, l.push(u);
        }
        return l;
      }
    }
    clone(e) {
      return new this.constructor().copy(this, e);
    }
    copy(e, t = true) {
      if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
      return this;
    }
  }
  Qe.DEFAULT_UP = new P(0, 1, 0);
  Qe.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Qe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  const Rn = new P(), si = new P(), uc = new P(), ri = new P(), Fs = new P(), Bs = new P(), gd = new P(), dc = new P(), fc = new P(), pc = new P();
  class un {
    constructor(e = new P(), t = new P(), n = new P()) {
      this.a = e, this.b = t, this.c = n;
    }
    static getNormal(e, t, n, i) {
      i.subVectors(n, t), Rn.subVectors(e, t), i.cross(Rn);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(e, t, n, i, r) {
      Rn.subVectors(i, t), si.subVectors(n, t), uc.subVectors(e, t);
      const o = Rn.dot(Rn), a = Rn.dot(si), l = Rn.dot(uc), c = si.dot(si), u = si.dot(uc), d = o * c - a * a;
      if (d === 0) return r.set(0, 0, 0), null;
      const h = 1 / d, f = (c * l - a * u) * h, m = (o * u - a * l) * h;
      return r.set(1 - f - m, m, f);
    }
    static containsPoint(e, t, n, i) {
      return this.getBarycoord(e, t, n, i, ri) === null ? false : ri.x >= 0 && ri.y >= 0 && ri.x + ri.y <= 1;
    }
    static getInterpolation(e, t, n, i, r, o, a, l) {
      return this.getBarycoord(e, t, n, i, ri) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, ri.x), l.addScaledVector(o, ri.y), l.addScaledVector(a, ri.z), l);
    }
    static isFrontFacing(e, t, n, i) {
      return Rn.subVectors(n, t), si.subVectors(e, t), Rn.cross(si).dot(i) < 0;
    }
    set(e, t, n) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
    }
    setFromPointsAndIndices(e, t, n, i) {
      return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
    }
    setFromAttributeAndIndices(e, t, n, i) {
      return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return Rn.subVectors(this.c, this.b), si.subVectors(this.a, this.b), Rn.cross(si).length() * 0.5;
    }
    getMidpoint(e) {
      return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e) {
      return un.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
      return un.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getInterpolation(e, t, n, i, r) {
      return un.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
    }
    containsPoint(e) {
      return un.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return un.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      const n = this.a, i = this.b, r = this.c;
      let o, a;
      Fs.subVectors(i, n), Bs.subVectors(r, n), dc.subVectors(e, n);
      const l = Fs.dot(dc), c = Bs.dot(dc);
      if (l <= 0 && c <= 0) return t.copy(n);
      fc.subVectors(e, i);
      const u = Fs.dot(fc), d = Bs.dot(fc);
      if (u >= 0 && d <= u) return t.copy(i);
      const h = l * d - u * c;
      if (h <= 0 && l >= 0 && u <= 0) return o = l / (l - u), t.copy(n).addScaledVector(Fs, o);
      pc.subVectors(e, r);
      const f = Fs.dot(pc), m = Bs.dot(pc);
      if (m >= 0 && f <= m) return t.copy(r);
      const v = f * c - l * m;
      if (v <= 0 && c >= 0 && m <= 0) return a = c / (c - m), t.copy(n).addScaledVector(Bs, a);
      const g = u * m - f * d;
      if (g <= 0 && d - u >= 0 && f - m >= 0) return gd.subVectors(r, i), a = (d - u) / (d - u + (f - m)), t.copy(i).addScaledVector(gd, a);
      const p = 1 / (g + v + h);
      return o = v * p, a = h * p, t.copy(n).addScaledVector(Fs, o).addScaledVector(Bs, a);
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  }
  const Nm = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, Ci = {
    h: 0,
    s: 0,
    l: 0
  }, ta = {
    h: 0,
    s: 0,
    l: 0
  };
  function mc(s, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
  }
  class ye {
    constructor(e, t, n) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
    }
    set(e, t, n) {
      if (t === void 0 && n === void 0) {
        const i = e;
        i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
      } else this.setRGB(e, t, n);
      return this;
    }
    setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this;
    }
    setHex(e, t = Mn) {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, st.toWorkingColorSpace(this, t), this;
    }
    setRGB(e, t, n, i = st.workingColorSpace) {
      return this.r = e, this.g = t, this.b = n, st.toWorkingColorSpace(this, i), this;
    }
    setHSL(e, t, n, i = st.workingColorSpace) {
      if (e = hu(e, 1), t = mt(t, 0, 1), n = mt(n, 0, 1), t === 0) this.r = this.g = this.b = n;
      else {
        const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - r;
        this.r = mc(o, r, e + 1 / 3), this.g = mc(o, r, e), this.b = mc(o, r, e - 1 / 3);
      }
      return st.toWorkingColorSpace(this, i), this;
    }
    setStyle(e, t = Mn) {
      function n(r) {
        r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
      }
      let i;
      if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
        let r;
        const o = i[1], a = i[2];
        switch (o) {
          case "rgb":
          case "rgba":
            if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
            if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
            break;
          case "hsl":
          case "hsla":
            if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + e);
        }
      } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
        const r = i[1], o = r.length;
        if (o === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
        if (o === 6) return this.setHex(parseInt(r, 16), t);
        console.warn("THREE.Color: Invalid hex color " + e);
      } else if (e && e.length > 0) return this.setColorName(e, t);
      return this;
    }
    setColorName(e, t = Mn) {
      const n = Nm[e.toLowerCase()];
      return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }
    copySRGBToLinear(e) {
      return this.r = rr(e.r), this.g = rr(e.g), this.b = rr(e.b), this;
    }
    copyLinearToSRGB(e) {
      return this.r = nc(e.r), this.g = nc(e.g), this.b = nc(e.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e = Mn) {
      return st.fromWorkingColorSpace(zt.copy(this), e), Math.round(mt(zt.r * 255, 0, 255)) * 65536 + Math.round(mt(zt.g * 255, 0, 255)) * 256 + Math.round(mt(zt.b * 255, 0, 255));
    }
    getHexString(e = Mn) {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = st.workingColorSpace) {
      st.fromWorkingColorSpace(zt.copy(this), t);
      const n = zt.r, i = zt.g, r = zt.b, o = Math.max(n, i, r), a = Math.min(n, i, r);
      let l, c;
      const u = (a + o) / 2;
      if (a === o) l = 0, c = 0;
      else {
        const d = o - a;
        switch (c = u <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
          case n:
            l = (i - r) / d + (i < r ? 6 : 0);
            break;
          case i:
            l = (r - n) / d + 2;
            break;
          case r:
            l = (n - i) / d + 4;
            break;
        }
        l /= 6;
      }
      return e.h = l, e.s = c, e.l = u, e;
    }
    getRGB(e, t = st.workingColorSpace) {
      return st.fromWorkingColorSpace(zt.copy(this), t), e.r = zt.r, e.g = zt.g, e.b = zt.b, e;
    }
    getStyle(e = Mn) {
      st.fromWorkingColorSpace(zt.copy(this), e);
      const t = zt.r, n = zt.g, i = zt.b;
      return e !== Mn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
    }
    offsetHSL(e, t, n) {
      return this.getHSL(Ci), this.setHSL(Ci.h + e, Ci.s + t, Ci.l + n);
    }
    add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }
    addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }
    addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this;
    }
    sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }
    multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }
    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }
    lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }
    lerpColors(e, t, n) {
      return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
    }
    lerpHSL(e, t) {
      this.getHSL(Ci), e.getHSL(ta);
      const n = Zr(Ci.h, ta.h, t), i = Zr(Ci.s, ta.s, t), r = Zr(Ci.l, ta.l, t);
      return this.setHSL(n, i, r), this;
    }
    setFromVector3(e) {
      return this.r = e.x, this.g = e.y, this.b = e.z, this;
    }
    applyMatrix3(e) {
      const t = this.r, n = this.g, i = this.b, r = e.elements;
      return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }
    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const zt = new ye();
  ye.NAMES = Nm;
  let zv = 0;
  class Ht extends Mi {
    constructor() {
      super(), this.isMaterial = true, Object.defineProperty(this, "id", {
        value: zv++
      }), this.uuid = fn(), this.name = "", this.type = "Material", this.blending = bs, this.side = mi, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = qa, this.blendDst = $a, this.blendEquation = Di, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ye(0, 0, 0), this.blendAlpha = 0, this.depthFunc = no, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Ch, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = fs, this.stencilZFail = fs, this.stencilZPass = fs, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e) {
      if (e !== void 0) for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      t && (e = {
        textures: {},
        images: {}
      });
      const n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== bs && (n.blending = this.blending), this.side !== mi && (n.side = this.side), this.vertexColors === true && (n.vertexColors = true), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === true && (n.transparent = true), this.blendSrc !== qa && (n.blendSrc = this.blendSrc), this.blendDst !== $a && (n.blendDst = this.blendDst), this.blendEquation !== Di && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== no && (n.depthFunc = this.depthFunc), this.depthTest === false && (n.depthTest = this.depthTest), this.depthWrite === false && (n.depthWrite = this.depthWrite), this.colorWrite === false && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Ch && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== fs && (n.stencilFail = this.stencilFail), this.stencilZFail !== fs && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== fs && (n.stencilZPass = this.stencilZPass), this.stencilWrite === true && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === true && (n.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === true && (n.dithering = true), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === true && (n.alphaHash = true), this.alphaToCoverage === true && (n.alphaToCoverage = true), this.premultipliedAlpha === true && (n.premultipliedAlpha = true), this.forceSinglePass === true && (n.forceSinglePass = true), this.wireframe === true && (n.wireframe = true), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n.flatShading = true), this.visible === false && (n.visible = false), this.toneMapped === false && (n.toneMapped = false), this.fog === false && (n.fog = false), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
      function i(r) {
        const o = [];
        for (const a in r) {
          const l = r[a];
          delete l.metadata, o.push(l);
        }
        return o;
      }
      if (t) {
        const r = i(e.textures), o = i(e.images);
        r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
      const t = e.clippingPlanes;
      let n = null;
      if (t !== null) {
        const i = t.length;
        n = new Array(i);
        for (let r = 0; r !== i; ++r) n[r] = t[r].clone();
      }
      return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
  }
  class Xi extends Ht {
    constructor(e) {
      super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new ye(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new mn(), this.combine = Lo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
  }
  const li = Fv();
  function Fv() {
    const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), n = new Uint32Array(512), i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
      const c = l - 127;
      c < -27 ? (n[l] = 0, n[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, i[l] = -c - 1, i[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, i[l] = 13, i[l | 256] = 13);
    }
    const r = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
      let c = l << 13, u = 0;
      for (; !(c & 8388608); ) c <<= 1, u -= 8388608;
      c &= -8388609, u += 947912704, r[l] = c | u;
    }
    for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l) o[l] = l << 23;
    o[31] = 1199570944, o[32] = 2147483648;
    for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
    return {
      floatView: e,
      uint32View: t,
      baseTable: n,
      shiftTable: i,
      mantissaTable: r,
      exponentTable: o,
      offsetTable: a
    };
  }
  function Kt(s) {
    Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = mt(s, -65504, 65504), li.floatView[0] = s;
    const e = li.uint32View[0], t = e >> 23 & 511;
    return li.baseTable[t] + ((e & 8388607) >> li.shiftTable[t]);
  }
  function Wr(s) {
    const e = s >> 10;
    return li.uint32View[0] = li.mantissaTable[li.offsetTable[e] + (s & 1023)] + li.exponentTable[e], li.floatView[0];
  }
  const Bv = {
    toHalfFloat: Kt,
    fromHalfFloat: Wr
  }, yt = new P(), na = new ee();
  class at {
    constructor(e, t, n = false) {
      if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = fo, this._updateRange = {
        offset: 0,
        count: -1
      }, this.updateRanges = [], this.gpuType = Tn, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    get updateRange() {
      return Im("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    addUpdateRange(e, t) {
      this.updateRanges.push({
        start: e,
        count: t
      });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(e) {
      return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
    }
    copyAt(e, t, n) {
      e *= this.itemSize, n *= t.itemSize;
      for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
      return this;
    }
    copyArray(e) {
      return this.array.set(e), this;
    }
    applyMatrix3(e) {
      if (this.itemSize === 2) for (let t = 0, n = this.count; t < n; t++) na.fromBufferAttribute(this, t), na.applyMatrix3(e), this.setXY(t, na.x, na.y);
      else if (this.itemSize === 3) for (let t = 0, n = this.count; t < n; t++) yt.fromBufferAttribute(this, t), yt.applyMatrix3(e), this.setXYZ(t, yt.x, yt.y, yt.z);
      return this;
    }
    applyMatrix4(e) {
      for (let t = 0, n = this.count; t < n; t++) yt.fromBufferAttribute(this, t), yt.applyMatrix4(e), this.setXYZ(t, yt.x, yt.y, yt.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, n = this.count; t < n; t++) yt.fromBufferAttribute(this, t), yt.applyNormalMatrix(e), this.setXYZ(t, yt.x, yt.y, yt.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, n = this.count; t < n; t++) yt.fromBufferAttribute(this, t), yt.transformDirection(e), this.setXYZ(t, yt.x, yt.y, yt.z);
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    getComponent(e, t) {
      let n = this.array[e * this.itemSize + t];
      return this.normalized && (n = $t(n, this.array)), n;
    }
    setComponent(e, t, n) {
      return this.normalized && (n = Be(n, this.array)), this.array[e * this.itemSize + t] = n, this;
    }
    getX(e) {
      let t = this.array[e * this.itemSize];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setX(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize] = t, this;
    }
    getY(e) {
      let t = this.array[e * this.itemSize + 1];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setY(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
    }
    getZ(e) {
      let t = this.array[e * this.itemSize + 2];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setZ(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
    }
    getW(e) {
      let t = this.array[e * this.itemSize + 3];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setW(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
    }
    setXY(e, t, n) {
      return e *= this.itemSize, this.normalized && (t = Be(t, this.array), n = Be(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
    }
    setXYZ(e, t, n, i) {
      return e *= this.itemSize, this.normalized && (t = Be(t, this.array), n = Be(n, this.array), i = Be(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
    }
    setXYZW(e, t, n, i, r) {
      return e *= this.itemSize, this.normalized && (t = Be(t, this.array), n = Be(n, this.array), i = Be(i, this.array), r = Be(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      return this.name !== "" && (e.name = this.name), this.usage !== fo && (e.usage = this.usage), e;
    }
  }
  class kv extends at {
    constructor(e, t, n) {
      super(new Int8Array(e), t, n);
    }
  }
  class Vv extends at {
    constructor(e, t, n) {
      super(new Uint8Array(e), t, n);
    }
  }
  class Hv extends at {
    constructor(e, t, n) {
      super(new Uint8ClampedArray(e), t, n);
    }
  }
  class Gv extends at {
    constructor(e, t, n) {
      super(new Int16Array(e), t, n);
    }
  }
  class du extends at {
    constructor(e, t, n) {
      super(new Uint16Array(e), t, n);
    }
  }
  class Wv extends at {
    constructor(e, t, n) {
      super(new Int32Array(e), t, n);
    }
  }
  class fu extends at {
    constructor(e, t, n) {
      super(new Uint32Array(e), t, n);
    }
  }
  class Xv extends at {
    constructor(e, t, n) {
      super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = true;
    }
    getX(e) {
      let t = Wr(this.array[e * this.itemSize]);
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setX(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize] = Kt(t), this;
    }
    getY(e) {
      let t = Wr(this.array[e * this.itemSize + 1]);
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setY(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize + 1] = Kt(t), this;
    }
    getZ(e) {
      let t = Wr(this.array[e * this.itemSize + 2]);
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setZ(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize + 2] = Kt(t), this;
    }
    getW(e) {
      let t = Wr(this.array[e * this.itemSize + 3]);
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setW(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.array[e * this.itemSize + 3] = Kt(t), this;
    }
    setXY(e, t, n) {
      return e *= this.itemSize, this.normalized && (t = Be(t, this.array), n = Be(n, this.array)), this.array[e + 0] = Kt(t), this.array[e + 1] = Kt(n), this;
    }
    setXYZ(e, t, n, i) {
      return e *= this.itemSize, this.normalized && (t = Be(t, this.array), n = Be(n, this.array), i = Be(i, this.array)), this.array[e + 0] = Kt(t), this.array[e + 1] = Kt(n), this.array[e + 2] = Kt(i), this;
    }
    setXYZW(e, t, n, i, r) {
      return e *= this.itemSize, this.normalized && (t = Be(t, this.array), n = Be(n, this.array), i = Be(i, this.array), r = Be(r, this.array)), this.array[e + 0] = Kt(t), this.array[e + 1] = Kt(n), this.array[e + 2] = Kt(i), this.array[e + 3] = Kt(r), this;
    }
  }
  class Ee extends at {
    constructor(e, t, n) {
      super(new Float32Array(e), t, n);
    }
  }
  let Yv = 0;
  const vn = new De(), gc = new Qe(), ks = new P(), an = new Bt(), Lr = new Bt(), Tt = new P();
  class We extends Mi {
    constructor() {
      super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
        value: Yv++
      }), this.uuid = fn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
        start: 0,
        count: 1 / 0
      }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e) {
      return Array.isArray(e) ? this.index = new (Rm(e) ? fu : du)(e, 1) : this.index = e, this;
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    setAttribute(e, t) {
      return this.attributes[e] = t, this;
    }
    deleteAttribute(e) {
      return delete this.attributes[e], this;
    }
    hasAttribute(e) {
      return this.attributes[e] !== void 0;
    }
    addGroup(e, t, n = 0) {
      this.groups.push({
        start: e,
        count: t,
        materialIndex: n
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e, t) {
      this.drawRange.start = e, this.drawRange.count = t;
    }
    applyMatrix4(e) {
      const t = this.attributes.position;
      t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
      const n = this.attributes.normal;
      if (n !== void 0) {
        const r = new Fe().getNormalMatrix(e);
        n.applyNormalMatrix(r), n.needsUpdate = true;
      }
      const i = this.attributes.tangent;
      return i !== void 0 && (i.transformDirection(e), i.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e) {
      return vn.makeRotationFromQuaternion(e), this.applyMatrix4(vn), this;
    }
    rotateX(e) {
      return vn.makeRotationX(e), this.applyMatrix4(vn), this;
    }
    rotateY(e) {
      return vn.makeRotationY(e), this.applyMatrix4(vn), this;
    }
    rotateZ(e) {
      return vn.makeRotationZ(e), this.applyMatrix4(vn), this;
    }
    translate(e, t, n) {
      return vn.makeTranslation(e, t, n), this.applyMatrix4(vn), this;
    }
    scale(e, t, n) {
      return vn.makeScale(e, t, n), this.applyMatrix4(vn), this;
    }
    lookAt(e) {
      return gc.lookAt(e), gc.updateMatrix(), this.applyMatrix4(gc.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(ks).negate(), this.translate(ks.x, ks.y, ks.z), this;
    }
    setFromPoints(e) {
      const t = [];
      for (let n = 0, i = e.length; n < i; n++) {
        const r = e[n];
        t.push(r.x, r.y, r.z || 0);
      }
      return this.setAttribute("position", new Ee(t, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Bt());
      const e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new P(-1 / 0, -1 / 0, -1 / 0), new P(1 / 0, 1 / 0, 1 / 0));
        return;
      }
      if (e !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(e), t) for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          an.setFromBufferAttribute(r), this.morphTargetsRelative ? (Tt.addVectors(this.boundingBox.min, an.min), this.boundingBox.expandByPoint(Tt), Tt.addVectors(this.boundingBox.max, an.max), this.boundingBox.expandByPoint(Tt)) : (this.boundingBox.expandByPoint(an.min), this.boundingBox.expandByPoint(an.max));
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new kt());
      const e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new P(), 1 / 0);
        return;
      }
      if (e) {
        const n = this.boundingSphere.center;
        if (an.setFromBufferAttribute(e), t) for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r];
          Lr.setFromBufferAttribute(a), this.morphTargetsRelative ? (Tt.addVectors(an.min, Lr.min), an.expandByPoint(Tt), Tt.addVectors(an.max, Lr.max), an.expandByPoint(Tt)) : (an.expandByPoint(Lr.min), an.expandByPoint(Lr.max));
        }
        an.getCenter(n);
        let i = 0;
        for (let r = 0, o = e.count; r < o; r++) Tt.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Tt));
        if (t) for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r], l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++) Tt.fromBufferAttribute(a, c), l && (ks.fromBufferAttribute(e, c), Tt.add(ks)), i = Math.max(i, n.distanceToSquared(Tt));
        }
        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const e = this.index, t = this.attributes;
      if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const n = t.position, i = t.normal, r = t.uv;
      this.hasAttribute("tangent") === false && this.setAttribute("tangent", new at(new Float32Array(4 * n.count), 4));
      const o = this.getAttribute("tangent"), a = [], l = [];
      for (let A = 0; A < n.count; A++) a[A] = new P(), l[A] = new P();
      const c = new P(), u = new P(), d = new P(), h = new ee(), f = new ee(), m = new ee(), v = new P(), g = new P();
      function p(A, M, y) {
        c.fromBufferAttribute(n, A), u.fromBufferAttribute(n, M), d.fromBufferAttribute(n, y), h.fromBufferAttribute(r, A), f.fromBufferAttribute(r, M), m.fromBufferAttribute(r, y), u.sub(c), d.sub(c), f.sub(h), m.sub(h);
        const C = 1 / (f.x * m.y - m.x * f.y);
        isFinite(C) && (v.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(C), g.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(C), a[A].add(v), a[M].add(v), a[y].add(v), l[A].add(g), l[M].add(g), l[y].add(g));
      }
      let _ = this.groups;
      _.length === 0 && (_ = [
        {
          start: 0,
          count: e.count
        }
      ]);
      for (let A = 0, M = _.length; A < M; ++A) {
        const y = _[A], C = y.start, N = y.count;
        for (let I = C, D = C + N; I < D; I += 3) p(e.getX(I + 0), e.getX(I + 1), e.getX(I + 2));
      }
      const x = new P(), b = new P(), E = new P(), S = new P();
      function w(A) {
        E.fromBufferAttribute(i, A), S.copy(E);
        const M = a[A];
        x.copy(M), x.sub(E.multiplyScalar(E.dot(M))).normalize(), b.crossVectors(S, M);
        const C = b.dot(l[A]) < 0 ? -1 : 1;
        o.setXYZW(A, x.x, x.y, x.z, C);
      }
      for (let A = 0, M = _.length; A < M; ++A) {
        const y = _[A], C = y.start, N = y.count;
        for (let I = C, D = C + N; I < D; I += 3) w(e.getX(I + 0)), w(e.getX(I + 1)), w(e.getX(I + 2));
      }
    }
    computeVertexNormals() {
      const e = this.index, t = this.getAttribute("position");
      if (t !== void 0) {
        let n = this.getAttribute("normal");
        if (n === void 0) n = new at(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
        else for (let h = 0, f = n.count; h < f; h++) n.setXYZ(h, 0, 0, 0);
        const i = new P(), r = new P(), o = new P(), a = new P(), l = new P(), c = new P(), u = new P(), d = new P();
        if (e) for (let h = 0, f = e.count; h < f; h += 3) {
          const m = e.getX(h + 0), v = e.getX(h + 1), g = e.getX(h + 2);
          i.fromBufferAttribute(t, m), r.fromBufferAttribute(t, v), o.fromBufferAttribute(t, g), u.subVectors(o, r), d.subVectors(i, r), u.cross(d), a.fromBufferAttribute(n, m), l.fromBufferAttribute(n, v), c.fromBufferAttribute(n, g), a.add(u), l.add(u), c.add(u), n.setXYZ(m, a.x, a.y, a.z), n.setXYZ(v, l.x, l.y, l.z), n.setXYZ(g, c.x, c.y, c.z);
        }
        else for (let h = 0, f = t.count; h < f; h += 3) i.fromBufferAttribute(t, h + 0), r.fromBufferAttribute(t, h + 1), o.fromBufferAttribute(t, h + 2), u.subVectors(o, r), d.subVectors(i, r), u.cross(d), n.setXYZ(h + 0, u.x, u.y, u.z), n.setXYZ(h + 1, u.x, u.y, u.z), n.setXYZ(h + 2, u.x, u.y, u.z);
        this.normalizeNormals(), n.needsUpdate = true;
      }
    }
    normalizeNormals() {
      const e = this.attributes.normal;
      for (let t = 0, n = e.count; t < n; t++) Tt.fromBufferAttribute(e, t), Tt.normalize(), e.setXYZ(t, Tt.x, Tt.y, Tt.z);
    }
    toNonIndexed() {
      function e(a, l) {
        const c = a.array, u = a.itemSize, d = a.normalized, h = new c.constructor(l.length * u);
        let f = 0, m = 0;
        for (let v = 0, g = l.length; v < g; v++) {
          a.isInterleavedBufferAttribute ? f = l[v] * a.data.stride + a.offset : f = l[v] * u;
          for (let p = 0; p < u; p++) h[m++] = c[f++];
        }
        return new at(h, u, d);
      }
      if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const t = new We(), n = this.index.array, i = this.attributes;
      for (const a in i) {
        const l = i[a], c = e(l, n);
        t.setAttribute(a, c);
      }
      const r = this.morphAttributes;
      for (const a in r) {
        const l = [], c = r[a];
        for (let u = 0, d = c.length; u < d; u++) {
          const h = c[u], f = e(h, n);
          l.push(f);
        }
        t.morphAttributes[a] = l;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      const o = this.groups;
      for (let a = 0, l = o.length; a < l; a++) {
        const c = o[a];
        t.addGroup(c.start, c.count, c.materialIndex);
      }
      return t;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
        const l = this.parameters;
        for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
        return e;
      }
      e.data = {
        attributes: {}
      };
      const t = this.index;
      t !== null && (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array)
      });
      const n = this.attributes;
      for (const l in n) {
        const c = n[l];
        e.data.attributes[l] = c.toJSON(e.data);
      }
      const i = {};
      let r = false;
      for (const l in this.morphAttributes) {
        const c = this.morphAttributes[l], u = [];
        for (let d = 0, h = c.length; d < h; d++) {
          const f = c[d];
          u.push(f.toJSON(e.data));
        }
        u.length > 0 && (i[l] = u, r = true);
      }
      r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
      const o = this.groups;
      o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
      const a = this.boundingSphere;
      return a !== null && (e.data.boundingSphere = {
        center: a.center.toArray(),
        radius: a.radius
      }), e;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const t = {};
      this.name = e.name;
      const n = e.index;
      n !== null && this.setIndex(n.clone(t));
      const i = e.attributes;
      for (const c in i) {
        const u = i[c];
        this.setAttribute(c, u.clone(t));
      }
      const r = e.morphAttributes;
      for (const c in r) {
        const u = [], d = r[c];
        for (let h = 0, f = d.length; h < f; h++) u.push(d[h].clone(t));
        this.morphAttributes[c] = u;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      const o = e.groups;
      for (let c = 0, u = o.length; c < u; c++) {
        const d = o[c];
        this.addGroup(d.start, d.count, d.materialIndex);
      }
      const a = e.boundingBox;
      a !== null && (this.boundingBox = a.clone());
      const l = e.boundingSphere;
      return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  const vd = new De(), Qi = new yr(), ia = new kt(), xd = new P(), Vs = new P(), Hs = new P(), Gs = new P(), vc = new P(), sa = new P(), ra = new ee(), oa = new ee(), aa = new ee(), _d = new P(), yd = new P(), Md = new P(), la = new P(), ca = new P();
  class ht extends Qe {
    constructor(e = new We(), t = new Xi()) {
      super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    }
    getVertexPosition(e, t) {
      const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, o = n.morphTargetsRelative;
      t.fromBufferAttribute(i, e);
      const a = this.morphTargetInfluences;
      if (r && a) {
        sa.set(0, 0, 0);
        for (let l = 0, c = r.length; l < c; l++) {
          const u = a[l], d = r[l];
          u !== 0 && (vc.fromBufferAttribute(d, e), o ? sa.addScaledVector(vc, u) : sa.addScaledVector(vc.sub(t), u));
        }
        t.add(sa);
      }
      return t;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.material, r = this.matrixWorld;
      i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), ia.copy(n.boundingSphere), ia.applyMatrix4(r), Qi.copy(e.ray).recast(e.near), !(ia.containsPoint(Qi.origin) === false && (Qi.intersectSphere(ia, xd) === null || Qi.origin.distanceToSquared(xd) > (e.far - e.near) ** 2)) && (vd.copy(r).invert(), Qi.copy(e.ray).applyMatrix4(vd), !(n.boundingBox !== null && Qi.intersectsBox(n.boundingBox) === false) && this._computeIntersections(e, t, Qi)));
    }
    _computeIntersections(e, t, n) {
      let i;
      const r = this.geometry, o = this.material, a = r.index, l = r.attributes.position, c = r.attributes.uv, u = r.attributes.uv1, d = r.attributes.normal, h = r.groups, f = r.drawRange;
      if (a !== null) if (Array.isArray(o)) for (let m = 0, v = h.length; m < v; m++) {
        const g = h[m], p = o[g.materialIndex], _ = Math.max(g.start, f.start), x = Math.min(a.count, Math.min(g.start + g.count, f.start + f.count));
        for (let b = _, E = x; b < E; b += 3) {
          const S = a.getX(b), w = a.getX(b + 1), A = a.getX(b + 2);
          i = ha(this, p, e, n, c, u, d, S, w, A), i && (i.faceIndex = Math.floor(b / 3), i.face.materialIndex = g.materialIndex, t.push(i));
        }
      }
      else {
        const m = Math.max(0, f.start), v = Math.min(a.count, f.start + f.count);
        for (let g = m, p = v; g < p; g += 3) {
          const _ = a.getX(g), x = a.getX(g + 1), b = a.getX(g + 2);
          i = ha(this, o, e, n, c, u, d, _, x, b), i && (i.faceIndex = Math.floor(g / 3), t.push(i));
        }
      }
      else if (l !== void 0) if (Array.isArray(o)) for (let m = 0, v = h.length; m < v; m++) {
        const g = h[m], p = o[g.materialIndex], _ = Math.max(g.start, f.start), x = Math.min(l.count, Math.min(g.start + g.count, f.start + f.count));
        for (let b = _, E = x; b < E; b += 3) {
          const S = b, w = b + 1, A = b + 2;
          i = ha(this, p, e, n, c, u, d, S, w, A), i && (i.faceIndex = Math.floor(b / 3), i.face.materialIndex = g.materialIndex, t.push(i));
        }
      }
      else {
        const m = Math.max(0, f.start), v = Math.min(l.count, f.start + f.count);
        for (let g = m, p = v; g < p; g += 3) {
          const _ = g, x = g + 1, b = g + 2;
          i = ha(this, o, e, n, c, u, d, _, x, b), i && (i.faceIndex = Math.floor(g / 3), t.push(i));
        }
      }
    }
  }
  function qv(s, e, t, n, i, r, o, a) {
    let l;
    if (e.side === Zt ? l = n.intersectTriangle(o, r, i, true, a) : l = n.intersectTriangle(i, r, o, e.side === mi, a), l === null) return null;
    ca.copy(a), ca.applyMatrix4(s.matrixWorld);
    const c = t.ray.origin.distanceTo(ca);
    return c < t.near || c > t.far ? null : {
      distance: c,
      point: ca.clone(),
      object: s
    };
  }
  function ha(s, e, t, n, i, r, o, a, l, c) {
    s.getVertexPosition(a, Vs), s.getVertexPosition(l, Hs), s.getVertexPosition(c, Gs);
    const u = qv(s, e, t, n, Vs, Hs, Gs, la);
    if (u) {
      i && (ra.fromBufferAttribute(i, a), oa.fromBufferAttribute(i, l), aa.fromBufferAttribute(i, c), u.uv = un.getInterpolation(la, Vs, Hs, Gs, ra, oa, aa, new ee())), r && (ra.fromBufferAttribute(r, a), oa.fromBufferAttribute(r, l), aa.fromBufferAttribute(r, c), u.uv1 = un.getInterpolation(la, Vs, Hs, Gs, ra, oa, aa, new ee())), o && (_d.fromBufferAttribute(o, a), yd.fromBufferAttribute(o, l), Md.fromBufferAttribute(o, c), u.normal = un.getInterpolation(la, Vs, Hs, Gs, _d, yd, Md, new P()), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
      const d = {
        a,
        b: l,
        c,
        normal: new P(),
        materialIndex: 0
      };
      un.getNormal(Vs, Hs, Gs, d.normal), u.face = d;
    }
    return u;
  }
  class bi extends We {
    constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
      super(), this.type = "BoxGeometry", this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o
      };
      const a = this;
      i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
      const l = [], c = [], u = [], d = [];
      let h = 0, f = 0;
      m("z", "y", "x", -1, -1, n, t, e, o, r, 0), m("z", "y", "x", 1, -1, n, t, -e, o, r, 1), m("x", "z", "y", 1, 1, e, n, t, i, o, 2), m("x", "z", "y", 1, -1, e, n, -t, i, o, 3), m("x", "y", "z", 1, -1, e, t, n, i, r, 4), m("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.setAttribute("position", new Ee(c, 3)), this.setAttribute("normal", new Ee(u, 3)), this.setAttribute("uv", new Ee(d, 2));
      function m(v, g, p, _, x, b, E, S, w, A, M) {
        const y = b / w, C = E / A, N = b / 2, I = E / 2, D = S / 2, O = w + 1, z = A + 1;
        let B = 0, U = 0;
        const G = new P();
        for (let V = 0; V < z; V++) {
          const K = V * C - I;
          for (let ce = 0; ce < O; ce++) {
            const Te = ce * y - N;
            G[v] = Te * _, G[g] = K * x, G[p] = D, c.push(G.x, G.y, G.z), G[v] = 0, G[g] = 0, G[p] = S > 0 ? 1 : -1, u.push(G.x, G.y, G.z), d.push(ce / w), d.push(1 - V / A), B += 1;
          }
        }
        for (let V = 0; V < A; V++) for (let K = 0; K < w; K++) {
          const ce = h + K + O * V, Te = h + K + O * (V + 1), q = h + (K + 1) + O * (V + 1), te = h + (K + 1) + O * V;
          l.push(ce, Te, te), l.push(Te, q, te), U += 6;
        }
        a.addGroup(f, U, M), f += U, h += B;
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new bi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
    }
  }
  function dr(s) {
    const e = {};
    for (const t in s) {
      e[t] = {};
      for (const n in s[t]) {
        const i = s[t][n];
        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
      }
    }
    return e;
  }
  function Xt(s) {
    const e = {};
    for (let t = 0; t < s.length; t++) {
      const n = dr(s[t]);
      for (const i in n) e[i] = n[i];
    }
    return e;
  }
  function $v(s) {
    const e = [];
    for (let t = 0; t < s.length; t++) e.push(s[t].clone());
    return e;
  }
  function Um(s) {
    const e = s.getRenderTarget();
    return e === null ? s.outputColorSpace : e.isXRRenderTarget === true ? e.texture.colorSpace : st.workingColorSpace;
  }
  const Om = {
    clone: dr,
    merge: Xt
  };
  var Zv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Jv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
  class Fn extends Ht {
    constructor(e) {
      super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Zv, this.fragmentShader = Jv, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
        clipCullDistance: false,
        multiDraw: false
      }, this.defaultAttributeValues = {
        color: [
          1,
          1,
          1
        ],
        uv: [
          0,
          0
        ],
        uv1: [
          0,
          0
        ]
      }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = dr(e.uniforms), this.uniformsGroups = $v(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      t.glslVersion = this.glslVersion, t.uniforms = {};
      for (const i in this.uniforms) {
        const o = this.uniforms[i].value;
        o && o.isTexture ? t.uniforms[i] = {
          type: "t",
          value: o.toJSON(e).uuid
        } : o && o.isColor ? t.uniforms[i] = {
          type: "c",
          value: o.getHex()
        } : o && o.isVector2 ? t.uniforms[i] = {
          type: "v2",
          value: o.toArray()
        } : o && o.isVector3 ? t.uniforms[i] = {
          type: "v3",
          value: o.toArray()
        } : o && o.isVector4 ? t.uniforms[i] = {
          type: "v4",
          value: o.toArray()
        } : o && o.isMatrix3 ? t.uniforms[i] = {
          type: "m3",
          value: o.toArray()
        } : o && o.isMatrix4 ? t.uniforms[i] = {
          type: "m4",
          value: o.toArray()
        } : t.uniforms[i] = {
          value: o
        };
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
      const n = {};
      for (const i in this.extensions) this.extensions[i] === true && (n[i] = true);
      return Object.keys(n).length > 0 && (t.extensions = n), t;
    }
  }
  class wl extends Qe {
    constructor() {
      super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new De(), this.projectionMatrix = new De(), this.projectionMatrixInverse = new De(), this.coordinateSystem = Yn;
    }
    copy(e, t) {
      return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
    }
    getWorldDirection(e) {
      return super.getWorldDirection(e).negate();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Ri = new P(), bd = new ee(), Sd = new ee();
  class Et extends wl {
    constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
      super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
    }
    setFocalLength(e) {
      const t = 0.5 * this.getFilmHeight() / e;
      this.fov = ur * 2 * Math.atan(t), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const e = Math.tan(ws * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / e;
    }
    getEffectiveFOV() {
      return ur * 2 * Math.atan(Math.tan(ws * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    getViewBounds(e, t, n) {
      Ri.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Ri.x, Ri.y).multiplyScalar(-e / Ri.z), Ri.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Ri.x, Ri.y).multiplyScalar(-e / Ri.z);
    }
    getViewSize(e, t) {
      return this.getViewBounds(e, bd, Sd), t.subVectors(Sd, bd);
    }
    setViewOffset(e, t, n, i, r, o) {
      this.aspect = e / t, this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = this.near;
      let t = e * Math.tan(ws * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
      const o = this.view;
      if (this.view !== null && this.view.enabled) {
        const l = o.fullWidth, c = o.fullHeight;
        r += o.offsetX * i / l, t -= o.offsetY * n / c, i *= o.width / l, n *= o.height / c;
      }
      const a = this.filmOffset;
      a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }
  const Ws = -90, Xs = 1;
  class zm extends Qe {
    constructor(e, t, n) {
      super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
      const i = new Et(Ws, Xs, e, t);
      i.layers = this.layers, this.add(i);
      const r = new Et(Ws, Xs, e, t);
      r.layers = this.layers, this.add(r);
      const o = new Et(Ws, Xs, e, t);
      o.layers = this.layers, this.add(o);
      const a = new Et(Ws, Xs, e, t);
      a.layers = this.layers, this.add(a);
      const l = new Et(Ws, Xs, e, t);
      l.layers = this.layers, this.add(l);
      const c = new Et(Ws, Xs, e, t);
      c.layers = this.layers, this.add(c);
    }
    updateCoordinateSystem() {
      const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, o, a, l] = t;
      for (const c of t) this.remove(c);
      if (e === Yn) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
      else if (e === po) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
      else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
      for (const c of t) this.add(c), c.updateMatrixWorld();
    }
    update(e, t) {
      this.parent === null && this.updateMatrixWorld();
      const { renderTarget: n, activeMipmapLevel: i } = this;
      this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
      const [r, o, a, l, c, u] = this.children, d = e.getRenderTarget(), h = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
      e.xr.enabled = false;
      const v = n.texture.generateMipmaps;
      n.texture.generateMipmaps = false, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, c), n.texture.generateMipmaps = v, e.setRenderTarget(n, 5, i), e.render(t, u), e.setRenderTarget(d, h, f), e.xr.enabled = m, n.texture.needsPMREMUpdate = true;
    }
  }
  class Uo extends gt {
    constructor(e, t, n, i, r, o, a, l, c, u) {
      e = e !== void 0 ? e : [], t = t !== void 0 ? t : gi, super(e, t, n, i, r, o, a, l, c, u), this.isCubeTexture = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(e) {
      this.image = e;
    }
  }
  class Fm extends zn {
    constructor(e = 1, t = {}) {
      super(e, e, t), this.isWebGLCubeRenderTarget = true;
      const n = {
        width: e,
        height: e,
        depth: 1
      }, i = [
        n,
        n,
        n,
        n,
        n,
        n
      ];
      this.texture = new Uo(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Mt;
    }
    fromEquirectangularTexture(e, t) {
      this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
      const n = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      }, i = new bi(5, 5, 5), r = new Fn({
        name: "CubemapFromEquirect",
        uniforms: dr(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Zt,
        blending: di
      });
      r.uniforms.tEquirect.value = t;
      const o = new ht(i, r), a = t.minFilter;
      return t.minFilter === Xn && (t.minFilter = Mt), new zm(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
    }
    clear(e, t, n, i) {
      const r = e.getRenderTarget();
      for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
      e.setRenderTarget(r);
    }
  }
  const xc = new P(), Kv = new P(), jv = new Fe();
  class Li {
    constructor(e = new P(1, 0, 0), t = 0) {
      this.isPlane = true, this.normal = e, this.constant = t;
    }
    set(e, t) {
      return this.normal.copy(e), this.constant = t, this;
    }
    setComponents(e, t, n, i) {
      return this.normal.set(e, t, n), this.constant = i, this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
    }
    setFromCoplanarPoints(e, t, n) {
      const i = xc.subVectors(n, t).cross(Kv.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, e), this;
    }
    copy(e) {
      return this.normal.copy(e.normal), this.constant = e.constant, this;
    }
    normalize() {
      const e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), this.constant *= e, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
    }
    intersectLine(e, t) {
      const n = e.delta(xc), i = this.normal.dot(n);
      if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
      const r = -(e.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
    }
    intersectsLine(e) {
      const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
      return t < 0 && n > 0 || n < 0 && t > 0;
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
      const n = t || jv.getNormalMatrix(e), i = this.coplanarPoint(xc).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
      return this.constant = -i.dot(r), this;
    }
    translate(e) {
      return this.constant -= e.dot(this.normal), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const es = new kt(), ua = new P();
  class Oo {
    constructor(e = new Li(), t = new Li(), n = new Li(), i = new Li(), r = new Li(), o = new Li()) {
      this.planes = [
        e,
        t,
        n,
        i,
        r,
        o
      ];
    }
    set(e, t, n, i, r, o) {
      const a = this.planes;
      return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this;
    }
    copy(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
      return this;
    }
    setFromProjectionMatrix(e, t = Yn) {
      const n = this.planes, i = e.elements, r = i[0], o = i[1], a = i[2], l = i[3], c = i[4], u = i[5], d = i[6], h = i[7], f = i[8], m = i[9], v = i[10], g = i[11], p = i[12], _ = i[13], x = i[14], b = i[15];
      if (n[0].setComponents(l - r, h - c, g - f, b - p).normalize(), n[1].setComponents(l + r, h + c, g + f, b + p).normalize(), n[2].setComponents(l + o, h + u, g + m, b + _).normalize(), n[3].setComponents(l - o, h - u, g - m, b - _).normalize(), n[4].setComponents(l - a, h - d, g - v, b - x).normalize(), t === Yn) n[5].setComponents(l + a, h + d, g + v, b + x).normalize();
      else if (t === po) n[5].setComponents(a, d, v, x).normalize();
      else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
      return this;
    }
    intersectsObject(e) {
      if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), es.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
      else {
        const t = e.geometry;
        t.boundingSphere === null && t.computeBoundingSphere(), es.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
      }
      return this.intersectsSphere(es);
    }
    intersectsSprite(e) {
      return es.center.set(0, 0, 0), es.radius = 0.7071067811865476, es.applyMatrix4(e.matrixWorld), this.intersectsSphere(es);
    }
    intersectsSphere(e) {
      const t = this.planes, n = e.center, i = -e.radius;
      for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(n) < i) return false;
      return true;
    }
    intersectsBox(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = t[n];
        if (ua.x = i.normal.x > 0 ? e.max.x : e.min.x, ua.y = i.normal.y > 0 ? e.max.y : e.min.y, ua.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(ua) < 0) return false;
      }
      return true;
    }
    containsPoint(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Bm() {
    let s = null, e = false, t = null, n = null;
    function i(r, o) {
      t(r, o), n = s.requestAnimationFrame(i);
    }
    return {
      start: function() {
        e !== true && t !== null && (n = s.requestAnimationFrame(i), e = true);
      },
      stop: function() {
        s.cancelAnimationFrame(n), e = false;
      },
      setAnimationLoop: function(r) {
        t = r;
      },
      setContext: function(r) {
        s = r;
      }
    };
  }
  function Qv(s) {
    const e = /* @__PURE__ */ new WeakMap();
    function t(a, l) {
      const c = a.array, u = a.usage, d = c.byteLength, h = s.createBuffer();
      s.bindBuffer(l, h), s.bufferData(l, c, u), a.onUploadCallback();
      let f;
      if (c instanceof Float32Array) f = s.FLOAT;
      else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
      else if (c instanceof Int16Array) f = s.SHORT;
      else if (c instanceof Uint32Array) f = s.UNSIGNED_INT;
      else if (c instanceof Int32Array) f = s.INT;
      else if (c instanceof Int8Array) f = s.BYTE;
      else if (c instanceof Uint8Array) f = s.UNSIGNED_BYTE;
      else if (c instanceof Uint8ClampedArray) f = s.UNSIGNED_BYTE;
      else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
      return {
        buffer: h,
        type: f,
        bytesPerElement: c.BYTES_PER_ELEMENT,
        version: a.version,
        size: d
      };
    }
    function n(a, l, c) {
      const u = l.array, d = l._updateRange, h = l.updateRanges;
      if (s.bindBuffer(c, a), d.count === -1 && h.length === 0 && s.bufferSubData(c, 0, u), h.length !== 0) {
        for (let f = 0, m = h.length; f < m; f++) {
          const v = h[f];
          s.bufferSubData(c, v.start * u.BYTES_PER_ELEMENT, u, v.start, v.count);
        }
        l.clearUpdateRanges();
      }
      d.count !== -1 && (s.bufferSubData(c, d.offset * u.BYTES_PER_ELEMENT, u, d.offset, d.count), d.count = -1), l.onUploadCallback();
    }
    function i(a) {
      return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
    }
    function r(a) {
      a.isInterleavedBufferAttribute && (a = a.data);
      const l = e.get(a);
      l && (s.deleteBuffer(l.buffer), e.delete(a));
    }
    function o(a, l) {
      if (a.isGLBufferAttribute) {
        const u = e.get(a);
        (!u || u.version < a.version) && e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version
        });
        return;
      }
      a.isInterleavedBufferAttribute && (a = a.data);
      const c = e.get(a);
      if (c === void 0) e.set(a, t(a, l));
      else if (c.version < a.version) {
        if (c.size !== a.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
        n(c.buffer, a, l), c.version = a.version;
      }
    }
    return {
      get: i,
      remove: r,
      update: o
    };
  }
  class Mr extends We {
    constructor(e = 1, t = 1, n = 1, i = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i
      };
      const r = e / 2, o = t / 2, a = Math.floor(n), l = Math.floor(i), c = a + 1, u = l + 1, d = e / a, h = t / l, f = [], m = [], v = [], g = [];
      for (let p = 0; p < u; p++) {
        const _ = p * h - o;
        for (let x = 0; x < c; x++) {
          const b = x * d - r;
          m.push(b, -_, 0), v.push(0, 0, 1), g.push(x / a), g.push(1 - p / l);
        }
      }
      for (let p = 0; p < l; p++) for (let _ = 0; _ < a; _++) {
        const x = _ + c * p, b = _ + c * (p + 1), E = _ + 1 + c * (p + 1), S = _ + 1 + c * p;
        f.push(x, b, S), f.push(b, E, S);
      }
      this.setIndex(f), this.setAttribute("position", new Ee(m, 3)), this.setAttribute("normal", new Ee(v, 3)), this.setAttribute("uv", new Ee(g, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Mr(e.width, e.height, e.widthSegments, e.heightSegments);
    }
  }
  var ex = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, tx = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, nx = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, ix = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, sx = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, rx = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, ox = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, ax = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, lx = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, cx = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, hx = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, ux = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, dx = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, fx = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, px = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, mx = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, gx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, vx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, xx = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, _x = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, yx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Mx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, bx = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Sx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, wx = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Tx = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Ex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Ax = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Cx = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Rx = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Px = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Ix = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, Lx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Dx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Nx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Ux = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Ox = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, zx = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Fx = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Bx = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, kx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Vx = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Hx = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Gx = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Wx = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Xx = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Yx = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, qx = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, $x = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Zx = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Jx = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Kx = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, jx = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Qx = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, e_ = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, t_ = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, n_ = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, i_ = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, s_ = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, r_ = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, o_ = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, a_ = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, l_ = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, c_ = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, h_ = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, u_ = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, d_ = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, f_ = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, p_ = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, m_ = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, g_ = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, v_ = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, x_ = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, __ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, y_ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, M_ = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, b_ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, S_ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, w_ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, T_ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, E_ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, A_ = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, C_ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, R_ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, P_ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, I_ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, L_ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, D_ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, N_ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, U_ = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, O_ = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, z_ = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, F_ = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, B_ = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, k_ = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, V_ = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, H_ = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, G_ = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, W_ = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, X_ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Y_ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, q_ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, $_ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Z_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, J_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, K_ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, j_ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
  const Q_ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, ey = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ty = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ny = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, iy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, sy = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ry = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, oy = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, ay = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, ly = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, cy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, hy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, uy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, dy = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, fy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, py = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, my = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, gy = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vy = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, xy = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, _y = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, yy = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, My = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, by = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Sy = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, wy = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ty = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ey = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ay = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Cy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Ry = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Py = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Iy = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Ly = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ve = {
    alphahash_fragment: ex,
    alphahash_pars_fragment: tx,
    alphamap_fragment: nx,
    alphamap_pars_fragment: ix,
    alphatest_fragment: sx,
    alphatest_pars_fragment: rx,
    aomap_fragment: ox,
    aomap_pars_fragment: ax,
    batching_pars_vertex: lx,
    batching_vertex: cx,
    begin_vertex: hx,
    beginnormal_vertex: ux,
    bsdfs: dx,
    iridescence_fragment: fx,
    bumpmap_pars_fragment: px,
    clipping_planes_fragment: mx,
    clipping_planes_pars_fragment: gx,
    clipping_planes_pars_vertex: vx,
    clipping_planes_vertex: xx,
    color_fragment: _x,
    color_pars_fragment: yx,
    color_pars_vertex: Mx,
    color_vertex: bx,
    common: Sx,
    cube_uv_reflection_fragment: wx,
    defaultnormal_vertex: Tx,
    displacementmap_pars_vertex: Ex,
    displacementmap_vertex: Ax,
    emissivemap_fragment: Cx,
    emissivemap_pars_fragment: Rx,
    colorspace_fragment: Px,
    colorspace_pars_fragment: Ix,
    envmap_fragment: Lx,
    envmap_common_pars_fragment: Dx,
    envmap_pars_fragment: Nx,
    envmap_pars_vertex: Ux,
    envmap_physical_pars_fragment: Yx,
    envmap_vertex: Ox,
    fog_vertex: zx,
    fog_pars_vertex: Fx,
    fog_fragment: Bx,
    fog_pars_fragment: kx,
    gradientmap_pars_fragment: Vx,
    lightmap_pars_fragment: Hx,
    lights_lambert_fragment: Gx,
    lights_lambert_pars_fragment: Wx,
    lights_pars_begin: Xx,
    lights_toon_fragment: qx,
    lights_toon_pars_fragment: $x,
    lights_phong_fragment: Zx,
    lights_phong_pars_fragment: Jx,
    lights_physical_fragment: Kx,
    lights_physical_pars_fragment: jx,
    lights_fragment_begin: Qx,
    lights_fragment_maps: e_,
    lights_fragment_end: t_,
    logdepthbuf_fragment: n_,
    logdepthbuf_pars_fragment: i_,
    logdepthbuf_pars_vertex: s_,
    logdepthbuf_vertex: r_,
    map_fragment: o_,
    map_pars_fragment: a_,
    map_particle_fragment: l_,
    map_particle_pars_fragment: c_,
    metalnessmap_fragment: h_,
    metalnessmap_pars_fragment: u_,
    morphinstance_vertex: d_,
    morphcolor_vertex: f_,
    morphnormal_vertex: p_,
    morphtarget_pars_vertex: m_,
    morphtarget_vertex: g_,
    normal_fragment_begin: v_,
    normal_fragment_maps: x_,
    normal_pars_fragment: __,
    normal_pars_vertex: y_,
    normal_vertex: M_,
    normalmap_pars_fragment: b_,
    clearcoat_normal_fragment_begin: S_,
    clearcoat_normal_fragment_maps: w_,
    clearcoat_pars_fragment: T_,
    iridescence_pars_fragment: E_,
    opaque_fragment: A_,
    packing: C_,
    premultiplied_alpha_fragment: R_,
    project_vertex: P_,
    dithering_fragment: I_,
    dithering_pars_fragment: L_,
    roughnessmap_fragment: D_,
    roughnessmap_pars_fragment: N_,
    shadowmap_pars_fragment: U_,
    shadowmap_pars_vertex: O_,
    shadowmap_vertex: z_,
    shadowmask_pars_fragment: F_,
    skinbase_vertex: B_,
    skinning_pars_vertex: k_,
    skinning_vertex: V_,
    skinnormal_vertex: H_,
    specularmap_fragment: G_,
    specularmap_pars_fragment: W_,
    tonemapping_fragment: X_,
    tonemapping_pars_fragment: Y_,
    transmission_fragment: q_,
    transmission_pars_fragment: $_,
    uv_pars_fragment: Z_,
    uv_pars_vertex: J_,
    uv_vertex: K_,
    worldpos_vertex: j_,
    background_vert: Q_,
    background_frag: ey,
    backgroundCube_vert: ty,
    backgroundCube_frag: ny,
    cube_vert: iy,
    cube_frag: sy,
    depth_vert: ry,
    depth_frag: oy,
    distanceRGBA_vert: ay,
    distanceRGBA_frag: ly,
    equirect_vert: cy,
    equirect_frag: hy,
    linedashed_vert: uy,
    linedashed_frag: dy,
    meshbasic_vert: fy,
    meshbasic_frag: py,
    meshlambert_vert: my,
    meshlambert_frag: gy,
    meshmatcap_vert: vy,
    meshmatcap_frag: xy,
    meshnormal_vert: _y,
    meshnormal_frag: yy,
    meshphong_vert: My,
    meshphong_frag: by,
    meshphysical_vert: Sy,
    meshphysical_frag: wy,
    meshtoon_vert: Ty,
    meshtoon_frag: Ey,
    points_vert: Ay,
    points_frag: Cy,
    shadow_vert: Ry,
    shadow_frag: Py,
    sprite_vert: Iy,
    sprite_frag: Ly
  }, pe = {
    common: {
      diffuse: {
        value: new ye(16777215)
      },
      opacity: {
        value: 1
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new Fe()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new Fe()
      },
      alphaTest: {
        value: 0
      }
    },
    specularmap: {
      specularMap: {
        value: null
      },
      specularMapTransform: {
        value: new Fe()
      }
    },
    envmap: {
      envMap: {
        value: null
      },
      envMapRotation: {
        value: new Fe()
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1
      },
      ior: {
        value: 1.5
      },
      refractionRatio: {
        value: 0.98
      }
    },
    aomap: {
      aoMap: {
        value: null
      },
      aoMapIntensity: {
        value: 1
      },
      aoMapTransform: {
        value: new Fe()
      }
    },
    lightmap: {
      lightMap: {
        value: null
      },
      lightMapIntensity: {
        value: 1
      },
      lightMapTransform: {
        value: new Fe()
      }
    },
    bumpmap: {
      bumpMap: {
        value: null
      },
      bumpMapTransform: {
        value: new Fe()
      },
      bumpScale: {
        value: 1
      }
    },
    normalmap: {
      normalMap: {
        value: null
      },
      normalMapTransform: {
        value: new Fe()
      },
      normalScale: {
        value: new ee(1, 1)
      }
    },
    displacementmap: {
      displacementMap: {
        value: null
      },
      displacementMapTransform: {
        value: new Fe()
      },
      displacementScale: {
        value: 1
      },
      displacementBias: {
        value: 0
      }
    },
    emissivemap: {
      emissiveMap: {
        value: null
      },
      emissiveMapTransform: {
        value: new Fe()
      }
    },
    metalnessmap: {
      metalnessMap: {
        value: null
      },
      metalnessMapTransform: {
        value: new Fe()
      }
    },
    roughnessmap: {
      roughnessMap: {
        value: null
      },
      roughnessMapTransform: {
        value: new Fe()
      }
    },
    gradientmap: {
      gradientMap: {
        value: null
      }
    },
    fog: {
      fogDensity: {
        value: 25e-5
      },
      fogNear: {
        value: 1
      },
      fogFar: {
        value: 2e3
      },
      fogColor: {
        value: new ye(16777215)
      }
    },
    lights: {
      ambientLightColor: {
        value: []
      },
      lightProbe: {
        value: []
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {}
        }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: {
        value: []
      },
      directionalShadowMatrix: {
        value: []
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: {
        value: []
      },
      spotShadowMap: {
        value: []
      },
      spotLightMatrix: {
        value: []
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {
        value: []
      },
      pointShadowMatrix: {
        value: []
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        }
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        }
      },
      ltc_1: {
        value: null
      },
      ltc_2: {
        value: null
      }
    },
    points: {
      diffuse: {
        value: new ye(16777215)
      },
      opacity: {
        value: 1
      },
      size: {
        value: 1
      },
      scale: {
        value: 1
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new Fe()
      },
      alphaTest: {
        value: 0
      },
      uvTransform: {
        value: new Fe()
      }
    },
    sprite: {
      diffuse: {
        value: new ye(16777215)
      },
      opacity: {
        value: 1
      },
      center: {
        value: new ee(0.5, 0.5)
      },
      rotation: {
        value: 0
      },
      map: {
        value: null
      },
      mapTransform: {
        value: new Fe()
      },
      alphaMap: {
        value: null
      },
      alphaMapTransform: {
        value: new Fe()
      },
      alphaTest: {
        value: 0
      }
    }
  }, In = {
    basic: {
      uniforms: Xt([
        pe.common,
        pe.specularmap,
        pe.envmap,
        pe.aomap,
        pe.lightmap,
        pe.fog
      ]),
      vertexShader: Ve.meshbasic_vert,
      fragmentShader: Ve.meshbasic_frag
    },
    lambert: {
      uniforms: Xt([
        pe.common,
        pe.specularmap,
        pe.envmap,
        pe.aomap,
        pe.lightmap,
        pe.emissivemap,
        pe.bumpmap,
        pe.normalmap,
        pe.displacementmap,
        pe.fog,
        pe.lights,
        {
          emissive: {
            value: new ye(0)
          }
        }
      ]),
      vertexShader: Ve.meshlambert_vert,
      fragmentShader: Ve.meshlambert_frag
    },
    phong: {
      uniforms: Xt([
        pe.common,
        pe.specularmap,
        pe.envmap,
        pe.aomap,
        pe.lightmap,
        pe.emissivemap,
        pe.bumpmap,
        pe.normalmap,
        pe.displacementmap,
        pe.fog,
        pe.lights,
        {
          emissive: {
            value: new ye(0)
          },
          specular: {
            value: new ye(1118481)
          },
          shininess: {
            value: 30
          }
        }
      ]),
      vertexShader: Ve.meshphong_vert,
      fragmentShader: Ve.meshphong_frag
    },
    standard: {
      uniforms: Xt([
        pe.common,
        pe.envmap,
        pe.aomap,
        pe.lightmap,
        pe.emissivemap,
        pe.bumpmap,
        pe.normalmap,
        pe.displacementmap,
        pe.roughnessmap,
        pe.metalnessmap,
        pe.fog,
        pe.lights,
        {
          emissive: {
            value: new ye(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }
      ]),
      vertexShader: Ve.meshphysical_vert,
      fragmentShader: Ve.meshphysical_frag
    },
    toon: {
      uniforms: Xt([
        pe.common,
        pe.aomap,
        pe.lightmap,
        pe.emissivemap,
        pe.bumpmap,
        pe.normalmap,
        pe.displacementmap,
        pe.gradientmap,
        pe.fog,
        pe.lights,
        {
          emissive: {
            value: new ye(0)
          }
        }
      ]),
      vertexShader: Ve.meshtoon_vert,
      fragmentShader: Ve.meshtoon_frag
    },
    matcap: {
      uniforms: Xt([
        pe.common,
        pe.bumpmap,
        pe.normalmap,
        pe.displacementmap,
        pe.fog,
        {
          matcap: {
            value: null
          }
        }
      ]),
      vertexShader: Ve.meshmatcap_vert,
      fragmentShader: Ve.meshmatcap_frag
    },
    points: {
      uniforms: Xt([
        pe.points,
        pe.fog
      ]),
      vertexShader: Ve.points_vert,
      fragmentShader: Ve.points_frag
    },
    dashed: {
      uniforms: Xt([
        pe.common,
        pe.fog,
        {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }
      ]),
      vertexShader: Ve.linedashed_vert,
      fragmentShader: Ve.linedashed_frag
    },
    depth: {
      uniforms: Xt([
        pe.common,
        pe.displacementmap
      ]),
      vertexShader: Ve.depth_vert,
      fragmentShader: Ve.depth_frag
    },
    normal: {
      uniforms: Xt([
        pe.common,
        pe.bumpmap,
        pe.normalmap,
        pe.displacementmap,
        {
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: Ve.meshnormal_vert,
      fragmentShader: Ve.meshnormal_frag
    },
    sprite: {
      uniforms: Xt([
        pe.sprite,
        pe.fog
      ]),
      vertexShader: Ve.sprite_vert,
      fragmentShader: Ve.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new Fe()
        },
        t2D: {
          value: null
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: Ve.background_vert,
      fragmentShader: Ve.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        backgroundBlurriness: {
          value: 0
        },
        backgroundIntensity: {
          value: 1
        },
        backgroundRotation: {
          value: new Fe()
        }
      },
      vertexShader: Ve.backgroundCube_vert,
      fragmentShader: Ve.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: {
          value: null
        },
        tFlip: {
          value: -1
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: Ve.cube_vert,
      fragmentShader: Ve.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: Ve.equirect_vert,
      fragmentShader: Ve.equirect_frag
    },
    distanceRGBA: {
      uniforms: Xt([
        pe.common,
        pe.displacementmap,
        {
          referencePosition: {
            value: new P()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }
      ]),
      vertexShader: Ve.distanceRGBA_vert,
      fragmentShader: Ve.distanceRGBA_frag
    },
    shadow: {
      uniforms: Xt([
        pe.lights,
        pe.fog,
        {
          color: {
            value: new ye(0)
          },
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: Ve.shadow_vert,
      fragmentShader: Ve.shadow_frag
    }
  };
  In.physical = {
    uniforms: Xt([
      In.standard.uniforms,
      {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatMapTransform: {
          value: new Fe()
        },
        clearcoatNormalMap: {
          value: null
        },
        clearcoatNormalMapTransform: {
          value: new Fe()
        },
        clearcoatNormalScale: {
          value: new ee(1, 1)
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatRoughnessMapTransform: {
          value: new Fe()
        },
        dispersion: {
          value: 0
        },
        iridescence: {
          value: 0
        },
        iridescenceMap: {
          value: null
        },
        iridescenceMapTransform: {
          value: new Fe()
        },
        iridescenceIOR: {
          value: 1.3
        },
        iridescenceThicknessMinimum: {
          value: 100
        },
        iridescenceThicknessMaximum: {
          value: 400
        },
        iridescenceThicknessMap: {
          value: null
        },
        iridescenceThicknessMapTransform: {
          value: new Fe()
        },
        sheen: {
          value: 0
        },
        sheenColor: {
          value: new ye(0)
        },
        sheenColorMap: {
          value: null
        },
        sheenColorMapTransform: {
          value: new Fe()
        },
        sheenRoughness: {
          value: 1
        },
        sheenRoughnessMap: {
          value: null
        },
        sheenRoughnessMapTransform: {
          value: new Fe()
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        },
        transmissionMapTransform: {
          value: new Fe()
        },
        transmissionSamplerSize: {
          value: new ee()
        },
        transmissionSamplerMap: {
          value: null
        },
        thickness: {
          value: 0
        },
        thicknessMap: {
          value: null
        },
        thicknessMapTransform: {
          value: new Fe()
        },
        attenuationDistance: {
          value: 0
        },
        attenuationColor: {
          value: new ye(0)
        },
        specularColor: {
          value: new ye(1, 1, 1)
        },
        specularColorMap: {
          value: null
        },
        specularColorMapTransform: {
          value: new Fe()
        },
        specularIntensity: {
          value: 1
        },
        specularIntensityMap: {
          value: null
        },
        specularIntensityMapTransform: {
          value: new Fe()
        },
        anisotropyVector: {
          value: new ee()
        },
        anisotropyMap: {
          value: null
        },
        anisotropyMapTransform: {
          value: new Fe()
        }
      }
    ]),
    vertexShader: Ve.meshphysical_vert,
    fragmentShader: Ve.meshphysical_frag
  };
  const da = {
    r: 0,
    b: 0,
    g: 0
  }, ts = new mn(), Dy = new De();
  function Ny(s, e, t, n, i, r, o) {
    const a = new ye(0);
    let l = r === true ? 0 : 1, c, u, d = null, h = 0, f = null;
    function m(_) {
      let x = _.isScene === true ? _.background : null;
      return x && x.isTexture && (x = (_.backgroundBlurriness > 0 ? t : e).get(x)), x;
    }
    function v(_) {
      let x = false;
      const b = m(_);
      b === null ? p(a, l) : b && b.isColor && (p(b, 1), x = true);
      const E = s.xr.getEnvironmentBlendMode();
      E === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : E === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || x) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil);
    }
    function g(_, x) {
      const b = m(x);
      b && (b.isCubeTexture || b.mapping === xr) ? (u === void 0 && (u = new ht(new bi(1, 1, 1), new Fn({
        name: "BackgroundCubeMaterial",
        uniforms: dr(In.backgroundCube.uniforms),
        vertexShader: In.backgroundCube.vertexShader,
        fragmentShader: In.backgroundCube.fragmentShader,
        side: Zt,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(E, S, w) {
        this.matrixWorld.copyPosition(w.matrixWorld);
      }, Object.defineProperty(u.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), i.update(u)), ts.copy(x.backgroundRotation), ts.x *= -1, ts.y *= -1, ts.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === false && (ts.y *= -1, ts.z *= -1), u.material.uniforms.envMap.value = b, u.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === false ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = x.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(Dy.makeRotationFromEuler(ts)), u.material.toneMapped = st.getTransfer(b.colorSpace) !== lt, (d !== b || h !== b.version || f !== s.toneMapping) && (u.material.needsUpdate = true, d = b, h = b.version, f = s.toneMapping), u.layers.enableAll(), _.unshift(u, u.geometry, u.material, 0, 0, null)) : b && b.isTexture && (c === void 0 && (c = new ht(new Mr(2, 2), new Fn({
        name: "BackgroundMaterial",
        uniforms: dr(In.background.uniforms),
        vertexShader: In.background.vertexShader,
        fragmentShader: In.background.fragmentShader,
        side: mi,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
        get: function() {
          return this.uniforms.t2D.value;
        }
      }), i.update(c)), c.material.uniforms.t2D.value = b, c.material.uniforms.backgroundIntensity.value = x.backgroundIntensity, c.material.toneMapped = st.getTransfer(b.colorSpace) !== lt, b.matrixAutoUpdate === true && b.updateMatrix(), c.material.uniforms.uvTransform.value.copy(b.matrix), (d !== b || h !== b.version || f !== s.toneMapping) && (c.material.needsUpdate = true, d = b, h = b.version, f = s.toneMapping), c.layers.enableAll(), _.unshift(c, c.geometry, c.material, 0, 0, null));
    }
    function p(_, x) {
      _.getRGB(da, Um(s)), n.buffers.color.setClear(da.r, da.g, da.b, x, o);
    }
    return {
      getClearColor: function() {
        return a;
      },
      setClearColor: function(_, x = 1) {
        a.set(_), l = x, p(a, l);
      },
      getClearAlpha: function() {
        return l;
      },
      setClearAlpha: function(_) {
        l = _, p(a, l);
      },
      render: v,
      addToRenderList: g
    };
  }
  function Uy(s, e) {
    const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), n = {}, i = h(null);
    let r = i, o = false;
    function a(y, C, N, I, D) {
      let O = false;
      const z = d(I, N, C);
      r !== z && (r = z, c(r.object)), O = f(y, I, N, D), O && m(y, I, N, D), D !== null && e.update(D, s.ELEMENT_ARRAY_BUFFER), (O || o) && (o = false, b(y, C, N, I), D !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(D).buffer));
    }
    function l() {
      return s.createVertexArray();
    }
    function c(y) {
      return s.bindVertexArray(y);
    }
    function u(y) {
      return s.deleteVertexArray(y);
    }
    function d(y, C, N) {
      const I = N.wireframe === true;
      let D = n[y.id];
      D === void 0 && (D = {}, n[y.id] = D);
      let O = D[C.id];
      O === void 0 && (O = {}, D[C.id] = O);
      let z = O[I];
      return z === void 0 && (z = h(l()), O[I] = z), z;
    }
    function h(y) {
      const C = [], N = [], I = [];
      for (let D = 0; D < t; D++) C[D] = 0, N[D] = 0, I[D] = 0;
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes: C,
        enabledAttributes: N,
        attributeDivisors: I,
        object: y,
        attributes: {},
        index: null
      };
    }
    function f(y, C, N, I) {
      const D = r.attributes, O = C.attributes;
      let z = 0;
      const B = N.getAttributes();
      for (const U in B) if (B[U].location >= 0) {
        const V = D[U];
        let K = O[U];
        if (K === void 0 && (U === "instanceMatrix" && y.instanceMatrix && (K = y.instanceMatrix), U === "instanceColor" && y.instanceColor && (K = y.instanceColor)), V === void 0 || V.attribute !== K || K && V.data !== K.data) return true;
        z++;
      }
      return r.attributesNum !== z || r.index !== I;
    }
    function m(y, C, N, I) {
      const D = {}, O = C.attributes;
      let z = 0;
      const B = N.getAttributes();
      for (const U in B) if (B[U].location >= 0) {
        let V = O[U];
        V === void 0 && (U === "instanceMatrix" && y.instanceMatrix && (V = y.instanceMatrix), U === "instanceColor" && y.instanceColor && (V = y.instanceColor));
        const K = {};
        K.attribute = V, V && V.data && (K.data = V.data), D[U] = K, z++;
      }
      r.attributes = D, r.attributesNum = z, r.index = I;
    }
    function v() {
      const y = r.newAttributes;
      for (let C = 0, N = y.length; C < N; C++) y[C] = 0;
    }
    function g(y) {
      p(y, 0);
    }
    function p(y, C) {
      const N = r.newAttributes, I = r.enabledAttributes, D = r.attributeDivisors;
      N[y] = 1, I[y] === 0 && (s.enableVertexAttribArray(y), I[y] = 1), D[y] !== C && (s.vertexAttribDivisor(y, C), D[y] = C);
    }
    function _() {
      const y = r.newAttributes, C = r.enabledAttributes;
      for (let N = 0, I = C.length; N < I; N++) C[N] !== y[N] && (s.disableVertexAttribArray(N), C[N] = 0);
    }
    function x(y, C, N, I, D, O, z) {
      z === true ? s.vertexAttribIPointer(y, C, N, D, O) : s.vertexAttribPointer(y, C, N, I, D, O);
    }
    function b(y, C, N, I) {
      v();
      const D = I.attributes, O = N.getAttributes(), z = C.defaultAttributeValues;
      for (const B in O) {
        const U = O[B];
        if (U.location >= 0) {
          let G = D[B];
          if (G === void 0 && (B === "instanceMatrix" && y.instanceMatrix && (G = y.instanceMatrix), B === "instanceColor" && y.instanceColor && (G = y.instanceColor)), G !== void 0) {
            const V = G.normalized, K = G.itemSize, ce = e.get(G);
            if (ce === void 0) continue;
            const Te = ce.buffer, q = ce.type, te = ce.bytesPerElement, de = q === s.INT || q === s.UNSIGNED_INT || G.gpuType === tu;
            if (G.isInterleavedBufferAttribute) {
              const oe = G.data, fe = oe.stride, be = G.offset;
              if (oe.isInstancedInterleavedBuffer) {
                for (let F = 0; F < U.locationSize; F++) p(U.location + F, oe.meshPerAttribute);
                y.isInstancedMesh !== true && I._maxInstanceCount === void 0 && (I._maxInstanceCount = oe.meshPerAttribute * oe.count);
              } else for (let F = 0; F < U.locationSize; F++) g(U.location + F);
              s.bindBuffer(s.ARRAY_BUFFER, Te);
              for (let F = 0; F < U.locationSize; F++) x(U.location + F, K / U.locationSize, q, V, fe * te, (be + K / U.locationSize * F) * te, de);
            } else {
              if (G.isInstancedBufferAttribute) {
                for (let oe = 0; oe < U.locationSize; oe++) p(U.location + oe, G.meshPerAttribute);
                y.isInstancedMesh !== true && I._maxInstanceCount === void 0 && (I._maxInstanceCount = G.meshPerAttribute * G.count);
              } else for (let oe = 0; oe < U.locationSize; oe++) g(U.location + oe);
              s.bindBuffer(s.ARRAY_BUFFER, Te);
              for (let oe = 0; oe < U.locationSize; oe++) x(U.location + oe, K / U.locationSize, q, V, K * te, K / U.locationSize * oe * te, de);
            }
          } else if (z !== void 0) {
            const V = z[B];
            if (V !== void 0) switch (V.length) {
              case 2:
                s.vertexAttrib2fv(U.location, V);
                break;
              case 3:
                s.vertexAttrib3fv(U.location, V);
                break;
              case 4:
                s.vertexAttrib4fv(U.location, V);
                break;
              default:
                s.vertexAttrib1fv(U.location, V);
            }
          }
        }
      }
      _();
    }
    function E() {
      A();
      for (const y in n) {
        const C = n[y];
        for (const N in C) {
          const I = C[N];
          for (const D in I) u(I[D].object), delete I[D];
          delete C[N];
        }
        delete n[y];
      }
    }
    function S(y) {
      if (n[y.id] === void 0) return;
      const C = n[y.id];
      for (const N in C) {
        const I = C[N];
        for (const D in I) u(I[D].object), delete I[D];
        delete C[N];
      }
      delete n[y.id];
    }
    function w(y) {
      for (const C in n) {
        const N = n[C];
        if (N[y.id] === void 0) continue;
        const I = N[y.id];
        for (const D in I) u(I[D].object), delete I[D];
        delete N[y.id];
      }
    }
    function A() {
      M(), o = true, r !== i && (r = i, c(r.object));
    }
    function M() {
      i.geometry = null, i.program = null, i.wireframe = false;
    }
    return {
      setup: a,
      reset: A,
      resetDefaultState: M,
      dispose: E,
      releaseStatesOfGeometry: S,
      releaseStatesOfProgram: w,
      initAttributes: v,
      enableAttribute: g,
      disableUnusedAttributes: _
    };
  }
  function Oy(s, e, t) {
    let n;
    function i(c) {
      n = c;
    }
    function r(c, u) {
      s.drawArrays(n, c, u), t.update(u, n, 1);
    }
    function o(c, u, d) {
      d !== 0 && (s.drawArraysInstanced(n, c, u, d), t.update(u, n, d));
    }
    function a(c, u, d) {
      if (d === 0) return;
      const h = e.get("WEBGL_multi_draw");
      if (h === null) for (let f = 0; f < d; f++) this.render(c[f], u[f]);
      else {
        h.multiDrawArraysWEBGL(n, c, 0, u, 0, d);
        let f = 0;
        for (let m = 0; m < d; m++) f += u[m];
        t.update(f, n, 1);
      }
    }
    function l(c, u, d, h) {
      if (d === 0) return;
      const f = e.get("WEBGL_multi_draw");
      if (f === null) for (let m = 0; m < c.length; m++) o(c[m], u[m], h[m]);
      else {
        f.multiDrawArraysInstancedWEBGL(n, c, 0, u, 0, h, 0, d);
        let m = 0;
        for (let v = 0; v < d; v++) m += u[v];
        for (let v = 0; v < h.length; v++) t.update(m, n, h[v]);
      }
    }
    this.setMode = i, this.render = r, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
  }
  function zy(s, e, t, n) {
    let i;
    function r() {
      if (i !== void 0) return i;
      if (e.has("EXT_texture_filter_anisotropic") === true) {
        const S = e.get("EXT_texture_filter_anisotropic");
        i = s.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else i = 0;
      return i;
    }
    function o(S) {
      return !(S !== dn && n.convert(S) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
    }
    function a(S) {
      const w = S === Do && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
      return !(S !== vi && n.convert(S) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && S !== Tn && !w);
    }
    function l(S) {
      if (S === "highp") {
        if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0) return "highp";
        S = "mediump";
      }
      return S === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const u = l(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
    const d = t.logarithmicDepthBuffer === true, h = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), f = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_TEXTURE_SIZE), v = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), g = s.getParameter(s.MAX_VERTEX_ATTRIBS), p = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), _ = s.getParameter(s.MAX_VARYING_VECTORS), x = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), b = f > 0, E = s.getParameter(s.MAX_SAMPLES);
    return {
      isWebGL2: true,
      getMaxAnisotropy: r,
      getMaxPrecision: l,
      textureFormatReadable: o,
      textureTypeReadable: a,
      precision: c,
      logarithmicDepthBuffer: d,
      maxTextures: h,
      maxVertexTextures: f,
      maxTextureSize: m,
      maxCubemapSize: v,
      maxAttributes: g,
      maxVertexUniforms: p,
      maxVaryings: _,
      maxFragmentUniforms: x,
      vertexTextures: b,
      maxSamples: E
    };
  }
  function Fy(s) {
    const e = this;
    let t = null, n = 0, i = false, r = false;
    const o = new Li(), a = new Fe(), l = {
      value: null,
      needsUpdate: false
    };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, h) {
      const f = d.length !== 0 || h || n !== 0 || i;
      return i = h, n = d.length, f;
    }, this.beginShadows = function() {
      r = true, u(null);
    }, this.endShadows = function() {
      r = false;
    }, this.setGlobalState = function(d, h) {
      t = u(d, h, 0);
    }, this.setState = function(d, h, f) {
      const m = d.clippingPlanes, v = d.clipIntersection, g = d.clipShadows, p = s.get(d);
      if (!i || m === null || m.length === 0 || r && !g) r ? u(null) : c();
      else {
        const _ = r ? 0 : n, x = _ * 4;
        let b = p.clippingState || null;
        l.value = b, b = u(m, h, x, f);
        for (let E = 0; E !== x; ++E) b[E] = t[E];
        p.clippingState = b, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += _;
      }
    };
    function c() {
      l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
    }
    function u(d, h, f, m) {
      const v = d !== null ? d.length : 0;
      let g = null;
      if (v !== 0) {
        if (g = l.value, m !== true || g === null) {
          const p = f + v * 4, _ = h.matrixWorldInverse;
          a.getNormalMatrix(_), (g === null || g.length < p) && (g = new Float32Array(p));
          for (let x = 0, b = f; x !== v; ++x, b += 4) o.copy(d[x]).applyMatrix4(_, a), o.normal.toArray(g, b), g[b + 3] = o.constant;
        }
        l.value = g, l.needsUpdate = true;
      }
      return e.numPlanes = v, e.numIntersection = 0, g;
    }
  }
  function By(s) {
    let e = /* @__PURE__ */ new WeakMap();
    function t(o, a) {
      return a === cr ? o.mapping = gi : a === io && (o.mapping = Bi), o;
    }
    function n(o) {
      if (o && o.isTexture) {
        const a = o.mapping;
        if (a === cr || a === io) if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new Fm(l.height);
            return c.fromEquirectangularTexture(s, o), e.set(o, c), o.addEventListener("dispose", i), t(c.texture, o.mapping);
          } else return null;
        }
      }
      return o;
    }
    function i(o) {
      const a = o.target;
      a.removeEventListener("dispose", i);
      const l = e.get(a);
      l !== void 0 && (e.delete(a), l.dispose());
    }
    function r() {
      e = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: n,
      dispose: r
    };
  }
  class Tl extends wl {
    constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
      super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
    }
    setViewOffset(e, t, n, i, r, o) {
      this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
      let r = n - e, o = n + e, a = i + t, l = i - t;
      if (this.view !== null && this.view.enabled) {
        const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        r += c * this.view.offsetX, o = r + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }
  const tr = 4, wd = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
  ], ms = 20, _c = new Tl(), Td = new ye();
  let yc = null, Mc = 0, bc = 0, Sc = false;
  const ps = (1 + Math.sqrt(5)) / 2, Ys = 1 / ps, Ed = [
    new P(-ps, Ys, 0),
    new P(ps, Ys, 0),
    new P(-Ys, 0, ps),
    new P(Ys, 0, ps),
    new P(0, ps, -Ys),
    new P(0, ps, Ys),
    new P(-1, 1, -1),
    new P(1, 1, -1),
    new P(-1, 1, 1),
    new P(1, 1, 1)
  ];
  class Ph {
    constructor(e) {
      this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, n = 0.1, i = 100) {
      yc = this._renderer.getRenderTarget(), Mc = this._renderer.getActiveCubeFace(), bc = this._renderer.getActiveMipmapLevel(), Sc = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
      const r = this._allocateTargets();
      return r.depthBuffer = true, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
    }
    fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
      return this._fromTexture(e, t);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null && (this._cubemapMaterial = Rd(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null && (this._equirectMaterial = Cd(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
      this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
      this._renderer.setRenderTarget(yc, Mc, bc), this._renderer.xr.enabled = Sc, e.scissorTest = false, fa(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
      e.mapping === gi || e.mapping === Bi ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), yc = this._renderer.getRenderTarget(), Mc = this._renderer.getActiveCubeFace(), bc = this._renderer.getActiveMipmapLevel(), Sc = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
      const n = t || this._allocateTargets();
      return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
    }
    _allocateTargets() {
      const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
        magFilter: Mt,
        minFilter: Mt,
        generateMipmaps: false,
        type: Do,
        format: dn,
        colorSpace: yi,
        depthBuffer: false
      }, i = Ad(e, t, n);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
        this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Ad(e, t, n);
        const { _lodMax: r } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = ky(r)), this._blurMaterial = Vy(r, e, t);
      }
      return i;
    }
    _compileMaterial(e) {
      const t = new ht(this._lodPlanes[0], e);
      this._renderer.compile(t, _c);
    }
    _sceneToCubeUV(e, t, n, i) {
      const a = new Et(90, 1, t, n), l = [
        1,
        -1,
        1,
        1,
        1,
        1
      ], c = [
        1,
        1,
        1,
        -1,
        -1,
        -1
      ], u = this._renderer, d = u.autoClear, h = u.toneMapping;
      u.getClearColor(Td), u.toneMapping = fi, u.autoClear = false;
      const f = new Xi({
        name: "PMREM.Background",
        side: Zt,
        depthWrite: false,
        depthTest: false
      }), m = new ht(new bi(), f);
      let v = false;
      const g = e.background;
      g ? g.isColor && (f.color.copy(g), e.background = null, v = true) : (f.color.copy(Td), v = true);
      for (let p = 0; p < 6; p++) {
        const _ = p % 3;
        _ === 0 ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
        const x = this._cubeSize;
        fa(i, _ * x, p > 2 ? x : 0, x, x), u.setRenderTarget(i), v && u.render(m, a), u.render(e, a);
      }
      m.geometry.dispose(), m.material.dispose(), u.toneMapping = h, u.autoClear = d, e.background = g;
    }
    _textureToCubeUV(e, t) {
      const n = this._renderer, i = e.mapping === gi || e.mapping === Bi;
      i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Rd()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Cd());
      const r = i ? this._cubemapMaterial : this._equirectMaterial, o = new ht(this._lodPlanes[0], r), a = r.uniforms;
      a.envMap.value = e;
      const l = this._cubeSize;
      fa(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, _c);
    }
    _applyPMREM(e) {
      const t = this._renderer, n = t.autoClear;
      t.autoClear = false;
      const i = this._lodPlanes.length;
      for (let r = 1; r < i; r++) {
        const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = Ed[(i - r - 1) % Ed.length];
        this._blur(e, r - 1, r, o, a);
      }
      t.autoClear = n;
    }
    _blur(e, t, n, i, r) {
      const o = this._pingPongRenderTarget;
      this._halfBlur(e, o, t, n, i, "latitudinal", r), this._halfBlur(o, e, n, n, i, "longitudinal", r);
    }
    _halfBlur(e, t, n, i, r, o, a) {
      const l = this._renderer, c = this._blurMaterial;
      o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const u = 3, d = new ht(this._lodPlanes[i], c), h = c.uniforms, f = this._sizeLods[n] - 1, m = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * ms - 1), v = r / m, g = isFinite(r) ? 1 + Math.floor(u * v) : ms;
      g > ms && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${ms}`);
      const p = [];
      let _ = 0;
      for (let w = 0; w < ms; ++w) {
        const A = w / v, M = Math.exp(-A * A / 2);
        p.push(M), w === 0 ? _ += M : w < g && (_ += 2 * M);
      }
      for (let w = 0; w < p.length; w++) p[w] = p[w] / _;
      h.envMap.value = e.texture, h.samples.value = g, h.weights.value = p, h.latitudinal.value = o === "latitudinal", a && (h.poleAxis.value = a);
      const { _lodMax: x } = this;
      h.dTheta.value = m, h.mipInt.value = x - n;
      const b = this._sizeLods[i], E = 3 * b * (i > x - tr ? i - x + tr : 0), S = 4 * (this._cubeSize - b);
      fa(t, E, S, 3 * b, 2 * b), l.setRenderTarget(t), l.render(d, _c);
    }
  }
  function ky(s) {
    const e = [], t = [], n = [];
    let i = s;
    const r = s - tr + 1 + wd.length;
    for (let o = 0; o < r; o++) {
      const a = Math.pow(2, i);
      t.push(a);
      let l = 1 / a;
      o > s - tr ? l = wd[o - s + tr - 1] : o === 0 && (l = 0), n.push(l);
      const c = 1 / (a - 2), u = -c, d = 1 + c, h = [
        u,
        u,
        d,
        u,
        d,
        d,
        u,
        u,
        d,
        d,
        u,
        d
      ], f = 6, m = 6, v = 3, g = 2, p = 1, _ = new Float32Array(v * m * f), x = new Float32Array(g * m * f), b = new Float32Array(p * m * f);
      for (let S = 0; S < f; S++) {
        const w = S % 3 * 2 / 3 - 1, A = S > 2 ? 0 : -1, M = [
          w,
          A,
          0,
          w + 2 / 3,
          A,
          0,
          w + 2 / 3,
          A + 1,
          0,
          w,
          A,
          0,
          w + 2 / 3,
          A + 1,
          0,
          w,
          A + 1,
          0
        ];
        _.set(M, v * m * S), x.set(h, g * m * S);
        const y = [
          S,
          S,
          S,
          S,
          S,
          S
        ];
        b.set(y, p * m * S);
      }
      const E = new We();
      E.setAttribute("position", new at(_, v)), E.setAttribute("uv", new at(x, g)), E.setAttribute("faceIndex", new at(b, p)), e.push(E), i > tr && i--;
    }
    return {
      lodPlanes: e,
      sizeLods: t,
      sigmas: n
    };
  }
  function Ad(s, e, t) {
    const n = new zn(s, e, t);
    return n.texture.mapping = xr, n.texture.name = "PMREM.cubeUv", n.scissorTest = true, n;
  }
  function fa(s, e, t, n, i) {
    s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
  }
  function Vy(s, e, t) {
    const n = new Float32Array(ms), i = new P(0, 1, 0);
    return new Fn({
      name: "SphericalGaussianBlur",
      defines: {
        n: ms,
        CUBEUV_TEXEL_WIDTH: 1 / e,
        CUBEUV_TEXEL_HEIGHT: 1 / t,
        CUBEUV_MAX_MIP: `${s}.0`
      },
      uniforms: {
        envMap: {
          value: null
        },
        samples: {
          value: 1
        },
        weights: {
          value: n
        },
        latitudinal: {
          value: false
        },
        dTheta: {
          value: 0
        },
        mipInt: {
          value: 0
        },
        poleAxis: {
          value: i
        }
      },
      vertexShader: pu(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: di,
      depthTest: false,
      depthWrite: false
    });
  }
  function Cd() {
    return new Fn({
      name: "EquirectangularToCubeUV",
      uniforms: {
        envMap: {
          value: null
        }
      },
      vertexShader: pu(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: di,
      depthTest: false,
      depthWrite: false
    });
  }
  function Rd() {
    return new Fn({
      name: "CubemapToCubeUV",
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        }
      },
      vertexShader: pu(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: di,
      depthTest: false,
      depthWrite: false
    });
  }
  function pu() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function Hy(s) {
    let e = /* @__PURE__ */ new WeakMap(), t = null;
    function n(a) {
      if (a && a.isTexture) {
        const l = a.mapping, c = l === cr || l === io, u = l === gi || l === Bi;
        if (c || u) {
          let d = e.get(a);
          const h = d !== void 0 ? d.texture.pmremVersion : 0;
          if (a.isRenderTargetTexture && a.pmremVersion !== h) return t === null && (t = new Ph(s)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), d.texture.pmremVersion = a.pmremVersion, e.set(a, d), d.texture;
          if (d !== void 0) return d.texture;
          {
            const f = a.image;
            return c && f && f.height > 0 || u && f && i(f) ? (t === null && (t = new Ph(s)), d = c ? t.fromEquirectangular(a) : t.fromCubemap(a), d.texture.pmremVersion = a.pmremVersion, e.set(a, d), a.addEventListener("dispose", r), d.texture) : null;
          }
        }
      }
      return a;
    }
    function i(a) {
      let l = 0;
      const c = 6;
      for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
      return l === c;
    }
    function r(a) {
      const l = a.target;
      l.removeEventListener("dispose", r);
      const c = e.get(l);
      c !== void 0 && (e.delete(l), c.dispose());
    }
    function o() {
      e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
    }
    return {
      get: n,
      dispose: o
    };
  }
  function Gy(s) {
    const e = {};
    function t(n) {
      if (e[n] !== void 0) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = s.getExtension(n);
      }
      return e[n] = i, i;
    }
    return {
      has: function(n) {
        return t(n) !== null;
      },
      init: function() {
        t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
      },
      get: function(n) {
        const i = t(n);
        return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
      }
    };
  }
  function Wy(s, e, t, n) {
    const i = {}, r = /* @__PURE__ */ new WeakMap();
    function o(d) {
      const h = d.target;
      h.index !== null && e.remove(h.index);
      for (const m in h.attributes) e.remove(h.attributes[m]);
      for (const m in h.morphAttributes) {
        const v = h.morphAttributes[m];
        for (let g = 0, p = v.length; g < p; g++) e.remove(v[g]);
      }
      h.removeEventListener("dispose", o), delete i[h.id];
      const f = r.get(h);
      f && (e.remove(f), r.delete(h)), n.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === true && delete h._maxInstanceCount, t.memory.geometries--;
    }
    function a(d, h) {
      return i[h.id] === true || (h.addEventListener("dispose", o), i[h.id] = true, t.memory.geometries++), h;
    }
    function l(d) {
      const h = d.attributes;
      for (const m in h) e.update(h[m], s.ARRAY_BUFFER);
      const f = d.morphAttributes;
      for (const m in f) {
        const v = f[m];
        for (let g = 0, p = v.length; g < p; g++) e.update(v[g], s.ARRAY_BUFFER);
      }
    }
    function c(d) {
      const h = [], f = d.index, m = d.attributes.position;
      let v = 0;
      if (f !== null) {
        const _ = f.array;
        v = f.version;
        for (let x = 0, b = _.length; x < b; x += 3) {
          const E = _[x + 0], S = _[x + 1], w = _[x + 2];
          h.push(E, S, S, w, w, E);
        }
      } else if (m !== void 0) {
        const _ = m.array;
        v = m.version;
        for (let x = 0, b = _.length / 3 - 1; x < b; x += 3) {
          const E = x + 0, S = x + 1, w = x + 2;
          h.push(E, S, S, w, w, E);
        }
      } else return;
      const g = new (Rm(h) ? fu : du)(h, 1);
      g.version = v;
      const p = r.get(d);
      p && e.remove(p), r.set(d, g);
    }
    function u(d) {
      const h = r.get(d);
      if (h) {
        const f = d.index;
        f !== null && h.version < f.version && c(d);
      } else c(d);
      return r.get(d);
    }
    return {
      get: a,
      update: l,
      getWireframeAttribute: u
    };
  }
  function Xy(s, e, t) {
    let n;
    function i(h) {
      n = h;
    }
    let r, o;
    function a(h) {
      r = h.type, o = h.bytesPerElement;
    }
    function l(h, f) {
      s.drawElements(n, f, r, h * o), t.update(f, n, 1);
    }
    function c(h, f, m) {
      m !== 0 && (s.drawElementsInstanced(n, f, r, h * o, m), t.update(f, n, m));
    }
    function u(h, f, m) {
      if (m === 0) return;
      const v = e.get("WEBGL_multi_draw");
      if (v === null) for (let g = 0; g < m; g++) this.render(h[g] / o, f[g]);
      else {
        v.multiDrawElementsWEBGL(n, f, 0, r, h, 0, m);
        let g = 0;
        for (let p = 0; p < m; p++) g += f[p];
        t.update(g, n, 1);
      }
    }
    function d(h, f, m, v) {
      if (m === 0) return;
      const g = e.get("WEBGL_multi_draw");
      if (g === null) for (let p = 0; p < h.length; p++) c(h[p] / o, f[p], v[p]);
      else {
        g.multiDrawElementsInstancedWEBGL(n, f, 0, r, h, 0, v, 0, m);
        let p = 0;
        for (let _ = 0; _ < m; _++) p += f[_];
        for (let _ = 0; _ < v.length; _++) t.update(p, n, v[_]);
      }
    }
    this.setMode = i, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = d;
  }
  function Yy(s) {
    const e = {
      geometries: 0,
      textures: 0
    }, t = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function n(r, o, a) {
      switch (t.calls++, o) {
        case s.TRIANGLES:
          t.triangles += a * (r / 3);
          break;
        case s.LINES:
          t.lines += a * (r / 2);
          break;
        case s.LINE_STRIP:
          t.lines += a * (r - 1);
          break;
        case s.LINE_LOOP:
          t.lines += a * r;
          break;
        case s.POINTS:
          t.points += a * r;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", o);
          break;
      }
    }
    function i() {
      t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
    }
    return {
      memory: e,
      render: t,
      programs: null,
      autoReset: true,
      reset: i,
      update: n
    };
  }
  function qy(s, e, t) {
    const n = /* @__PURE__ */ new WeakMap(), i = new rt();
    function r(o, a, l) {
      const c = o.morphTargetInfluences, u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, d = u !== void 0 ? u.length : 0;
      let h = n.get(a);
      if (h === void 0 || h.count !== d) {
        let M = function() {
          w.dispose(), n.delete(a), a.removeEventListener("dispose", M);
        };
        h !== void 0 && h.texture.dispose();
        const f = a.morphAttributes.position !== void 0, m = a.morphAttributes.normal !== void 0, v = a.morphAttributes.color !== void 0, g = a.morphAttributes.position || [], p = a.morphAttributes.normal || [], _ = a.morphAttributes.color || [];
        let x = 0;
        f === true && (x = 1), m === true && (x = 2), v === true && (x = 3);
        let b = a.attributes.position.count * x, E = 1;
        b > e.maxTextureSize && (E = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
        const S = new Float32Array(b * E * 4 * d), w = new bl(S, b, E, d);
        w.type = Tn, w.needsUpdate = true;
        const A = x * 4;
        for (let y = 0; y < d; y++) {
          const C = g[y], N = p[y], I = _[y], D = b * E * 4 * y;
          for (let O = 0; O < C.count; O++) {
            const z = O * A;
            f === true && (i.fromBufferAttribute(C, O), S[D + z + 0] = i.x, S[D + z + 1] = i.y, S[D + z + 2] = i.z, S[D + z + 3] = 0), m === true && (i.fromBufferAttribute(N, O), S[D + z + 4] = i.x, S[D + z + 5] = i.y, S[D + z + 6] = i.z, S[D + z + 7] = 0), v === true && (i.fromBufferAttribute(I, O), S[D + z + 8] = i.x, S[D + z + 9] = i.y, S[D + z + 10] = i.z, S[D + z + 11] = I.itemSize === 4 ? i.w : 1);
          }
        }
        h = {
          count: d,
          texture: w,
          size: new ee(b, E)
        }, n.set(a, h), a.addEventListener("dispose", M);
      }
      if (o.isInstancedMesh === true && o.morphTexture !== null) l.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
      else {
        let f = 0;
        for (let v = 0; v < c.length; v++) f += c[v];
        const m = a.morphTargetsRelative ? 1 : 1 - f;
        l.getUniforms().setValue(s, "morphTargetBaseInfluence", m), l.getUniforms().setValue(s, "morphTargetInfluences", c);
      }
      l.getUniforms().setValue(s, "morphTargetsTexture", h.texture, t), l.getUniforms().setValue(s, "morphTargetsTextureSize", h.size);
    }
    return {
      update: r
    };
  }
  function $y(s, e, t, n) {
    let i = /* @__PURE__ */ new WeakMap();
    function r(l) {
      const c = n.render.frame, u = l.geometry, d = e.get(l, u);
      if (i.get(d) !== c && (e.update(d), i.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === false && l.addEventListener("dispose", a), i.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
        const h = l.skeleton;
        i.get(h) !== c && (h.update(), i.set(h, c));
      }
      return d;
    }
    function o() {
      i = /* @__PURE__ */ new WeakMap();
    }
    function a(l) {
      const c = l.target;
      c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
    }
    return {
      update: r,
      dispose: o
    };
  }
  class mu extends gt {
    constructor(e, t, n, i, r, o, a, l, c, u) {
      if (u = u !== void 0 ? u : Ss, u !== Ss && u !== hr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n === void 0 && u === Ss && (n = Ts), n === void 0 && u === hr && (n = _r), super(null, i, r, o, a, l, u, n, c), this.isDepthTexture = true, this.image = {
        width: e,
        height: t
      }, this.magFilter = a !== void 0 ? a : At, this.minFilter = l !== void 0 ? l : At, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
    }
    copy(e) {
      return super.copy(e), this.compareFunction = e.compareFunction, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
    }
  }
  const km = new gt(), Vm = new mu(1, 1);
  Vm.compareFunction = cu;
  const Hm = new bl(), Gm = new uu(), Wm = new Uo(), Pd = [], Id = [], Ld = new Float32Array(16), Dd = new Float32Array(9), Nd = new Float32Array(4);
  function br(s, e, t) {
    const n = s[0];
    if (n <= 0 || n > 0) return s;
    const i = e * t;
    let r = Pd[i];
    if (r === void 0 && (r = new Float32Array(i), Pd[i] = r), e !== 0) {
      n.toArray(r, 0);
      for (let o = 1, a = 0; o !== e; ++o) a += t, s[o].toArray(r, a);
    }
    return r;
  }
  function St(s, e) {
    if (s.length !== e.length) return false;
    for (let t = 0, n = s.length; t < n; t++) if (s[t] !== e[t]) return false;
    return true;
  }
  function wt(s, e) {
    for (let t = 0, n = e.length; t < n; t++) s[t] = e[t];
  }
  function El(s, e) {
    let t = Id[e];
    t === void 0 && (t = new Int32Array(e), Id[e] = t);
    for (let n = 0; n !== e; ++n) t[n] = s.allocateTextureUnit();
    return t;
  }
  function Zy(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
  }
  function Jy(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (St(t, e)) return;
      s.uniform2fv(this.addr, e), wt(t, e);
    }
  }
  function Ky(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
      if (St(t, e)) return;
      s.uniform3fv(this.addr, e), wt(t, e);
    }
  }
  function jy(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (St(t, e)) return;
      s.uniform4fv(this.addr, e), wt(t, e);
    }
  }
  function Qy(s, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (St(t, e)) return;
      s.uniformMatrix2fv(this.addr, false, e), wt(t, e);
    } else {
      if (St(t, n)) return;
      Nd.set(n), s.uniformMatrix2fv(this.addr, false, Nd), wt(t, n);
    }
  }
  function eM(s, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (St(t, e)) return;
      s.uniformMatrix3fv(this.addr, false, e), wt(t, e);
    } else {
      if (St(t, n)) return;
      Dd.set(n), s.uniformMatrix3fv(this.addr, false, Dd), wt(t, n);
    }
  }
  function tM(s, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (St(t, e)) return;
      s.uniformMatrix4fv(this.addr, false, e), wt(t, e);
    } else {
      if (St(t, n)) return;
      Ld.set(n), s.uniformMatrix4fv(this.addr, false, Ld), wt(t, n);
    }
  }
  function nM(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
  }
  function iM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (St(t, e)) return;
      s.uniform2iv(this.addr, e), wt(t, e);
    }
  }
  function sM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
      if (St(t, e)) return;
      s.uniform3iv(this.addr, e), wt(t, e);
    }
  }
  function rM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (St(t, e)) return;
      s.uniform4iv(this.addr, e), wt(t, e);
    }
  }
  function oM(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
  }
  function aM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (St(t, e)) return;
      s.uniform2uiv(this.addr, e), wt(t, e);
    }
  }
  function lM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
      if (St(t, e)) return;
      s.uniform3uiv(this.addr, e), wt(t, e);
    }
  }
  function cM(s, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (St(t, e)) return;
      s.uniform4uiv(this.addr, e), wt(t, e);
    }
  }
  function hM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
    const r = this.type === s.SAMPLER_2D_SHADOW ? Vm : km;
    t.setTexture2D(e || r, i);
  }
  function uM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || Gm, i);
  }
  function dM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || Wm, i);
  }
  function fM(s, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || Hm, i);
  }
  function pM(s) {
    switch (s) {
      case 5126:
        return Zy;
      case 35664:
        return Jy;
      case 35665:
        return Ky;
      case 35666:
        return jy;
      case 35674:
        return Qy;
      case 35675:
        return eM;
      case 35676:
        return tM;
      case 5124:
      case 35670:
        return nM;
      case 35667:
      case 35671:
        return iM;
      case 35668:
      case 35672:
        return sM;
      case 35669:
      case 35673:
        return rM;
      case 5125:
        return oM;
      case 36294:
        return aM;
      case 36295:
        return lM;
      case 36296:
        return cM;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return hM;
      case 35679:
      case 36299:
      case 36307:
        return uM;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return dM;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return fM;
    }
  }
  function mM(s, e) {
    s.uniform1fv(this.addr, e);
  }
  function gM(s, e) {
    const t = br(e, this.size, 2);
    s.uniform2fv(this.addr, t);
  }
  function vM(s, e) {
    const t = br(e, this.size, 3);
    s.uniform3fv(this.addr, t);
  }
  function xM(s, e) {
    const t = br(e, this.size, 4);
    s.uniform4fv(this.addr, t);
  }
  function _M(s, e) {
    const t = br(e, this.size, 4);
    s.uniformMatrix2fv(this.addr, false, t);
  }
  function yM(s, e) {
    const t = br(e, this.size, 9);
    s.uniformMatrix3fv(this.addr, false, t);
  }
  function MM(s, e) {
    const t = br(e, this.size, 16);
    s.uniformMatrix4fv(this.addr, false, t);
  }
  function bM(s, e) {
    s.uniform1iv(this.addr, e);
  }
  function SM(s, e) {
    s.uniform2iv(this.addr, e);
  }
  function wM(s, e) {
    s.uniform3iv(this.addr, e);
  }
  function TM(s, e) {
    s.uniform4iv(this.addr, e);
  }
  function EM(s, e) {
    s.uniform1uiv(this.addr, e);
  }
  function AM(s, e) {
    s.uniform2uiv(this.addr, e);
  }
  function CM(s, e) {
    s.uniform3uiv(this.addr, e);
  }
  function RM(s, e) {
    s.uniform4uiv(this.addr, e);
  }
  function PM(s, e, t) {
    const n = this.cache, i = e.length, r = El(t, i);
    St(n, r) || (s.uniform1iv(this.addr, r), wt(n, r));
    for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || km, r[o]);
  }
  function IM(s, e, t) {
    const n = this.cache, i = e.length, r = El(t, i);
    St(n, r) || (s.uniform1iv(this.addr, r), wt(n, r));
    for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || Gm, r[o]);
  }
  function LM(s, e, t) {
    const n = this.cache, i = e.length, r = El(t, i);
    St(n, r) || (s.uniform1iv(this.addr, r), wt(n, r));
    for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || Wm, r[o]);
  }
  function DM(s, e, t) {
    const n = this.cache, i = e.length, r = El(t, i);
    St(n, r) || (s.uniform1iv(this.addr, r), wt(n, r));
    for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || Hm, r[o]);
  }
  function NM(s) {
    switch (s) {
      case 5126:
        return mM;
      case 35664:
        return gM;
      case 35665:
        return vM;
      case 35666:
        return xM;
      case 35674:
        return _M;
      case 35675:
        return yM;
      case 35676:
        return MM;
      case 5124:
      case 35670:
        return bM;
      case 35667:
      case 35671:
        return SM;
      case 35668:
      case 35672:
        return wM;
      case 35669:
      case 35673:
        return TM;
      case 5125:
        return EM;
      case 36294:
        return AM;
      case 36295:
        return CM;
      case 36296:
        return RM;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return PM;
      case 35679:
      case 36299:
      case 36307:
        return IM;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return LM;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return DM;
    }
  }
  class UM {
    constructor(e, t, n) {
      this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = pM(t.type);
    }
  }
  class OM {
    constructor(e, t, n) {
      this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = NM(t.type);
    }
  }
  class zM {
    constructor(e) {
      this.id = e, this.seq = [], this.map = {};
    }
    setValue(e, t, n) {
      const i = this.seq;
      for (let r = 0, o = i.length; r !== o; ++r) {
        const a = i[r];
        a.setValue(e, t[a.id], n);
      }
    }
  }
  const wc = /(\w+)(\])?(\[|\.)?/g;
  function Ud(s, e) {
    s.seq.push(e), s.map[e.id] = e;
  }
  function FM(s, e, t) {
    const n = s.name, i = n.length;
    for (wc.lastIndex = 0; ; ) {
      const r = wc.exec(n), o = wc.lastIndex;
      let a = r[1];
      const l = r[2] === "]", c = r[3];
      if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === i) {
        Ud(t, c === void 0 ? new UM(a, s, e) : new OM(a, s, e));
        break;
      } else {
        let d = t.map[a];
        d === void 0 && (d = new zM(a), Ud(t, d)), t = d;
      }
    }
  }
  class Ya {
    constructor(e, t) {
      this.seq = [], this.map = {};
      const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const r = e.getActiveUniform(t, i), o = e.getUniformLocation(t, r.name);
        FM(r, o, this);
      }
    }
    setValue(e, t, n, i) {
      const r = this.map[t];
      r !== void 0 && r.setValue(e, n, i);
    }
    setOptional(e, t, n) {
      const i = t[n];
      i !== void 0 && this.setValue(e, n, i);
    }
    static upload(e, t, n, i) {
      for (let r = 0, o = t.length; r !== o; ++r) {
        const a = t[r], l = n[a.id];
        l.needsUpdate !== false && a.setValue(e, l.value, i);
      }
    }
    static seqWithValue(e, t) {
      const n = [];
      for (let i = 0, r = e.length; i !== r; ++i) {
        const o = e[i];
        o.id in t && n.push(o);
      }
      return n;
    }
  }
  function Od(s, e, t) {
    const n = s.createShader(e);
    return s.shaderSource(n, t), s.compileShader(n), n;
  }
  const BM = 37297;
  let kM = 0;
  function VM(s, e) {
    const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
    for (let o = i; o < r; o++) {
      const a = o + 1;
      n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
    }
    return n.join(`
`);
  }
  function HM(s) {
    const e = st.getPrimaries(st.workingColorSpace), t = st.getPrimaries(s);
    let n;
    switch (e === t ? n = "" : e === uo && t === ho ? n = "LinearDisplayP3ToLinearSRGB" : e === ho && t === uo && (n = "LinearSRGBToLinearDisplayP3"), s) {
      case yi:
      case No:
        return [
          n,
          "LinearTransferOETF"
        ];
      case Mn:
      case Ml:
        return [
          n,
          "sRGBTransferOETF"
        ];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [
          n,
          "LinearTransferOETF"
        ];
    }
  }
  function zd(s, e, t) {
    const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
    if (n && i === "") return "";
    const r = /ERROR: 0:(\d+)/.exec(i);
    if (r) {
      const o = parseInt(r[1]);
      return t.toUpperCase() + `

` + i + `

` + VM(s.getShaderSource(e), o);
    } else return i;
  }
  function GM(s, e) {
    const t = HM(e);
    return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
  }
  function WM(s, e) {
    let t;
    switch (e) {
      case Qp:
        t = "Linear";
        break;
      case em:
        t = "Reinhard";
        break;
      case tm:
        t = "OptimizedCineon";
        break;
      case nm:
        t = "ACESFilmic";
        break;
      case sm:
        t = "AgX";
        break;
      case rm:
        t = "Neutral";
        break;
      case im:
        t = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
    }
    return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
  }
  function XM(s) {
    return [
      s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
      s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
    ].filter(Xr).join(`
`);
  }
  function YM(s) {
    const e = [];
    for (const t in s) {
      const n = s[t];
      n !== false && e.push("#define " + t + " " + n);
    }
    return e.join(`
`);
  }
  function qM(s, e) {
    const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
      const r = s.getActiveAttrib(e, i), o = r.name;
      let a = 1;
      r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = {
        type: r.type,
        location: s.getAttribLocation(e, o),
        locationSize: a
      };
    }
    return t;
  }
  function Xr(s) {
    return s !== "";
  }
  function Fd(s, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function Bd(s, e) {
    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
  }
  const $M = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Ih(s) {
    return s.replace($M, JM);
  }
  const ZM = /* @__PURE__ */ new Map();
  function JM(s, e) {
    let t = Ve[e];
    if (t === void 0) {
      const n = ZM.get(e);
      if (n !== void 0) t = Ve[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
      else throw new Error("Can not resolve #include <" + e + ">");
    }
    return Ih(t);
  }
  const KM = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function kd(s) {
    return s.replace(KM, jM);
  }
  function jM(s, e, t, n) {
    let i = "";
    for (let r = parseInt(e); r < parseInt(t); r++) i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return i;
  }
  function Vd(s) {
    let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
    return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
  }
  function QM(s) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return s.shadowMapType === Io ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === xl ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Gn && (e = "SHADOWMAP_TYPE_VSM"), e;
  }
  function eb(s) {
    let e = "ENVMAP_TYPE_CUBE";
    if (s.envMap) switch (s.envMapMode) {
      case gi:
      case Bi:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case xr:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
    return e;
  }
  function tb(s) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (s.envMap) switch (s.envMapMode) {
      case Bi:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
    return e;
  }
  function nb(s) {
    let e = "ENVMAP_BLENDING_NONE";
    if (s.envMap) switch (s.combine) {
      case Lo:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Kp:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case jp:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
    return e;
  }
  function ib(s) {
    const e = s.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2, n = 1 / e;
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
      texelHeight: n,
      maxMip: t
    };
  }
  function sb(s, e, t, n) {
    const i = s.getContext(), r = t.defines;
    let o = t.vertexShader, a = t.fragmentShader;
    const l = QM(t), c = eb(t), u = tb(t), d = nb(t), h = ib(t), f = XM(t), m = YM(r), v = i.createProgram();
    let g, p, _ = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (g = [
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      m
    ].filter(Xr).join(`
`), g.length > 0 && (g += `
`), p = [
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      m
    ].filter(Xr).join(`
`), p.length > 0 && (p += `
`)) : (g = [
      Vd(t),
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      m,
      t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      t.batching ? "#define USE_BATCHING" : "",
      t.instancing ? "#define USE_INSTANCING" : "",
      t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.map ? "#define USE_MAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + u : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.anisotropy ? "#define USE_ANISOTROPY" : "",
      t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.alphaHash ? "#define USE_ALPHAHASH" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      t.mapUv ? "#define MAP_UV " + t.mapUv : "",
      t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
      t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
      t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
      t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
      t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
      t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
      t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
      t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
      t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
      t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
      t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
      t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
      t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
      t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
      t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
      t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
      t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
      t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
      t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
      t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
      t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
      t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
      t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
      t.vertexColors ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUv1s ? "#define USE_UV1" : "",
      t.vertexUv2s ? "#define USE_UV2" : "",
      t.vertexUv3s ? "#define USE_UV3" : "",
      t.pointsUvs ? "#define USE_POINTS_UV" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.skinning ? "#define USE_SKINNING" : "",
      t.morphTargets ? "#define USE_MORPHTARGETS" : "",
      t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      t.morphColors ? "#define USE_MORPHCOLORS" : "",
      t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
      t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
      t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + l : "",
      t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(Xr).join(`
`), p = [
      Vd(t),
      "#define SHADER_TYPE " + t.shaderType,
      "#define SHADER_NAME " + t.shaderName,
      m,
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      t.map ? "#define USE_MAP" : "",
      t.matcap ? "#define USE_MATCAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + c : "",
      t.envMap ? "#define " + u : "",
      t.envMap ? "#define " + d : "",
      h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
      h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
      h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.anisotropy ? "#define USE_ANISOTROPY" : "",
      t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      t.clearcoat ? "#define USE_CLEARCOAT" : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.dispersion ? "#define USE_DISPERSION" : "",
      t.iridescence ? "#define USE_IRIDESCENCE" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.alphaTest ? "#define USE_ALPHATEST" : "",
      t.alphaHash ? "#define USE_ALPHAHASH" : "",
      t.sheen ? "#define USE_SHEEN" : "",
      t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
      t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUv1s ? "#define USE_UV1" : "",
      t.vertexUv2s ? "#define USE_UV2" : "",
      t.vertexUv3s ? "#define USE_UV3" : "",
      t.pointsUvs ? "#define USE_POINTS_UV" : "",
      t.gradientMap ? "#define USE_GRADIENTMAP" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + l : "",
      t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      t.toneMapping !== fi ? "#define TONE_MAPPING" : "",
      t.toneMapping !== fi ? Ve.tonemapping_pars_fragment : "",
      t.toneMapping !== fi ? WM("toneMapping", t.toneMapping) : "",
      t.dithering ? "#define DITHERING" : "",
      t.opaque ? "#define OPAQUE" : "",
      Ve.colorspace_pars_fragment,
      GM("linearToOutputTexel", t.outputColorSpace),
      t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
      `
`
    ].filter(Xr).join(`
`)), o = Ih(o), o = Fd(o, t), o = Bd(o, t), a = Ih(a), a = Fd(a, t), a = Bd(a, t), o = kd(o), a = kd(a), t.isRawShaderMaterial !== true && (_ = `#version 300 es
`, g = [
      f,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join(`
`) + `
` + g, p = [
      "#define varying in",
      t.glslVersion === Rh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      t.glslVersion === Rh ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join(`
`) + `
` + p);
    const x = _ + g + o, b = _ + p + a, E = Od(i, i.VERTEX_SHADER, x), S = Od(i, i.FRAGMENT_SHADER, b);
    i.attachShader(v, E), i.attachShader(v, S), t.index0AttributeName !== void 0 ? i.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === true && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v);
    function w(C) {
      if (s.debug.checkShaderErrors) {
        const N = i.getProgramInfoLog(v).trim(), I = i.getShaderInfoLog(E).trim(), D = i.getShaderInfoLog(S).trim();
        let O = true, z = true;
        if (i.getProgramParameter(v, i.LINK_STATUS) === false) if (O = false, typeof s.debug.onShaderError == "function") s.debug.onShaderError(i, v, E, S);
        else {
          const B = zd(i, E, "vertex"), U = zd(i, S, "fragment");
          console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, i.VALIDATE_STATUS) + `

Material Name: ` + C.name + `
Material Type: ` + C.type + `

Program Info Log: ` + N + `
` + B + `
` + U);
        }
        else N !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", N) : (I === "" || D === "") && (z = false);
        z && (C.diagnostics = {
          runnable: O,
          programLog: N,
          vertexShader: {
            log: I,
            prefix: g
          },
          fragmentShader: {
            log: D,
            prefix: p
          }
        });
      }
      i.deleteShader(E), i.deleteShader(S), A = new Ya(i, v), M = qM(i, v);
    }
    let A;
    this.getUniforms = function() {
      return A === void 0 && w(this), A;
    };
    let M;
    this.getAttributes = function() {
      return M === void 0 && w(this), M;
    };
    let y = t.rendererExtensionParallelShaderCompile === false;
    return this.isReady = function() {
      return y === false && (y = i.getProgramParameter(v, BM)), y;
    }, this.destroy = function() {
      n.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0;
    }, this.type = t.shaderType, this.name = t.shaderName, this.id = kM++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = E, this.fragmentShader = S, this;
  }
  let rb = 0;
  class ob {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(e) {
      const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
      return o.has(i) === false && (o.add(i), i.usedTimes++), o.has(r) === false && (o.add(r), r.usedTimes++), this;
    }
    remove(e) {
      const t = this.materialCache.get(e);
      for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
      return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
      const t = this.materialCache;
      let n = t.get(e);
      return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
    }
    _getShaderStage(e) {
      const t = this.shaderCache;
      let n = t.get(e);
      return n === void 0 && (n = new ab(e), t.set(e, n)), n;
    }
  }
  class ab {
    constructor(e) {
      this.id = rb++, this.code = e, this.usedTimes = 0;
    }
  }
  function lb(s, e, t, n, i, r, o) {
    const a = new Sl(), l = new ob(), c = /* @__PURE__ */ new Set(), u = [], d = i.logarithmicDepthBuffer, h = i.vertexTextures;
    let f = i.precision;
    const m = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function v(M) {
      return c.add(M), M === 0 ? "uv" : `uv${M}`;
    }
    function g(M, y, C, N, I) {
      const D = N.fog, O = I.geometry, z = M.isMeshStandardMaterial ? N.environment : null, B = (M.isMeshStandardMaterial ? t : e).get(M.envMap || z), U = B && B.mapping === xr ? B.image.height : null, G = m[M.type];
      M.precision !== null && (f = i.getMaxPrecision(M.precision), f !== M.precision && console.warn("THREE.WebGLProgram.getParameters:", M.precision, "not supported, using", f, "instead."));
      const V = O.morphAttributes.position || O.morphAttributes.normal || O.morphAttributes.color, K = V !== void 0 ? V.length : 0;
      let ce = 0;
      O.morphAttributes.position !== void 0 && (ce = 1), O.morphAttributes.normal !== void 0 && (ce = 2), O.morphAttributes.color !== void 0 && (ce = 3);
      let Te, q, te, de;
      if (G) {
        const it = In[G];
        Te = it.vertexShader, q = it.fragmentShader;
      } else Te = M.vertexShader, q = M.fragmentShader, l.update(M), te = l.getVertexShaderID(M), de = l.getFragmentShaderID(M);
      const oe = s.getRenderTarget(), fe = I.isInstancedMesh === true, be = I.isBatchedMesh === true, F = !!M.map, Le = !!M.matcap, J = !!B, ie = !!M.aoMap, Z = !!M.lightMap, le = !!M.bumpMap, se = !!M.normalMap, ve = !!M.displacementMap, Ce = !!M.emissiveMap, L = !!M.metalnessMap, T = !!M.roughnessMap, W = M.anisotropy > 0, Q = M.clearcoat > 0, ae = M.dispersion > 0, ne = M.iridescence > 0, Ie = M.sheen > 0, ge = M.transmission > 0, me = W && !!M.anisotropyMap, ke = Q && !!M.clearcoatMap, he = Q && !!M.clearcoatNormalMap, Pe = Q && !!M.clearcoatRoughnessMap, Ze = ne && !!M.iridescenceMap, Ne = ne && !!M.iridescenceThicknessMap, we = Ie && !!M.sheenColorMap, Xe = Ie && !!M.sheenRoughnessMap, Je = !!M.specularMap, vt = !!M.specularColorMap, Ye = !!M.specularIntensityMap, k = ge && !!M.transmissionMap, re = ge && !!M.thicknessMap, j = !!M.gradientMap, xe = !!M.alphaMap, Me = M.alphaTest > 0, je = !!M.alphaHash, ct = !!M.extensions;
      let ft = fi;
      M.toneMapped && (oe === null || oe.isXRRenderTarget === true) && (ft = s.toneMapping);
      const Dt = {
        shaderID: G,
        shaderType: M.type,
        shaderName: M.name,
        vertexShader: Te,
        fragmentShader: q,
        defines: M.defines,
        customVertexShaderID: te,
        customFragmentShaderID: de,
        isRawShaderMaterial: M.isRawShaderMaterial === true,
        glslVersion: M.glslVersion,
        precision: f,
        batching: be,
        instancing: fe,
        instancingColor: fe && I.instanceColor !== null,
        instancingMorph: fe && I.morphTexture !== null,
        supportsVertexTextures: h,
        outputColorSpace: oe === null ? s.outputColorSpace : oe.isXRRenderTarget === true ? oe.texture.colorSpace : yi,
        alphaToCoverage: !!M.alphaToCoverage,
        map: F,
        matcap: Le,
        envMap: J,
        envMapMode: J && B.mapping,
        envMapCubeUVHeight: U,
        aoMap: ie,
        lightMap: Z,
        bumpMap: le,
        normalMap: se,
        displacementMap: h && ve,
        emissiveMap: Ce,
        normalMapObjectSpace: se && M.normalMapType === Mm,
        normalMapTangentSpace: se && M.normalMapType === Wi,
        metalnessMap: L,
        roughnessMap: T,
        anisotropy: W,
        anisotropyMap: me,
        clearcoat: Q,
        clearcoatMap: ke,
        clearcoatNormalMap: he,
        clearcoatRoughnessMap: Pe,
        dispersion: ae,
        iridescence: ne,
        iridescenceMap: Ze,
        iridescenceThicknessMap: Ne,
        sheen: Ie,
        sheenColorMap: we,
        sheenRoughnessMap: Xe,
        specularMap: Je,
        specularColorMap: vt,
        specularIntensityMap: Ye,
        transmission: ge,
        transmissionMap: k,
        thicknessMap: re,
        gradientMap: j,
        opaque: M.transparent === false && M.blending === bs && M.alphaToCoverage === false,
        alphaMap: xe,
        alphaTest: Me,
        alphaHash: je,
        combine: M.combine,
        mapUv: F && v(M.map.channel),
        aoMapUv: ie && v(M.aoMap.channel),
        lightMapUv: Z && v(M.lightMap.channel),
        bumpMapUv: le && v(M.bumpMap.channel),
        normalMapUv: se && v(M.normalMap.channel),
        displacementMapUv: ve && v(M.displacementMap.channel),
        emissiveMapUv: Ce && v(M.emissiveMap.channel),
        metalnessMapUv: L && v(M.metalnessMap.channel),
        roughnessMapUv: T && v(M.roughnessMap.channel),
        anisotropyMapUv: me && v(M.anisotropyMap.channel),
        clearcoatMapUv: ke && v(M.clearcoatMap.channel),
        clearcoatNormalMapUv: he && v(M.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: Pe && v(M.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Ze && v(M.iridescenceMap.channel),
        iridescenceThicknessMapUv: Ne && v(M.iridescenceThicknessMap.channel),
        sheenColorMapUv: we && v(M.sheenColorMap.channel),
        sheenRoughnessMapUv: Xe && v(M.sheenRoughnessMap.channel),
        specularMapUv: Je && v(M.specularMap.channel),
        specularColorMapUv: vt && v(M.specularColorMap.channel),
        specularIntensityMapUv: Ye && v(M.specularIntensityMap.channel),
        transmissionMapUv: k && v(M.transmissionMap.channel),
        thicknessMapUv: re && v(M.thicknessMap.channel),
        alphaMapUv: xe && v(M.alphaMap.channel),
        vertexTangents: !!O.attributes.tangent && (se || W),
        vertexColors: M.vertexColors,
        vertexAlphas: M.vertexColors === true && !!O.attributes.color && O.attributes.color.itemSize === 4,
        pointsUvs: I.isPoints === true && !!O.attributes.uv && (F || xe),
        fog: !!D,
        useFog: M.fog === true,
        fogExp2: !!D && D.isFogExp2,
        flatShading: M.flatShading === true,
        sizeAttenuation: M.sizeAttenuation === true,
        logarithmicDepthBuffer: d,
        skinning: I.isSkinnedMesh === true,
        morphTargets: O.morphAttributes.position !== void 0,
        morphNormals: O.morphAttributes.normal !== void 0,
        morphColors: O.morphAttributes.color !== void 0,
        morphTargetsCount: K,
        morphTextureStride: ce,
        numDirLights: y.directional.length,
        numPointLights: y.point.length,
        numSpotLights: y.spot.length,
        numSpotLightMaps: y.spotLightMap.length,
        numRectAreaLights: y.rectArea.length,
        numHemiLights: y.hemi.length,
        numDirLightShadows: y.directionalShadowMap.length,
        numPointLightShadows: y.pointShadowMap.length,
        numSpotLightShadows: y.spotShadowMap.length,
        numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps,
        numLightProbes: y.numLightProbes,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: M.dithering,
        shadowMapEnabled: s.shadowMap.enabled && C.length > 0,
        shadowMapType: s.shadowMap.type,
        toneMapping: ft,
        useLegacyLights: s._useLegacyLights,
        decodeVideoTexture: F && M.map.isVideoTexture === true && st.getTransfer(M.map.colorSpace) === lt,
        premultipliedAlpha: M.premultipliedAlpha,
        doubleSided: M.side === Qt,
        flipSided: M.side === Zt,
        useDepthPacking: M.depthPacking >= 0,
        depthPacking: M.depthPacking || 0,
        index0AttributeName: M.index0AttributeName,
        extensionClipCullDistance: ct && M.extensions.clipCullDistance === true && n.has("WEBGL_clip_cull_distance"),
        extensionMultiDraw: ct && M.extensions.multiDraw === true && n.has("WEBGL_multi_draw"),
        rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
        customProgramCacheKey: M.customProgramCacheKey()
      };
      return Dt.vertexUv1s = c.has(1), Dt.vertexUv2s = c.has(2), Dt.vertexUv3s = c.has(3), c.clear(), Dt;
    }
    function p(M) {
      const y = [];
      if (M.shaderID ? y.push(M.shaderID) : (y.push(M.customVertexShaderID), y.push(M.customFragmentShaderID)), M.defines !== void 0) for (const C in M.defines) y.push(C), y.push(M.defines[C]);
      return M.isRawShaderMaterial === false && (_(y, M), x(y, M), y.push(s.outputColorSpace)), y.push(M.customProgramCacheKey), y.join();
    }
    function _(M, y) {
      M.push(y.precision), M.push(y.outputColorSpace), M.push(y.envMapMode), M.push(y.envMapCubeUVHeight), M.push(y.mapUv), M.push(y.alphaMapUv), M.push(y.lightMapUv), M.push(y.aoMapUv), M.push(y.bumpMapUv), M.push(y.normalMapUv), M.push(y.displacementMapUv), M.push(y.emissiveMapUv), M.push(y.metalnessMapUv), M.push(y.roughnessMapUv), M.push(y.anisotropyMapUv), M.push(y.clearcoatMapUv), M.push(y.clearcoatNormalMapUv), M.push(y.clearcoatRoughnessMapUv), M.push(y.iridescenceMapUv), M.push(y.iridescenceThicknessMapUv), M.push(y.sheenColorMapUv), M.push(y.sheenRoughnessMapUv), M.push(y.specularMapUv), M.push(y.specularColorMapUv), M.push(y.specularIntensityMapUv), M.push(y.transmissionMapUv), M.push(y.thicknessMapUv), M.push(y.combine), M.push(y.fogExp2), M.push(y.sizeAttenuation), M.push(y.morphTargetsCount), M.push(y.morphAttributeCount), M.push(y.numDirLights), M.push(y.numPointLights), M.push(y.numSpotLights), M.push(y.numSpotLightMaps), M.push(y.numHemiLights), M.push(y.numRectAreaLights), M.push(y.numDirLightShadows), M.push(y.numPointLightShadows), M.push(y.numSpotLightShadows), M.push(y.numSpotLightShadowsWithMaps), M.push(y.numLightProbes), M.push(y.shadowMapType), M.push(y.toneMapping), M.push(y.numClippingPlanes), M.push(y.numClipIntersection), M.push(y.depthPacking);
    }
    function x(M, y) {
      a.disableAll(), y.supportsVertexTextures && a.enable(0), y.instancing && a.enable(1), y.instancingColor && a.enable(2), y.instancingMorph && a.enable(3), y.matcap && a.enable(4), y.envMap && a.enable(5), y.normalMapObjectSpace && a.enable(6), y.normalMapTangentSpace && a.enable(7), y.clearcoat && a.enable(8), y.iridescence && a.enable(9), y.alphaTest && a.enable(10), y.vertexColors && a.enable(11), y.vertexAlphas && a.enable(12), y.vertexUv1s && a.enable(13), y.vertexUv2s && a.enable(14), y.vertexUv3s && a.enable(15), y.vertexTangents && a.enable(16), y.anisotropy && a.enable(17), y.alphaHash && a.enable(18), y.batching && a.enable(19), y.dispersion && a.enable(20), M.push(a.mask), a.disableAll(), y.fog && a.enable(0), y.useFog && a.enable(1), y.flatShading && a.enable(2), y.logarithmicDepthBuffer && a.enable(3), y.skinning && a.enable(4), y.morphTargets && a.enable(5), y.morphNormals && a.enable(6), y.morphColors && a.enable(7), y.premultipliedAlpha && a.enable(8), y.shadowMapEnabled && a.enable(9), y.useLegacyLights && a.enable(10), y.doubleSided && a.enable(11), y.flipSided && a.enable(12), y.useDepthPacking && a.enable(13), y.dithering && a.enable(14), y.transmission && a.enable(15), y.sheen && a.enable(16), y.opaque && a.enable(17), y.pointsUvs && a.enable(18), y.decodeVideoTexture && a.enable(19), y.alphaToCoverage && a.enable(20), M.push(a.mask);
    }
    function b(M) {
      const y = m[M.type];
      let C;
      if (y) {
        const N = In[y];
        C = Om.clone(N.uniforms);
      } else C = M.uniforms;
      return C;
    }
    function E(M, y) {
      let C;
      for (let N = 0, I = u.length; N < I; N++) {
        const D = u[N];
        if (D.cacheKey === y) {
          C = D, ++C.usedTimes;
          break;
        }
      }
      return C === void 0 && (C = new sb(s, y, M, r), u.push(C)), C;
    }
    function S(M) {
      if (--M.usedTimes === 0) {
        const y = u.indexOf(M);
        u[y] = u[u.length - 1], u.pop(), M.destroy();
      }
    }
    function w(M) {
      l.remove(M);
    }
    function A() {
      l.dispose();
    }
    return {
      getParameters: g,
      getProgramCacheKey: p,
      getUniforms: b,
      acquireProgram: E,
      releaseProgram: S,
      releaseShaderCache: w,
      programs: u,
      dispose: A
    };
  }
  function cb() {
    let s = /* @__PURE__ */ new WeakMap();
    function e(r) {
      let o = s.get(r);
      return o === void 0 && (o = {}, s.set(r, o)), o;
    }
    function t(r) {
      s.delete(r);
    }
    function n(r, o, a) {
      s.get(r)[o] = a;
    }
    function i() {
      s = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: e,
      remove: t,
      update: n,
      dispose: i
    };
  }
  function hb(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
  }
  function Hd(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
  }
  function Gd() {
    const s = [];
    let e = 0;
    const t = [], n = [], i = [];
    function r() {
      e = 0, t.length = 0, n.length = 0, i.length = 0;
    }
    function o(d, h, f, m, v, g) {
      let p = s[e];
      return p === void 0 ? (p = {
        id: d.id,
        object: d,
        geometry: h,
        material: f,
        groupOrder: m,
        renderOrder: d.renderOrder,
        z: v,
        group: g
      }, s[e] = p) : (p.id = d.id, p.object = d, p.geometry = h, p.material = f, p.groupOrder = m, p.renderOrder = d.renderOrder, p.z = v, p.group = g), e++, p;
    }
    function a(d, h, f, m, v, g) {
      const p = o(d, h, f, m, v, g);
      f.transmission > 0 ? n.push(p) : f.transparent === true ? i.push(p) : t.push(p);
    }
    function l(d, h, f, m, v, g) {
      const p = o(d, h, f, m, v, g);
      f.transmission > 0 ? n.unshift(p) : f.transparent === true ? i.unshift(p) : t.unshift(p);
    }
    function c(d, h) {
      t.length > 1 && t.sort(d || hb), n.length > 1 && n.sort(h || Hd), i.length > 1 && i.sort(h || Hd);
    }
    function u() {
      for (let d = e, h = s.length; d < h; d++) {
        const f = s[d];
        if (f.id === null) break;
        f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
      }
    }
    return {
      opaque: t,
      transmissive: n,
      transparent: i,
      init: r,
      push: a,
      unshift: l,
      finish: u,
      sort: c
    };
  }
  function ub() {
    let s = /* @__PURE__ */ new WeakMap();
    function e(n, i) {
      const r = s.get(n);
      let o;
      return r === void 0 ? (o = new Gd(), s.set(n, [
        o
      ])) : i >= r.length ? (o = new Gd(), r.push(o)) : o = r[i], o;
    }
    function t() {
      s = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: e,
      dispose: t
    };
  }
  function db() {
    const s = {};
    return {
      get: function(e) {
        if (s[e.id] !== void 0) return s[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              direction: new P(),
              color: new ye()
            };
            break;
          case "SpotLight":
            t = {
              position: new P(),
              direction: new P(),
              color: new ye(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            t = {
              position: new P(),
              color: new ye(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            t = {
              direction: new P(),
              skyColor: new ye(),
              groundColor: new ye()
            };
            break;
          case "RectAreaLight":
            t = {
              color: new ye(),
              position: new P(),
              halfWidth: new P(),
              halfHeight: new P()
            };
            break;
        }
        return s[e.id] = t, t;
      }
    };
  }
  function fb() {
    const s = {};
    return {
      get: function(e) {
        if (s[e.id] !== void 0) return s[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new ee()
            };
            break;
          case "SpotLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new ee()
            };
            break;
          case "PointLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new ee(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        return s[e.id] = t, t;
      }
    };
  }
  let pb = 0;
  function mb(s, e) {
    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
  }
  function gb(s) {
    const e = new db(), t = fb(), n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1
      },
      ambient: [
        0,
        0,
        0
      ],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0
    };
    for (let c = 0; c < 9; c++) n.probe.push(new P());
    const i = new P(), r = new De(), o = new De();
    function a(c, u) {
      let d = 0, h = 0, f = 0;
      for (let C = 0; C < 9; C++) n.probe[C].set(0, 0, 0);
      let m = 0, v = 0, g = 0, p = 0, _ = 0, x = 0, b = 0, E = 0, S = 0, w = 0, A = 0;
      c.sort(mb);
      const M = u === true ? Math.PI : 1;
      for (let C = 0, N = c.length; C < N; C++) {
        const I = c[C], D = I.color, O = I.intensity, z = I.distance, B = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
        if (I.isAmbientLight) d += D.r * O * M, h += D.g * O * M, f += D.b * O * M;
        else if (I.isLightProbe) {
          for (let U = 0; U < 9; U++) n.probe[U].addScaledVector(I.sh.coefficients[U], O);
          A++;
        } else if (I.isDirectionalLight) {
          const U = e.get(I);
          if (U.color.copy(I.color).multiplyScalar(I.intensity * M), I.castShadow) {
            const G = I.shadow, V = t.get(I);
            V.shadowBias = G.bias, V.shadowNormalBias = G.normalBias, V.shadowRadius = G.radius, V.shadowMapSize = G.mapSize, n.directionalShadow[m] = V, n.directionalShadowMap[m] = B, n.directionalShadowMatrix[m] = I.shadow.matrix, x++;
          }
          n.directional[m] = U, m++;
        } else if (I.isSpotLight) {
          const U = e.get(I);
          U.position.setFromMatrixPosition(I.matrixWorld), U.color.copy(D).multiplyScalar(O * M), U.distance = z, U.coneCos = Math.cos(I.angle), U.penumbraCos = Math.cos(I.angle * (1 - I.penumbra)), U.decay = I.decay, n.spot[g] = U;
          const G = I.shadow;
          if (I.map && (n.spotLightMap[S] = I.map, S++, G.updateMatrices(I), I.castShadow && w++), n.spotLightMatrix[g] = G.matrix, I.castShadow) {
            const V = t.get(I);
            V.shadowBias = G.bias, V.shadowNormalBias = G.normalBias, V.shadowRadius = G.radius, V.shadowMapSize = G.mapSize, n.spotShadow[g] = V, n.spotShadowMap[g] = B, E++;
          }
          g++;
        } else if (I.isRectAreaLight) {
          const U = e.get(I);
          U.color.copy(D).multiplyScalar(O), U.halfWidth.set(I.width * 0.5, 0, 0), U.halfHeight.set(0, I.height * 0.5, 0), n.rectArea[p] = U, p++;
        } else if (I.isPointLight) {
          const U = e.get(I);
          if (U.color.copy(I.color).multiplyScalar(I.intensity * M), U.distance = I.distance, U.decay = I.decay, I.castShadow) {
            const G = I.shadow, V = t.get(I);
            V.shadowBias = G.bias, V.shadowNormalBias = G.normalBias, V.shadowRadius = G.radius, V.shadowMapSize = G.mapSize, V.shadowCameraNear = G.camera.near, V.shadowCameraFar = G.camera.far, n.pointShadow[v] = V, n.pointShadowMap[v] = B, n.pointShadowMatrix[v] = I.shadow.matrix, b++;
          }
          n.point[v] = U, v++;
        } else if (I.isHemisphereLight) {
          const U = e.get(I);
          U.skyColor.copy(I.color).multiplyScalar(O * M), U.groundColor.copy(I.groundColor).multiplyScalar(O * M), n.hemi[_] = U, _++;
        }
      }
      p > 0 && (s.has("OES_texture_float_linear") === true ? (n.rectAreaLTC1 = pe.LTC_FLOAT_1, n.rectAreaLTC2 = pe.LTC_FLOAT_2) : (n.rectAreaLTC1 = pe.LTC_HALF_1, n.rectAreaLTC2 = pe.LTC_HALF_2)), n.ambient[0] = d, n.ambient[1] = h, n.ambient[2] = f;
      const y = n.hash;
      (y.directionalLength !== m || y.pointLength !== v || y.spotLength !== g || y.rectAreaLength !== p || y.hemiLength !== _ || y.numDirectionalShadows !== x || y.numPointShadows !== b || y.numSpotShadows !== E || y.numSpotMaps !== S || y.numLightProbes !== A) && (n.directional.length = m, n.spot.length = g, n.rectArea.length = p, n.point.length = v, n.hemi.length = _, n.directionalShadow.length = x, n.directionalShadowMap.length = x, n.pointShadow.length = b, n.pointShadowMap.length = b, n.spotShadow.length = E, n.spotShadowMap.length = E, n.directionalShadowMatrix.length = x, n.pointShadowMatrix.length = b, n.spotLightMatrix.length = E + S - w, n.spotLightMap.length = S, n.numSpotLightShadowsWithMaps = w, n.numLightProbes = A, y.directionalLength = m, y.pointLength = v, y.spotLength = g, y.rectAreaLength = p, y.hemiLength = _, y.numDirectionalShadows = x, y.numPointShadows = b, y.numSpotShadows = E, y.numSpotMaps = S, y.numLightProbes = A, n.version = pb++);
    }
    function l(c, u) {
      let d = 0, h = 0, f = 0, m = 0, v = 0;
      const g = u.matrixWorldInverse;
      for (let p = 0, _ = c.length; p < _; p++) {
        const x = c[p];
        if (x.isDirectionalLight) {
          const b = n.directional[d];
          b.direction.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(i), b.direction.transformDirection(g), d++;
        } else if (x.isSpotLight) {
          const b = n.spot[f];
          b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(g), b.direction.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(x.target.matrixWorld), b.direction.sub(i), b.direction.transformDirection(g), f++;
        } else if (x.isRectAreaLight) {
          const b = n.rectArea[m];
          b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(g), o.identity(), r.copy(x.matrixWorld), r.premultiply(g), o.extractRotation(r), b.halfWidth.set(x.width * 0.5, 0, 0), b.halfHeight.set(0, x.height * 0.5, 0), b.halfWidth.applyMatrix4(o), b.halfHeight.applyMatrix4(o), m++;
        } else if (x.isPointLight) {
          const b = n.point[h];
          b.position.setFromMatrixPosition(x.matrixWorld), b.position.applyMatrix4(g), h++;
        } else if (x.isHemisphereLight) {
          const b = n.hemi[v];
          b.direction.setFromMatrixPosition(x.matrixWorld), b.direction.transformDirection(g), v++;
        }
      }
    }
    return {
      setup: a,
      setupView: l,
      state: n
    };
  }
  function Wd(s) {
    const e = new gb(s), t = [], n = [];
    function i(u) {
      c.camera = u, t.length = 0, n.length = 0;
    }
    function r(u) {
      t.push(u);
    }
    function o(u) {
      n.push(u);
    }
    function a(u) {
      e.setup(t, u);
    }
    function l(u) {
      e.setupView(t, u);
    }
    const c = {
      lightsArray: t,
      shadowsArray: n,
      camera: null,
      lights: e,
      transmissionRenderTarget: {}
    };
    return {
      init: i,
      state: c,
      setupLights: a,
      setupLightsView: l,
      pushLight: r,
      pushShadow: o
    };
  }
  function vb(s) {
    let e = /* @__PURE__ */ new WeakMap();
    function t(i, r = 0) {
      const o = e.get(i);
      let a;
      return o === void 0 ? (a = new Wd(s), e.set(i, [
        a
      ])) : r >= o.length ? (a = new Wd(s), o.push(a)) : a = o[r], a;
    }
    function n() {
      e = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: t,
      dispose: n
    };
  }
  class gu extends Ht {
    constructor(e) {
      super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = _m, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
    }
  }
  class vu extends Ht {
    constructor(e) {
      super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
    }
  }
  const xb = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, _b = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
  function yb(s, e, t) {
    let n = new Oo();
    const i = new ee(), r = new ee(), o = new rt(), a = new gu({
      depthPacking: ym
    }), l = new vu(), c = {}, u = t.maxTextureSize, d = {
      [mi]: Zt,
      [Zt]: mi,
      [Qt]: Qt
    }, h = new Fn({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: {
          value: null
        },
        resolution: {
          value: new ee()
        },
        radius: {
          value: 4
        }
      },
      vertexShader: xb,
      fragmentShader: _b
    }), f = h.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const m = new We();
    m.setAttribute("position", new at(new Float32Array([
      -1,
      -1,
      0.5,
      3,
      -1,
      0.5,
      -1,
      3,
      0.5
    ]), 3));
    const v = new ht(m, h), g = this;
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = Io;
    let p = this.type;
    this.render = function(S, w, A) {
      if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || S.length === 0) return;
      const M = s.getRenderTarget(), y = s.getActiveCubeFace(), C = s.getActiveMipmapLevel(), N = s.state;
      N.setBlending(di), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(true), N.setScissorTest(false);
      const I = p !== Gn && this.type === Gn, D = p === Gn && this.type !== Gn;
      for (let O = 0, z = S.length; O < z; O++) {
        const B = S[O], U = B.shadow;
        if (U === void 0) {
          console.warn("THREE.WebGLShadowMap:", B, "has no shadow.");
          continue;
        }
        if (U.autoUpdate === false && U.needsUpdate === false) continue;
        i.copy(U.mapSize);
        const G = U.getFrameExtents();
        if (i.multiply(G), r.copy(U.mapSize), (i.x > u || i.y > u) && (i.x > u && (r.x = Math.floor(u / G.x), i.x = r.x * G.x, U.mapSize.x = r.x), i.y > u && (r.y = Math.floor(u / G.y), i.y = r.y * G.y, U.mapSize.y = r.y)), U.map === null || I === true || D === true) {
          const K = this.type !== Gn ? {
            minFilter: At,
            magFilter: At
          } : {};
          U.map !== null && U.map.dispose(), U.map = new zn(i.x, i.y, K), U.map.texture.name = B.name + ".shadowMap", U.camera.updateProjectionMatrix();
        }
        s.setRenderTarget(U.map), s.clear();
        const V = U.getViewportCount();
        for (let K = 0; K < V; K++) {
          const ce = U.getViewport(K);
          o.set(r.x * ce.x, r.y * ce.y, r.x * ce.z, r.y * ce.w), N.viewport(o), U.updateMatrices(B, K), n = U.getFrustum(), b(w, A, U.camera, B, this.type);
        }
        U.isPointLightShadow !== true && this.type === Gn && _(U, A), U.needsUpdate = false;
      }
      p = this.type, g.needsUpdate = false, s.setRenderTarget(M, y, C);
    };
    function _(S, w) {
      const A = e.update(v);
      h.defines.VSM_SAMPLES !== S.blurSamples && (h.defines.VSM_SAMPLES = S.blurSamples, f.defines.VSM_SAMPLES = S.blurSamples, h.needsUpdate = true, f.needsUpdate = true), S.mapPass === null && (S.mapPass = new zn(i.x, i.y)), h.uniforms.shadow_pass.value = S.map.texture, h.uniforms.resolution.value = S.mapSize, h.uniforms.radius.value = S.radius, s.setRenderTarget(S.mapPass), s.clear(), s.renderBufferDirect(w, null, A, h, v, null), f.uniforms.shadow_pass.value = S.mapPass.texture, f.uniforms.resolution.value = S.mapSize, f.uniforms.radius.value = S.radius, s.setRenderTarget(S.map), s.clear(), s.renderBufferDirect(w, null, A, f, v, null);
    }
    function x(S, w, A, M) {
      let y = null;
      const C = A.isPointLight === true ? S.customDistanceMaterial : S.customDepthMaterial;
      if (C !== void 0) y = C;
      else if (y = A.isPointLight === true ? l : a, s.localClippingEnabled && w.clipShadows === true && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
        const N = y.uuid, I = w.uuid;
        let D = c[N];
        D === void 0 && (D = {}, c[N] = D);
        let O = D[I];
        O === void 0 && (O = y.clone(), D[I] = O, w.addEventListener("dispose", E)), y = O;
      }
      if (y.visible = w.visible, y.wireframe = w.wireframe, M === Gn ? y.side = w.shadowSide !== null ? w.shadowSide : w.side : y.side = w.shadowSide !== null ? w.shadowSide : d[w.side], y.alphaMap = w.alphaMap, y.alphaTest = w.alphaTest, y.map = w.map, y.clipShadows = w.clipShadows, y.clippingPlanes = w.clippingPlanes, y.clipIntersection = w.clipIntersection, y.displacementMap = w.displacementMap, y.displacementScale = w.displacementScale, y.displacementBias = w.displacementBias, y.wireframeLinewidth = w.wireframeLinewidth, y.linewidth = w.linewidth, A.isPointLight === true && y.isMeshDistanceMaterial === true) {
        const N = s.properties.get(y);
        N.light = A;
      }
      return y;
    }
    function b(S, w, A, M, y) {
      if (S.visible === false) return;
      if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && y === Gn) && (!S.frustumCulled || n.intersectsObject(S))) {
        S.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, S.matrixWorld);
        const I = e.update(S), D = S.material;
        if (Array.isArray(D)) {
          const O = I.groups;
          for (let z = 0, B = O.length; z < B; z++) {
            const U = O[z], G = D[U.materialIndex];
            if (G && G.visible) {
              const V = x(S, G, M, y);
              S.onBeforeShadow(s, S, w, A, I, V, U), s.renderBufferDirect(A, null, I, V, S, U), S.onAfterShadow(s, S, w, A, I, V, U);
            }
          }
        } else if (D.visible) {
          const O = x(S, D, M, y);
          S.onBeforeShadow(s, S, w, A, I, O, null), s.renderBufferDirect(A, null, I, O, S, null), S.onAfterShadow(s, S, w, A, I, O, null);
        }
      }
      const N = S.children;
      for (let I = 0, D = N.length; I < D; I++) b(N[I], w, A, M, y);
    }
    function E(S) {
      S.target.removeEventListener("dispose", E);
      for (const A in c) {
        const M = c[A], y = S.target.uuid;
        y in M && (M[y].dispose(), delete M[y]);
      }
    }
  }
  function Mb(s) {
    function e() {
      let k = false;
      const re = new rt();
      let j = null;
      const xe = new rt(0, 0, 0, 0);
      return {
        setMask: function(Me) {
          j !== Me && !k && (s.colorMask(Me, Me, Me, Me), j = Me);
        },
        setLocked: function(Me) {
          k = Me;
        },
        setClear: function(Me, je, ct, ft, Dt) {
          Dt === true && (Me *= ft, je *= ft, ct *= ft), re.set(Me, je, ct, ft), xe.equals(re) === false && (s.clearColor(Me, je, ct, ft), xe.copy(re));
        },
        reset: function() {
          k = false, j = null, xe.set(-1, 0, 0, 0);
        }
      };
    }
    function t() {
      let k = false, re = null, j = null, xe = null;
      return {
        setTest: function(Me) {
          Me ? de(s.DEPTH_TEST) : oe(s.DEPTH_TEST);
        },
        setMask: function(Me) {
          re !== Me && !k && (s.depthMask(Me), re = Me);
        },
        setFunc: function(Me) {
          if (j !== Me) {
            switch (Me) {
              case Wp:
                s.depthFunc(s.NEVER);
                break;
              case Xp:
                s.depthFunc(s.ALWAYS);
                break;
              case Yp:
                s.depthFunc(s.LESS);
                break;
              case no:
                s.depthFunc(s.LEQUAL);
                break;
              case qp:
                s.depthFunc(s.EQUAL);
                break;
              case $p:
                s.depthFunc(s.GEQUAL);
                break;
              case Zp:
                s.depthFunc(s.GREATER);
                break;
              case Jp:
                s.depthFunc(s.NOTEQUAL);
                break;
              default:
                s.depthFunc(s.LEQUAL);
            }
            j = Me;
          }
        },
        setLocked: function(Me) {
          k = Me;
        },
        setClear: function(Me) {
          xe !== Me && (s.clearDepth(Me), xe = Me);
        },
        reset: function() {
          k = false, re = null, j = null, xe = null;
        }
      };
    }
    function n() {
      let k = false, re = null, j = null, xe = null, Me = null, je = null, ct = null, ft = null, Dt = null;
      return {
        setTest: function(it) {
          k || (it ? de(s.STENCIL_TEST) : oe(s.STENCIL_TEST));
        },
        setMask: function(it) {
          re !== it && !k && (s.stencilMask(it), re = it);
        },
        setFunc: function(it, Hn, Gt) {
          (j !== it || xe !== Hn || Me !== Gt) && (s.stencilFunc(it, Hn, Gt), j = it, xe = Hn, Me = Gt);
        },
        setOp: function(it, Hn, Gt) {
          (je !== it || ct !== Hn || ft !== Gt) && (s.stencilOp(it, Hn, Gt), je = it, ct = Hn, ft = Gt);
        },
        setLocked: function(it) {
          k = it;
        },
        setClear: function(it) {
          Dt !== it && (s.clearStencil(it), Dt = it);
        },
        reset: function() {
          k = false, re = null, j = null, xe = null, Me = null, je = null, ct = null, ft = null, Dt = null;
        }
      };
    }
    const i = new e(), r = new t(), o = new n(), a = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
    let c = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), h = [], f = null, m = false, v = null, g = null, p = null, _ = null, x = null, b = null, E = null, S = new ye(0, 0, 0), w = 0, A = false, M = null, y = null, C = null, N = null, I = null;
    const D = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let O = false, z = 0;
    const B = s.getParameter(s.VERSION);
    B.indexOf("WebGL") !== -1 ? (z = parseFloat(/^WebGL (\d)/.exec(B)[1]), O = z >= 1) : B.indexOf("OpenGL ES") !== -1 && (z = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), O = z >= 2);
    let U = null, G = {};
    const V = s.getParameter(s.SCISSOR_BOX), K = s.getParameter(s.VIEWPORT), ce = new rt().fromArray(V), Te = new rt().fromArray(K);
    function q(k, re, j, xe) {
      const Me = new Uint8Array(4), je = s.createTexture();
      s.bindTexture(k, je), s.texParameteri(k, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(k, s.TEXTURE_MAG_FILTER, s.NEAREST);
      for (let ct = 0; ct < j; ct++) k === s.TEXTURE_3D || k === s.TEXTURE_2D_ARRAY ? s.texImage3D(re, 0, s.RGBA, 1, 1, xe, 0, s.RGBA, s.UNSIGNED_BYTE, Me) : s.texImage2D(re + ct, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, Me);
      return je;
    }
    const te = {};
    te[s.TEXTURE_2D] = q(s.TEXTURE_2D, s.TEXTURE_2D, 1), te[s.TEXTURE_CUBE_MAP] = q(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), te[s.TEXTURE_2D_ARRAY] = q(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), te[s.TEXTURE_3D] = q(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), de(s.DEPTH_TEST), r.setFunc(no), le(false), se(Kc), de(s.CULL_FACE), ie(di);
    function de(k) {
      c[k] !== true && (s.enable(k), c[k] = true);
    }
    function oe(k) {
      c[k] !== false && (s.disable(k), c[k] = false);
    }
    function fe(k, re) {
      return u[k] !== re ? (s.bindFramebuffer(k, re), u[k] = re, k === s.DRAW_FRAMEBUFFER && (u[s.FRAMEBUFFER] = re), k === s.FRAMEBUFFER && (u[s.DRAW_FRAMEBUFFER] = re), true) : false;
    }
    function be(k, re) {
      let j = h, xe = false;
      if (k) {
        j = d.get(re), j === void 0 && (j = [], d.set(re, j));
        const Me = k.textures;
        if (j.length !== Me.length || j[0] !== s.COLOR_ATTACHMENT0) {
          for (let je = 0, ct = Me.length; je < ct; je++) j[je] = s.COLOR_ATTACHMENT0 + je;
          j.length = Me.length, xe = true;
        }
      } else j[0] !== s.BACK && (j[0] = s.BACK, xe = true);
      xe && s.drawBuffers(j);
    }
    function F(k) {
      return f !== k ? (s.useProgram(k), f = k, true) : false;
    }
    const Le = {
      [Di]: s.FUNC_ADD,
      [Ap]: s.FUNC_SUBTRACT,
      [Cp]: s.FUNC_REVERSE_SUBTRACT
    };
    Le[Rp] = s.MIN, Le[Pp] = s.MAX;
    const J = {
      [Ip]: s.ZERO,
      [Lp]: s.ONE,
      [Dp]: s.SRC_COLOR,
      [qa]: s.SRC_ALPHA,
      [Bp]: s.SRC_ALPHA_SATURATE,
      [zp]: s.DST_COLOR,
      [Up]: s.DST_ALPHA,
      [Np]: s.ONE_MINUS_SRC_COLOR,
      [$a]: s.ONE_MINUS_SRC_ALPHA,
      [Fp]: s.ONE_MINUS_DST_COLOR,
      [Op]: s.ONE_MINUS_DST_ALPHA,
      [kp]: s.CONSTANT_COLOR,
      [Vp]: s.ONE_MINUS_CONSTANT_COLOR,
      [Hp]: s.CONSTANT_ALPHA,
      [Gp]: s.ONE_MINUS_CONSTANT_ALPHA
    };
    function ie(k, re, j, xe, Me, je, ct, ft, Dt, it) {
      if (k === di) {
        m === true && (oe(s.BLEND), m = false);
        return;
      }
      if (m === false && (de(s.BLEND), m = true), k !== Ep) {
        if (k !== v || it !== A) {
          if ((g !== Di || x !== Di) && (s.blendEquation(s.FUNC_ADD), g = Di, x = Di), it) switch (k) {
            case bs:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case jc:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case Qc:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case eh:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
          else switch (k) {
            case bs:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case jc:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case Qc:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case eh:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
          p = null, _ = null, b = null, E = null, S.set(0, 0, 0), w = 0, v = k, A = it;
        }
        return;
      }
      Me = Me || re, je = je || j, ct = ct || xe, (re !== g || Me !== x) && (s.blendEquationSeparate(Le[re], Le[Me]), g = re, x = Me), (j !== p || xe !== _ || je !== b || ct !== E) && (s.blendFuncSeparate(J[j], J[xe], J[je], J[ct]), p = j, _ = xe, b = je, E = ct), (ft.equals(S) === false || Dt !== w) && (s.blendColor(ft.r, ft.g, ft.b, Dt), S.copy(ft), w = Dt), v = k, A = false;
    }
    function Z(k, re) {
      k.side === Qt ? oe(s.CULL_FACE) : de(s.CULL_FACE);
      let j = k.side === Zt;
      re && (j = !j), le(j), k.blending === bs && k.transparent === false ? ie(di) : ie(k.blending, k.blendEquation, k.blendSrc, k.blendDst, k.blendEquationAlpha, k.blendSrcAlpha, k.blendDstAlpha, k.blendColor, k.blendAlpha, k.premultipliedAlpha), r.setFunc(k.depthFunc), r.setTest(k.depthTest), r.setMask(k.depthWrite), i.setMask(k.colorWrite);
      const xe = k.stencilWrite;
      o.setTest(xe), xe && (o.setMask(k.stencilWriteMask), o.setFunc(k.stencilFunc, k.stencilRef, k.stencilFuncMask), o.setOp(k.stencilFail, k.stencilZFail, k.stencilZPass)), Ce(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits), k.alphaToCoverage === true ? de(s.SAMPLE_ALPHA_TO_COVERAGE) : oe(s.SAMPLE_ALPHA_TO_COVERAGE);
    }
    function le(k) {
      M !== k && (k ? s.frontFace(s.CW) : s.frontFace(s.CCW), M = k);
    }
    function se(k) {
      k !== wp ? (de(s.CULL_FACE), k !== y && (k === Kc ? s.cullFace(s.BACK) : k === Tp ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : oe(s.CULL_FACE), y = k;
    }
    function ve(k) {
      k !== C && (O && s.lineWidth(k), C = k);
    }
    function Ce(k, re, j) {
      k ? (de(s.POLYGON_OFFSET_FILL), (N !== re || I !== j) && (s.polygonOffset(re, j), N = re, I = j)) : oe(s.POLYGON_OFFSET_FILL);
    }
    function L(k) {
      k ? de(s.SCISSOR_TEST) : oe(s.SCISSOR_TEST);
    }
    function T(k) {
      k === void 0 && (k = s.TEXTURE0 + D - 1), U !== k && (s.activeTexture(k), U = k);
    }
    function W(k, re, j) {
      j === void 0 && (U === null ? j = s.TEXTURE0 + D - 1 : j = U);
      let xe = G[j];
      xe === void 0 && (xe = {
        type: void 0,
        texture: void 0
      }, G[j] = xe), (xe.type !== k || xe.texture !== re) && (U !== j && (s.activeTexture(j), U = j), s.bindTexture(k, re || te[k]), xe.type = k, xe.texture = re);
    }
    function Q() {
      const k = G[U];
      k !== void 0 && k.type !== void 0 && (s.bindTexture(k.type, null), k.type = void 0, k.texture = void 0);
    }
    function ae() {
      try {
        s.compressedTexImage2D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function ne() {
      try {
        s.compressedTexImage3D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function Ie() {
      try {
        s.texSubImage2D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function ge() {
      try {
        s.texSubImage3D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function me() {
      try {
        s.compressedTexSubImage2D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function ke() {
      try {
        s.compressedTexSubImage3D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function he() {
      try {
        s.texStorage2D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function Pe() {
      try {
        s.texStorage3D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function Ze() {
      try {
        s.texImage2D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function Ne() {
      try {
        s.texImage3D.apply(s, arguments);
      } catch (k) {
        console.error("THREE.WebGLState:", k);
      }
    }
    function we(k) {
      ce.equals(k) === false && (s.scissor(k.x, k.y, k.z, k.w), ce.copy(k));
    }
    function Xe(k) {
      Te.equals(k) === false && (s.viewport(k.x, k.y, k.z, k.w), Te.copy(k));
    }
    function Je(k, re) {
      let j = l.get(re);
      j === void 0 && (j = /* @__PURE__ */ new WeakMap(), l.set(re, j));
      let xe = j.get(k);
      xe === void 0 && (xe = s.getUniformBlockIndex(re, k.name), j.set(k, xe));
    }
    function vt(k, re) {
      const xe = l.get(re).get(k);
      a.get(re) !== xe && (s.uniformBlockBinding(re, xe, k.__bindingPointIndex), a.set(re, xe));
    }
    function Ye() {
      s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(true, true, true, true), s.clearColor(0, 0, 0, 0), s.depthMask(true), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), c = {}, U = null, G = {}, u = {}, d = /* @__PURE__ */ new WeakMap(), h = [], f = null, m = false, v = null, g = null, p = null, _ = null, x = null, b = null, E = null, S = new ye(0, 0, 0), w = 0, A = false, M = null, y = null, C = null, N = null, I = null, ce.set(0, 0, s.canvas.width, s.canvas.height), Te.set(0, 0, s.canvas.width, s.canvas.height), i.reset(), r.reset(), o.reset();
    }
    return {
      buffers: {
        color: i,
        depth: r,
        stencil: o
      },
      enable: de,
      disable: oe,
      bindFramebuffer: fe,
      drawBuffers: be,
      useProgram: F,
      setBlending: ie,
      setMaterial: Z,
      setFlipSided: le,
      setCullFace: se,
      setLineWidth: ve,
      setPolygonOffset: Ce,
      setScissorTest: L,
      activeTexture: T,
      bindTexture: W,
      unbindTexture: Q,
      compressedTexImage2D: ae,
      compressedTexImage3D: ne,
      texImage2D: Ze,
      texImage3D: Ne,
      updateUBOMapping: Je,
      uniformBlockBinding: vt,
      texStorage2D: he,
      texStorage3D: Pe,
      texSubImage2D: Ie,
      texSubImage3D: ge,
      compressedTexSubImage2D: me,
      compressedTexSubImage3D: ke,
      scissor: we,
      viewport: Xe,
      reset: Ye
    };
  }
  function bb(s, e, t, n, i, r, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new ee(), u = /* @__PURE__ */ new WeakMap();
    let d;
    const h = /* @__PURE__ */ new WeakMap();
    let f = false;
    try {
      f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch {
    }
    function m(L, T) {
      return f ? new OffscreenCanvas(L, T) : mo("canvas");
    }
    function v(L, T, W) {
      let Q = 1;
      const ae = Ce(L);
      if ((ae.width > W || ae.height > W) && (Q = W / Math.max(ae.width, ae.height)), Q < 1) if (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && L instanceof ImageBitmap || typeof VideoFrame < "u" && L instanceof VideoFrame) {
        const ne = Math.floor(Q * ae.width), Ie = Math.floor(Q * ae.height);
        d === void 0 && (d = m(ne, Ie));
        const ge = T ? m(ne, Ie) : d;
        return ge.width = ne, ge.height = Ie, ge.getContext("2d").drawImage(L, 0, 0, ne, Ie), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ae.width + "x" + ae.height + ") to (" + ne + "x" + Ie + ")."), ge;
      } else return "data" in L && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ae.width + "x" + ae.height + ")."), L;
      return L;
    }
    function g(L) {
      return L.generateMipmaps && L.minFilter !== At && L.minFilter !== Mt;
    }
    function p(L) {
      s.generateMipmap(L);
    }
    function _(L, T, W, Q, ae = false) {
      if (L !== null) {
        if (s[L] !== void 0) return s[L];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + L + "'");
      }
      let ne = T;
      if (T === s.RED && (W === s.FLOAT && (ne = s.R32F), W === s.HALF_FLOAT && (ne = s.R16F), W === s.UNSIGNED_BYTE && (ne = s.R8)), T === s.RED_INTEGER && (W === s.UNSIGNED_BYTE && (ne = s.R8UI), W === s.UNSIGNED_SHORT && (ne = s.R16UI), W === s.UNSIGNED_INT && (ne = s.R32UI), W === s.BYTE && (ne = s.R8I), W === s.SHORT && (ne = s.R16I), W === s.INT && (ne = s.R32I)), T === s.RG && (W === s.FLOAT && (ne = s.RG32F), W === s.HALF_FLOAT && (ne = s.RG16F), W === s.UNSIGNED_BYTE && (ne = s.RG8)), T === s.RG_INTEGER && (W === s.UNSIGNED_BYTE && (ne = s.RG8UI), W === s.UNSIGNED_SHORT && (ne = s.RG16UI), W === s.UNSIGNED_INT && (ne = s.RG32UI), W === s.BYTE && (ne = s.RG8I), W === s.SHORT && (ne = s.RG16I), W === s.INT && (ne = s.RG32I)), T === s.RGB && W === s.UNSIGNED_INT_5_9_9_9_REV && (ne = s.RGB9_E5), T === s.RGBA) {
        const Ie = ae ? co : st.getTransfer(Q);
        W === s.FLOAT && (ne = s.RGBA32F), W === s.HALF_FLOAT && (ne = s.RGBA16F), W === s.UNSIGNED_BYTE && (ne = Ie === lt ? s.SRGB8_ALPHA8 : s.RGBA8), W === s.UNSIGNED_SHORT_4_4_4_4 && (ne = s.RGBA4), W === s.UNSIGNED_SHORT_5_5_5_1 && (ne = s.RGB5_A1);
      }
      return (ne === s.R16F || ne === s.R32F || ne === s.RG16F || ne === s.RG32F || ne === s.RGBA16F || ne === s.RGBA32F) && e.get("EXT_color_buffer_float"), ne;
    }
    function x(L, T) {
      return g(L) === true || L.isFramebufferTexture && L.minFilter !== At && L.minFilter !== Mt ? Math.log2(Math.max(T.width, T.height)) + 1 : L.mipmaps !== void 0 && L.mipmaps.length > 0 ? L.mipmaps.length : L.isCompressedTexture && Array.isArray(L.image) ? T.mipmaps.length : 1;
    }
    function b(L) {
      const T = L.target;
      T.removeEventListener("dispose", b), S(T), T.isVideoTexture && u.delete(T);
    }
    function E(L) {
      const T = L.target;
      T.removeEventListener("dispose", E), A(T);
    }
    function S(L) {
      const T = n.get(L);
      if (T.__webglInit === void 0) return;
      const W = L.source, Q = h.get(W);
      if (Q) {
        const ae = Q[T.__cacheKey];
        ae.usedTimes--, ae.usedTimes === 0 && w(L), Object.keys(Q).length === 0 && h.delete(W);
      }
      n.remove(L);
    }
    function w(L) {
      const T = n.get(L);
      s.deleteTexture(T.__webglTexture);
      const W = L.source, Q = h.get(W);
      delete Q[T.__cacheKey], o.memory.textures--;
    }
    function A(L) {
      const T = n.get(L);
      if (L.depthTexture && L.depthTexture.dispose(), L.isWebGLCubeRenderTarget) for (let Q = 0; Q < 6; Q++) {
        if (Array.isArray(T.__webglFramebuffer[Q])) for (let ae = 0; ae < T.__webglFramebuffer[Q].length; ae++) s.deleteFramebuffer(T.__webglFramebuffer[Q][ae]);
        else s.deleteFramebuffer(T.__webglFramebuffer[Q]);
        T.__webglDepthbuffer && s.deleteRenderbuffer(T.__webglDepthbuffer[Q]);
      }
      else {
        if (Array.isArray(T.__webglFramebuffer)) for (let Q = 0; Q < T.__webglFramebuffer.length; Q++) s.deleteFramebuffer(T.__webglFramebuffer[Q]);
        else s.deleteFramebuffer(T.__webglFramebuffer);
        if (T.__webglDepthbuffer && s.deleteRenderbuffer(T.__webglDepthbuffer), T.__webglMultisampledFramebuffer && s.deleteFramebuffer(T.__webglMultisampledFramebuffer), T.__webglColorRenderbuffer) for (let Q = 0; Q < T.__webglColorRenderbuffer.length; Q++) T.__webglColorRenderbuffer[Q] && s.deleteRenderbuffer(T.__webglColorRenderbuffer[Q]);
        T.__webglDepthRenderbuffer && s.deleteRenderbuffer(T.__webglDepthRenderbuffer);
      }
      const W = L.textures;
      for (let Q = 0, ae = W.length; Q < ae; Q++) {
        const ne = n.get(W[Q]);
        ne.__webglTexture && (s.deleteTexture(ne.__webglTexture), o.memory.textures--), n.remove(W[Q]);
      }
      n.remove(L);
    }
    let M = 0;
    function y() {
      M = 0;
    }
    function C() {
      const L = M;
      return L >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + L + " texture units while this GPU supports only " + i.maxTextures), M += 1, L;
    }
    function N(L) {
      const T = [];
      return T.push(L.wrapS), T.push(L.wrapT), T.push(L.wrapR || 0), T.push(L.magFilter), T.push(L.minFilter), T.push(L.anisotropy), T.push(L.internalFormat), T.push(L.format), T.push(L.type), T.push(L.generateMipmaps), T.push(L.premultiplyAlpha), T.push(L.flipY), T.push(L.unpackAlignment), T.push(L.colorSpace), T.join();
    }
    function I(L, T) {
      const W = n.get(L);
      if (L.isVideoTexture && se(L), L.isRenderTargetTexture === false && L.version > 0 && W.__version !== L.version) {
        const Q = L.image;
        if (Q === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else if (Q.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        else {
          ce(W, L, T);
          return;
        }
      }
      t.bindTexture(s.TEXTURE_2D, W.__webglTexture, s.TEXTURE0 + T);
    }
    function D(L, T) {
      const W = n.get(L);
      if (L.version > 0 && W.__version !== L.version) {
        ce(W, L, T);
        return;
      }
      t.bindTexture(s.TEXTURE_2D_ARRAY, W.__webglTexture, s.TEXTURE0 + T);
    }
    function O(L, T) {
      const W = n.get(L);
      if (L.version > 0 && W.__version !== L.version) {
        ce(W, L, T);
        return;
      }
      t.bindTexture(s.TEXTURE_3D, W.__webglTexture, s.TEXTURE0 + T);
    }
    function z(L, T) {
      const W = n.get(L);
      if (L.version > 0 && W.__version !== L.version) {
        Te(W, L, T);
        return;
      }
      t.bindTexture(s.TEXTURE_CUBE_MAP, W.__webglTexture, s.TEXTURE0 + T);
    }
    const B = {
      [so]: s.REPEAT,
      [wn]: s.CLAMP_TO_EDGE,
      [ro]: s.MIRRORED_REPEAT
    }, U = {
      [At]: s.NEAREST,
      [Qh]: s.NEAREST_MIPMAP_NEAREST,
      [Qs]: s.NEAREST_MIPMAP_LINEAR,
      [Mt]: s.LINEAR,
      [$r]: s.LINEAR_MIPMAP_NEAREST,
      [Xn]: s.LINEAR_MIPMAP_LINEAR
    }, G = {
      [bm]: s.NEVER,
      [Cm]: s.ALWAYS,
      [Sm]: s.LESS,
      [cu]: s.LEQUAL,
      [wm]: s.EQUAL,
      [Am]: s.GEQUAL,
      [Tm]: s.GREATER,
      [Em]: s.NOTEQUAL
    };
    function V(L, T) {
      if (T.type === Tn && e.has("OES_texture_float_linear") === false && (T.magFilter === Mt || T.magFilter === $r || T.magFilter === Qs || T.magFilter === Xn || T.minFilter === Mt || T.minFilter === $r || T.minFilter === Qs || T.minFilter === Xn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(L, s.TEXTURE_WRAP_S, B[T.wrapS]), s.texParameteri(L, s.TEXTURE_WRAP_T, B[T.wrapT]), (L === s.TEXTURE_3D || L === s.TEXTURE_2D_ARRAY) && s.texParameteri(L, s.TEXTURE_WRAP_R, B[T.wrapR]), s.texParameteri(L, s.TEXTURE_MAG_FILTER, U[T.magFilter]), s.texParameteri(L, s.TEXTURE_MIN_FILTER, U[T.minFilter]), T.compareFunction && (s.texParameteri(L, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(L, s.TEXTURE_COMPARE_FUNC, G[T.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
        if (T.magFilter === At || T.minFilter !== Qs && T.minFilter !== Xn || T.type === Tn && e.has("OES_texture_float_linear") === false) return;
        if (T.anisotropy > 1 || n.get(T).__currentAnisotropy) {
          const W = e.get("EXT_texture_filter_anisotropic");
          s.texParameterf(L, W.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(T.anisotropy, i.getMaxAnisotropy())), n.get(T).__currentAnisotropy = T.anisotropy;
        }
      }
    }
    function K(L, T) {
      let W = false;
      L.__webglInit === void 0 && (L.__webglInit = true, T.addEventListener("dispose", b));
      const Q = T.source;
      let ae = h.get(Q);
      ae === void 0 && (ae = {}, h.set(Q, ae));
      const ne = N(T);
      if (ne !== L.__cacheKey) {
        ae[ne] === void 0 && (ae[ne] = {
          texture: s.createTexture(),
          usedTimes: 0
        }, o.memory.textures++, W = true), ae[ne].usedTimes++;
        const Ie = ae[L.__cacheKey];
        Ie !== void 0 && (ae[L.__cacheKey].usedTimes--, Ie.usedTimes === 0 && w(T)), L.__cacheKey = ne, L.__webglTexture = ae[ne].texture;
      }
      return W;
    }
    function ce(L, T, W) {
      let Q = s.TEXTURE_2D;
      (T.isDataArrayTexture || T.isCompressedArrayTexture) && (Q = s.TEXTURE_2D_ARRAY), T.isData3DTexture && (Q = s.TEXTURE_3D);
      const ae = K(L, T), ne = T.source;
      t.bindTexture(Q, L.__webglTexture, s.TEXTURE0 + W);
      const Ie = n.get(ne);
      if (ne.version !== Ie.__version || ae === true) {
        t.activeTexture(s.TEXTURE0 + W);
        const ge = st.getPrimaries(st.workingColorSpace), me = T.colorSpace === ai ? null : st.getPrimaries(T.colorSpace), ke = T.colorSpace === ai || ge === me ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
        s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, T.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, T.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, ke);
        let he = v(T.image, false, i.maxTextureSize);
        he = ve(T, he);
        const Pe = r.convert(T.format, T.colorSpace), Ze = r.convert(T.type);
        let Ne = _(T.internalFormat, Pe, Ze, T.colorSpace, T.isVideoTexture);
        V(Q, T);
        let we;
        const Xe = T.mipmaps, Je = T.isVideoTexture !== true, vt = Ie.__version === void 0 || ae === true, Ye = ne.dataReady, k = x(T, he);
        if (T.isDepthTexture) Ne = s.DEPTH_COMPONENT16, T.type === Tn ? Ne = s.DEPTH_COMPONENT32F : T.type === Ts ? Ne = s.DEPTH_COMPONENT24 : T.type === _r && (Ne = s.DEPTH24_STENCIL8), vt && (Je ? t.texStorage2D(s.TEXTURE_2D, 1, Ne, he.width, he.height) : t.texImage2D(s.TEXTURE_2D, 0, Ne, he.width, he.height, 0, Pe, Ze, null));
        else if (T.isDataTexture) if (Xe.length > 0) {
          Je && vt && t.texStorage2D(s.TEXTURE_2D, k, Ne, Xe[0].width, Xe[0].height);
          for (let re = 0, j = Xe.length; re < j; re++) we = Xe[re], Je ? Ye && t.texSubImage2D(s.TEXTURE_2D, re, 0, 0, we.width, we.height, Pe, Ze, we.data) : t.texImage2D(s.TEXTURE_2D, re, Ne, we.width, we.height, 0, Pe, Ze, we.data);
          T.generateMipmaps = false;
        } else Je ? (vt && t.texStorage2D(s.TEXTURE_2D, k, Ne, he.width, he.height), Ye && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, he.width, he.height, Pe, Ze, he.data)) : t.texImage2D(s.TEXTURE_2D, 0, Ne, he.width, he.height, 0, Pe, Ze, he.data);
        else if (T.isCompressedTexture) if (T.isCompressedArrayTexture) {
          Je && vt && t.texStorage3D(s.TEXTURE_2D_ARRAY, k, Ne, Xe[0].width, Xe[0].height, he.depth);
          for (let re = 0, j = Xe.length; re < j; re++) we = Xe[re], T.format !== dn ? Pe !== null ? Je ? Ye && t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, re, 0, 0, 0, we.width, we.height, he.depth, Pe, we.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, re, Ne, we.width, we.height, he.depth, 0, we.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Je ? Ye && t.texSubImage3D(s.TEXTURE_2D_ARRAY, re, 0, 0, 0, we.width, we.height, he.depth, Pe, Ze, we.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, re, Ne, we.width, we.height, he.depth, 0, Pe, Ze, we.data);
        } else {
          Je && vt && t.texStorage2D(s.TEXTURE_2D, k, Ne, Xe[0].width, Xe[0].height);
          for (let re = 0, j = Xe.length; re < j; re++) we = Xe[re], T.format !== dn ? Pe !== null ? Je ? Ye && t.compressedTexSubImage2D(s.TEXTURE_2D, re, 0, 0, we.width, we.height, Pe, we.data) : t.compressedTexImage2D(s.TEXTURE_2D, re, Ne, we.width, we.height, 0, we.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Je ? Ye && t.texSubImage2D(s.TEXTURE_2D, re, 0, 0, we.width, we.height, Pe, Ze, we.data) : t.texImage2D(s.TEXTURE_2D, re, Ne, we.width, we.height, 0, Pe, Ze, we.data);
        }
        else if (T.isDataArrayTexture) Je ? (vt && t.texStorage3D(s.TEXTURE_2D_ARRAY, k, Ne, he.width, he.height, he.depth), Ye && t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, he.width, he.height, he.depth, Pe, Ze, he.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Ne, he.width, he.height, he.depth, 0, Pe, Ze, he.data);
        else if (T.isData3DTexture) Je ? (vt && t.texStorage3D(s.TEXTURE_3D, k, Ne, he.width, he.height, he.depth), Ye && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, he.width, he.height, he.depth, Pe, Ze, he.data)) : t.texImage3D(s.TEXTURE_3D, 0, Ne, he.width, he.height, he.depth, 0, Pe, Ze, he.data);
        else if (T.isFramebufferTexture) {
          if (vt) if (Je) t.texStorage2D(s.TEXTURE_2D, k, Ne, he.width, he.height);
          else {
            let re = he.width, j = he.height;
            for (let xe = 0; xe < k; xe++) t.texImage2D(s.TEXTURE_2D, xe, Ne, re, j, 0, Pe, Ze, null), re >>= 1, j >>= 1;
          }
        } else if (Xe.length > 0) {
          if (Je && vt) {
            const re = Ce(Xe[0]);
            t.texStorage2D(s.TEXTURE_2D, k, Ne, re.width, re.height);
          }
          for (let re = 0, j = Xe.length; re < j; re++) we = Xe[re], Je ? Ye && t.texSubImage2D(s.TEXTURE_2D, re, 0, 0, Pe, Ze, we) : t.texImage2D(s.TEXTURE_2D, re, Ne, Pe, Ze, we);
          T.generateMipmaps = false;
        } else if (Je) {
          if (vt) {
            const re = Ce(he);
            t.texStorage2D(s.TEXTURE_2D, k, Ne, re.width, re.height);
          }
          Ye && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Pe, Ze, he);
        } else t.texImage2D(s.TEXTURE_2D, 0, Ne, Pe, Ze, he);
        g(T) && p(Q), Ie.__version = ne.version, T.onUpdate && T.onUpdate(T);
      }
      L.__version = T.version;
    }
    function Te(L, T, W) {
      if (T.image.length !== 6) return;
      const Q = K(L, T), ae = T.source;
      t.bindTexture(s.TEXTURE_CUBE_MAP, L.__webglTexture, s.TEXTURE0 + W);
      const ne = n.get(ae);
      if (ae.version !== ne.__version || Q === true) {
        t.activeTexture(s.TEXTURE0 + W);
        const Ie = st.getPrimaries(st.workingColorSpace), ge = T.colorSpace === ai ? null : st.getPrimaries(T.colorSpace), me = T.colorSpace === ai || Ie === ge ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
        s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, T.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, T.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, me);
        const ke = T.isCompressedTexture || T.image[0].isCompressedTexture, he = T.image[0] && T.image[0].isDataTexture, Pe = [];
        for (let j = 0; j < 6; j++) !ke && !he ? Pe[j] = v(T.image[j], true, i.maxCubemapSize) : Pe[j] = he ? T.image[j].image : T.image[j], Pe[j] = ve(T, Pe[j]);
        const Ze = Pe[0], Ne = r.convert(T.format, T.colorSpace), we = r.convert(T.type), Xe = _(T.internalFormat, Ne, we, T.colorSpace), Je = T.isVideoTexture !== true, vt = ne.__version === void 0 || Q === true, Ye = ae.dataReady;
        let k = x(T, Ze);
        V(s.TEXTURE_CUBE_MAP, T);
        let re;
        if (ke) {
          Je && vt && t.texStorage2D(s.TEXTURE_CUBE_MAP, k, Xe, Ze.width, Ze.height);
          for (let j = 0; j < 6; j++) {
            re = Pe[j].mipmaps;
            for (let xe = 0; xe < re.length; xe++) {
              const Me = re[xe];
              T.format !== dn ? Ne !== null ? Je ? Ye && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe, 0, 0, Me.width, Me.height, Ne, Me.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe, Xe, Me.width, Me.height, 0, Me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Je ? Ye && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe, 0, 0, Me.width, Me.height, Ne, we, Me.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe, Xe, Me.width, Me.height, 0, Ne, we, Me.data);
            }
          }
        } else {
          if (re = T.mipmaps, Je && vt) {
            re.length > 0 && k++;
            const j = Ce(Pe[0]);
            t.texStorage2D(s.TEXTURE_CUBE_MAP, k, Xe, j.width, j.height);
          }
          for (let j = 0; j < 6; j++) if (he) {
            Je ? Ye && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, 0, 0, Pe[j].width, Pe[j].height, Ne, we, Pe[j].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, Xe, Pe[j].width, Pe[j].height, 0, Ne, we, Pe[j].data);
            for (let xe = 0; xe < re.length; xe++) {
              const je = re[xe].image[j].image;
              Je ? Ye && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe + 1, 0, 0, je.width, je.height, Ne, we, je.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe + 1, Xe, je.width, je.height, 0, Ne, we, je.data);
            }
          } else {
            Je ? Ye && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, 0, 0, Ne, we, Pe[j]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, Xe, Ne, we, Pe[j]);
            for (let xe = 0; xe < re.length; xe++) {
              const Me = re[xe];
              Je ? Ye && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe + 1, 0, 0, Ne, we, Me.image[j]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + j, xe + 1, Xe, Ne, we, Me.image[j]);
            }
          }
        }
        g(T) && p(s.TEXTURE_CUBE_MAP), ne.__version = ae.version, T.onUpdate && T.onUpdate(T);
      }
      L.__version = T.version;
    }
    function q(L, T, W, Q, ae, ne) {
      const Ie = r.convert(W.format, W.colorSpace), ge = r.convert(W.type), me = _(W.internalFormat, Ie, ge, W.colorSpace);
      if (!n.get(T).__hasExternalTextures) {
        const he = Math.max(1, T.width >> ne), Pe = Math.max(1, T.height >> ne);
        ae === s.TEXTURE_3D || ae === s.TEXTURE_2D_ARRAY ? t.texImage3D(ae, ne, me, he, Pe, T.depth, 0, Ie, ge, null) : t.texImage2D(ae, ne, me, he, Pe, 0, Ie, ge, null);
      }
      t.bindFramebuffer(s.FRAMEBUFFER, L), le(T) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, Q, ae, n.get(W).__webglTexture, 0, Z(T)) : (ae === s.TEXTURE_2D || ae >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ae <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, Q, ae, n.get(W).__webglTexture, ne), t.bindFramebuffer(s.FRAMEBUFFER, null);
    }
    function te(L, T, W) {
      if (s.bindRenderbuffer(s.RENDERBUFFER, L), T.depthBuffer && !T.stencilBuffer) {
        let Q = s.DEPTH_COMPONENT24;
        if (W || le(T)) {
          const ae = T.depthTexture;
          ae && ae.isDepthTexture && (ae.type === Tn ? Q = s.DEPTH_COMPONENT32F : ae.type === Ts && (Q = s.DEPTH_COMPONENT24));
          const ne = Z(T);
          le(T) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, ne, Q, T.width, T.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, ne, Q, T.width, T.height);
        } else s.renderbufferStorage(s.RENDERBUFFER, Q, T.width, T.height);
        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, L);
      } else if (T.depthBuffer && T.stencilBuffer) {
        const Q = Z(T);
        W && le(T) === false ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Q, s.DEPTH24_STENCIL8, T.width, T.height) : le(T) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Q, s.DEPTH24_STENCIL8, T.width, T.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, T.width, T.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, L);
      } else {
        const Q = T.textures;
        for (let ae = 0; ae < Q.length; ae++) {
          const ne = Q[ae], Ie = r.convert(ne.format, ne.colorSpace), ge = r.convert(ne.type), me = _(ne.internalFormat, Ie, ge, ne.colorSpace), ke = Z(T);
          W && le(T) === false ? s.renderbufferStorageMultisample(s.RENDERBUFFER, ke, me, T.width, T.height) : le(T) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, ke, me, T.width, T.height) : s.renderbufferStorage(s.RENDERBUFFER, me, T.width, T.height);
        }
      }
      s.bindRenderbuffer(s.RENDERBUFFER, null);
    }
    function de(L, T) {
      if (T && T.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
      if (t.bindFramebuffer(s.FRAMEBUFFER, L), !(T.depthTexture && T.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      (!n.get(T.depthTexture).__webglTexture || T.depthTexture.image.width !== T.width || T.depthTexture.image.height !== T.height) && (T.depthTexture.image.width = T.width, T.depthTexture.image.height = T.height, T.depthTexture.needsUpdate = true), I(T.depthTexture, 0);
      const Q = n.get(T.depthTexture).__webglTexture, ae = Z(T);
      if (T.depthTexture.format === Ss) le(T) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Q, 0, ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Q, 0);
      else if (T.depthTexture.format === hr) le(T) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Q, 0, ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Q, 0);
      else throw new Error("Unknown depthTexture format");
    }
    function oe(L) {
      const T = n.get(L), W = L.isWebGLCubeRenderTarget === true;
      if (L.depthTexture && !T.__autoAllocateDepthBuffer) {
        if (W) throw new Error("target.depthTexture not supported in Cube render targets");
        de(T.__webglFramebuffer, L);
      } else if (W) {
        T.__webglDepthbuffer = [];
        for (let Q = 0; Q < 6; Q++) t.bindFramebuffer(s.FRAMEBUFFER, T.__webglFramebuffer[Q]), T.__webglDepthbuffer[Q] = s.createRenderbuffer(), te(T.__webglDepthbuffer[Q], L, false);
      } else t.bindFramebuffer(s.FRAMEBUFFER, T.__webglFramebuffer), T.__webglDepthbuffer = s.createRenderbuffer(), te(T.__webglDepthbuffer, L, false);
      t.bindFramebuffer(s.FRAMEBUFFER, null);
    }
    function fe(L, T, W) {
      const Q = n.get(L);
      T !== void 0 && q(Q.__webglFramebuffer, L, L.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), W !== void 0 && oe(L);
    }
    function be(L) {
      const T = L.texture, W = n.get(L), Q = n.get(T);
      L.addEventListener("dispose", E);
      const ae = L.textures, ne = L.isWebGLCubeRenderTarget === true, Ie = ae.length > 1;
      if (Ie || (Q.__webglTexture === void 0 && (Q.__webglTexture = s.createTexture()), Q.__version = T.version, o.memory.textures++), ne) {
        W.__webglFramebuffer = [];
        for (let ge = 0; ge < 6; ge++) if (T.mipmaps && T.mipmaps.length > 0) {
          W.__webglFramebuffer[ge] = [];
          for (let me = 0; me < T.mipmaps.length; me++) W.__webglFramebuffer[ge][me] = s.createFramebuffer();
        } else W.__webglFramebuffer[ge] = s.createFramebuffer();
      } else {
        if (T.mipmaps && T.mipmaps.length > 0) {
          W.__webglFramebuffer = [];
          for (let ge = 0; ge < T.mipmaps.length; ge++) W.__webglFramebuffer[ge] = s.createFramebuffer();
        } else W.__webglFramebuffer = s.createFramebuffer();
        if (Ie) for (let ge = 0, me = ae.length; ge < me; ge++) {
          const ke = n.get(ae[ge]);
          ke.__webglTexture === void 0 && (ke.__webglTexture = s.createTexture(), o.memory.textures++);
        }
        if (L.samples > 0 && le(L) === false) {
          W.__webglMultisampledFramebuffer = s.createFramebuffer(), W.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, W.__webglMultisampledFramebuffer);
          for (let ge = 0; ge < ae.length; ge++) {
            const me = ae[ge];
            W.__webglColorRenderbuffer[ge] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, W.__webglColorRenderbuffer[ge]);
            const ke = r.convert(me.format, me.colorSpace), he = r.convert(me.type), Pe = _(me.internalFormat, ke, he, me.colorSpace, L.isXRRenderTarget === true), Ze = Z(L);
            s.renderbufferStorageMultisample(s.RENDERBUFFER, Ze, Pe, L.width, L.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + ge, s.RENDERBUFFER, W.__webglColorRenderbuffer[ge]);
          }
          s.bindRenderbuffer(s.RENDERBUFFER, null), L.depthBuffer && (W.__webglDepthRenderbuffer = s.createRenderbuffer(), te(W.__webglDepthRenderbuffer, L, true)), t.bindFramebuffer(s.FRAMEBUFFER, null);
        }
      }
      if (ne) {
        t.bindTexture(s.TEXTURE_CUBE_MAP, Q.__webglTexture), V(s.TEXTURE_CUBE_MAP, T);
        for (let ge = 0; ge < 6; ge++) if (T.mipmaps && T.mipmaps.length > 0) for (let me = 0; me < T.mipmaps.length; me++) q(W.__webglFramebuffer[ge][me], L, T, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + ge, me);
        else q(W.__webglFramebuffer[ge], L, T, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + ge, 0);
        g(T) && p(s.TEXTURE_CUBE_MAP), t.unbindTexture();
      } else if (Ie) {
        for (let ge = 0, me = ae.length; ge < me; ge++) {
          const ke = ae[ge], he = n.get(ke);
          t.bindTexture(s.TEXTURE_2D, he.__webglTexture), V(s.TEXTURE_2D, ke), q(W.__webglFramebuffer, L, ke, s.COLOR_ATTACHMENT0 + ge, s.TEXTURE_2D, 0), g(ke) && p(s.TEXTURE_2D);
        }
        t.unbindTexture();
      } else {
        let ge = s.TEXTURE_2D;
        if ((L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) && (ge = L.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), t.bindTexture(ge, Q.__webglTexture), V(ge, T), T.mipmaps && T.mipmaps.length > 0) for (let me = 0; me < T.mipmaps.length; me++) q(W.__webglFramebuffer[me], L, T, s.COLOR_ATTACHMENT0, ge, me);
        else q(W.__webglFramebuffer, L, T, s.COLOR_ATTACHMENT0, ge, 0);
        g(T) && p(ge), t.unbindTexture();
      }
      L.depthBuffer && oe(L);
    }
    function F(L) {
      const T = L.textures;
      for (let W = 0, Q = T.length; W < Q; W++) {
        const ae = T[W];
        if (g(ae)) {
          const ne = L.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, Ie = n.get(ae).__webglTexture;
          t.bindTexture(ne, Ie), p(ne), t.unbindTexture();
        }
      }
    }
    const Le = [], J = [];
    function ie(L) {
      if (L.samples > 0) {
        if (le(L) === false) {
          const T = L.textures, W = L.width, Q = L.height;
          let ae = s.COLOR_BUFFER_BIT;
          const ne = L.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Ie = n.get(L), ge = T.length > 1;
          if (ge) for (let me = 0; me < T.length; me++) t.bindFramebuffer(s.FRAMEBUFFER, Ie.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + me, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Ie.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + me, s.TEXTURE_2D, null, 0);
          t.bindFramebuffer(s.READ_FRAMEBUFFER, Ie.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Ie.__webglFramebuffer);
          for (let me = 0; me < T.length; me++) {
            if (L.resolveDepthBuffer && (L.depthBuffer && (ae |= s.DEPTH_BUFFER_BIT), L.stencilBuffer && L.resolveStencilBuffer && (ae |= s.STENCIL_BUFFER_BIT)), ge) {
              s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Ie.__webglColorRenderbuffer[me]);
              const ke = n.get(T[me]).__webglTexture;
              s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, ke, 0);
            }
            s.blitFramebuffer(0, 0, W, Q, 0, 0, W, Q, ae, s.NEAREST), l === true && (Le.length = 0, J.length = 0, Le.push(s.COLOR_ATTACHMENT0 + me), L.depthBuffer && L.resolveDepthBuffer === false && (Le.push(ne), J.push(ne), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, J)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Le));
          }
          if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), ge) for (let me = 0; me < T.length; me++) {
            t.bindFramebuffer(s.FRAMEBUFFER, Ie.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + me, s.RENDERBUFFER, Ie.__webglColorRenderbuffer[me]);
            const ke = n.get(T[me]).__webglTexture;
            t.bindFramebuffer(s.FRAMEBUFFER, Ie.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + me, s.TEXTURE_2D, ke, 0);
          }
          t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Ie.__webglMultisampledFramebuffer);
        } else if (L.depthBuffer && L.resolveDepthBuffer === false && l) {
          const T = L.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
          s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [
            T
          ]);
        }
      }
    }
    function Z(L) {
      return Math.min(i.maxSamples, L.samples);
    }
    function le(L) {
      const T = n.get(L);
      return L.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && T.__useRenderToTexture !== false;
    }
    function se(L) {
      const T = o.render.frame;
      u.get(L) !== T && (u.set(L, T), L.update());
    }
    function ve(L, T) {
      const W = L.colorSpace, Q = L.format, ae = L.type;
      return L.isCompressedTexture === true || L.isVideoTexture === true || W !== yi && W !== ai && (st.getTransfer(W) === lt ? (Q !== dn || ae !== vi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", W)), T;
    }
    function Ce(L) {
      return typeof HTMLImageElement < "u" && L instanceof HTMLImageElement ? (c.width = L.naturalWidth || L.width, c.height = L.naturalHeight || L.height) : typeof VideoFrame < "u" && L instanceof VideoFrame ? (c.width = L.displayWidth, c.height = L.displayHeight) : (c.width = L.width, c.height = L.height), c;
    }
    this.allocateTextureUnit = C, this.resetTextureUnits = y, this.setTexture2D = I, this.setTexture2DArray = D, this.setTexture3D = O, this.setTextureCube = z, this.rebindTextures = fe, this.setupRenderTarget = be, this.updateRenderTargetMipmap = F, this.updateMultisampleRenderTarget = ie, this.setupDepthRenderbuffer = oe, this.setupFrameBufferTexture = q, this.useMultisampledRTT = le;
  }
  function Xm(s, e) {
    function t(n, i = ai) {
      let r;
      const o = st.getTransfer(i);
      if (n === vi) return s.UNSIGNED_BYTE;
      if (n === nu) return s.UNSIGNED_SHORT_4_4_4_4;
      if (n === iu) return s.UNSIGNED_SHORT_5_5_5_1;
      if (n === cm) return s.UNSIGNED_INT_5_9_9_9_REV;
      if (n === am) return s.BYTE;
      if (n === lm) return s.SHORT;
      if (n === eu) return s.UNSIGNED_SHORT;
      if (n === tu) return s.INT;
      if (n === Ts) return s.UNSIGNED_INT;
      if (n === Tn) return s.FLOAT;
      if (n === Do) return s.HALF_FLOAT;
      if (n === hm) return s.ALPHA;
      if (n === um) return s.RGB;
      if (n === dn) return s.RGBA;
      if (n === dm) return s.LUMINANCE;
      if (n === fm) return s.LUMINANCE_ALPHA;
      if (n === Ss) return s.DEPTH_COMPONENT;
      if (n === hr) return s.DEPTH_STENCIL;
      if (n === su) return s.RED;
      if (n === ru) return s.RED_INTEGER;
      if (n === pm) return s.RG;
      if (n === ou) return s.RG_INTEGER;
      if (n === au) return s.RGBA_INTEGER;
      if (n === ka || n === Va || n === Ha || n === Ga) if (o === lt) if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
        if (n === ka) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (n === Va) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (n === Ha) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (n === Ga) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
        if (n === ka) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Va) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Ha) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Ga) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
      if (n === nh || n === ih || n === sh || n === rh) if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
        if (n === nh) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === ih) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === sh) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === rh) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
      if (n === oh || n === ah || n === lh) if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
        if (n === oh || n === ah) return o === lt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (n === lh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
      if (n === ch || n === hh || n === uh || n === dh || n === fh || n === ph || n === mh || n === gh || n === vh || n === xh || n === _h || n === yh || n === Mh || n === bh) if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
        if (n === ch) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === hh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === uh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === dh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === fh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === ph) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === mh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === gh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === vh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === xh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === _h) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === yh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Mh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === bh) return o === lt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
      if (n === Wa || n === Sh || n === wh) if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
        if (n === Wa) return o === lt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === Sh) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === wh) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
      if (n === mm || n === Th || n === Eh || n === Ah) if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
        if (n === Wa) return r.COMPRESSED_RED_RGTC1_EXT;
        if (n === Th) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Eh) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === Ah) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
      return n === _r ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null;
    }
    return {
      convert: t
    };
  }
  class Ym extends Et {
    constructor(e = []) {
      super(), this.isArrayCamera = true, this.cameras = e;
    }
  }
  class Ln extends Qe {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  }
  const Sb = {
    type: "move"
  };
  class Tc {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new Ln(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
        pinching: false
      }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new Ln(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new P(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new P()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new Ln(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new P(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new P()), this._grip;
    }
    dispatchEvent(e) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
    }
    connect(e) {
      if (e && e.hand) {
        const t = this._hand;
        if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
      }
      return this.dispatchEvent({
        type: "connected",
        data: e
      }), this;
    }
    disconnect(e) {
      return this.dispatchEvent({
        type: "disconnected",
        data: e
      }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(e, t, n) {
      let i = null, r = null, o = null;
      const a = this._targetRay, l = this._grip, c = this._hand;
      if (e && t.session.visibilityState !== "visible-blurred") {
        if (c && e.hand) {
          o = true;
          for (const v of e.hand.values()) {
            const g = t.getJointPose(v, n), p = this._getHandJoint(c, v);
            g !== null && (p.matrix.fromArray(g.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = true, p.jointRadius = g.radius), p.visible = g !== null;
          }
          const u = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], h = u.position.distanceTo(d.position), f = 0.02, m = 5e-3;
          c.inputState.pinching && h > f + m ? (c.inputState.pinching = false, this.dispatchEvent({
            type: "pinchend",
            handedness: e.handedness,
            target: this
          })) : !c.inputState.pinching && h <= f - m && (c.inputState.pinching = true, this.dispatchEvent({
            type: "pinchstart",
            handedness: e.handedness,
            target: this
          }));
        } else l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, r.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = false, r.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = false));
        a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = true, i.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = false, i.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(Sb)));
      }
      return a !== null && (a.visible = i !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
    }
    _getHandJoint(e, t) {
      if (e.joints[t.jointName] === void 0) {
        const n = new Ln();
        n.matrixAutoUpdate = false, n.visible = false, e.joints[t.jointName] = n, e.add(n);
      }
      return e.joints[t.jointName];
    }
  }
  const wb = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, Tb = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
  class Eb {
    constructor() {
      this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
    }
    init(e, t, n) {
      if (this.texture === null) {
        const i = new gt(), r = e.properties.get(i);
        r.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
      }
    }
    render(e, t) {
      if (this.texture !== null) {
        if (this.mesh === null) {
          const n = t.cameras[0].viewport, i = new Fn({
            vertexShader: wb,
            fragmentShader: Tb,
            uniforms: {
              depthColor: {
                value: this.texture
              },
              depthWidth: {
                value: n.z
              },
              depthHeight: {
                value: n.w
              }
            }
          });
          this.mesh = new ht(new Mr(20, 20), i);
        }
        e.render(this.mesh, t);
      }
    }
    reset() {
      this.texture = null, this.mesh = null;
    }
  }
  class Ab extends Mi {
    constructor(e, t) {
      super();
      const n = this;
      let i = null, r = 1, o = null, a = "local-floor", l = 1, c = null, u = null, d = null, h = null, f = null, m = null;
      const v = new Eb(), g = t.getContextAttributes();
      let p = null, _ = null;
      const x = [], b = [], E = new ee();
      let S = null;
      const w = new Et();
      w.layers.enable(1), w.viewport = new rt();
      const A = new Et();
      A.layers.enable(2), A.viewport = new rt();
      const M = [
        w,
        A
      ], y = new Ym();
      y.layers.enable(1), y.layers.enable(2);
      let C = null, N = null;
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(q) {
        let te = x[q];
        return te === void 0 && (te = new Tc(), x[q] = te), te.getTargetRaySpace();
      }, this.getControllerGrip = function(q) {
        let te = x[q];
        return te === void 0 && (te = new Tc(), x[q] = te), te.getGripSpace();
      }, this.getHand = function(q) {
        let te = x[q];
        return te === void 0 && (te = new Tc(), x[q] = te), te.getHandSpace();
      };
      function I(q) {
        const te = b.indexOf(q.inputSource);
        if (te === -1) return;
        const de = x[te];
        de !== void 0 && (de.update(q.inputSource, q.frame, c || o), de.dispatchEvent({
          type: q.type,
          data: q.inputSource
        }));
      }
      function D() {
        i.removeEventListener("select", I), i.removeEventListener("selectstart", I), i.removeEventListener("selectend", I), i.removeEventListener("squeeze", I), i.removeEventListener("squeezestart", I), i.removeEventListener("squeezeend", I), i.removeEventListener("end", D), i.removeEventListener("inputsourceschange", O);
        for (let q = 0; q < x.length; q++) {
          const te = b[q];
          te !== null && (b[q] = null, x[q].disconnect(te));
        }
        C = null, N = null, v.reset(), e.setRenderTarget(p), f = null, h = null, d = null, i = null, _ = null, Te.stop(), n.isPresenting = false, e.setPixelRatio(S), e.setSize(E.width, E.height, false), n.dispatchEvent({
          type: "sessionend"
        });
      }
      this.setFramebufferScaleFactor = function(q) {
        r = q, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(q) {
        a = q, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return c || o;
      }, this.setReferenceSpace = function(q) {
        c = q;
      }, this.getBaseLayer = function() {
        return h !== null ? h : f;
      }, this.getBinding = function() {
        return d;
      }, this.getFrame = function() {
        return m;
      }, this.getSession = function() {
        return i;
      }, this.setSession = async function(q) {
        if (i = q, i !== null) {
          if (p = e.getRenderTarget(), i.addEventListener("select", I), i.addEventListener("selectstart", I), i.addEventListener("selectend", I), i.addEventListener("squeeze", I), i.addEventListener("squeezestart", I), i.addEventListener("squeezeend", I), i.addEventListener("end", D), i.addEventListener("inputsourceschange", O), g.xrCompatible !== true && await t.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(E), i.renderState.layers === void 0) {
            const te = {
              antialias: g.antialias,
              alpha: true,
              depth: g.depth,
              stencil: g.stencil,
              framebufferScaleFactor: r
            };
            f = new XRWebGLLayer(i, t, te), i.updateRenderState({
              baseLayer: f
            }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, false), _ = new zn(f.framebufferWidth, f.framebufferHeight, {
              format: dn,
              type: vi,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            });
          } else {
            let te = null, de = null, oe = null;
            g.depth && (oe = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, te = g.stencil ? hr : Ss, de = g.stencil ? _r : Ts);
            const fe = {
              colorFormat: t.RGBA8,
              depthFormat: oe,
              scaleFactor: r
            };
            d = new XRWebGLBinding(i, t), h = d.createProjectionLayer(fe), i.updateRenderState({
              layers: [
                h
              ]
            }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, false), _ = new zn(h.textureWidth, h.textureHeight, {
              format: dn,
              type: vi,
              depthTexture: new mu(h.textureWidth, h.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, te),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0,
              resolveDepthBuffer: h.ignoreDepthValues === false
            });
          }
          _.isXRRenderTarget = true, this.setFoveation(l), c = null, o = await i.requestReferenceSpace(a), Te.setContext(i), Te.start(), n.isPresenting = true, n.dispatchEvent({
            type: "sessionstart"
          });
        }
      }, this.getEnvironmentBlendMode = function() {
        if (i !== null) return i.environmentBlendMode;
      };
      function O(q) {
        for (let te = 0; te < q.removed.length; te++) {
          const de = q.removed[te], oe = b.indexOf(de);
          oe >= 0 && (b[oe] = null, x[oe].disconnect(de));
        }
        for (let te = 0; te < q.added.length; te++) {
          const de = q.added[te];
          let oe = b.indexOf(de);
          if (oe === -1) {
            for (let be = 0; be < x.length; be++) if (be >= b.length) {
              b.push(de), oe = be;
              break;
            } else if (b[be] === null) {
              b[be] = de, oe = be;
              break;
            }
            if (oe === -1) break;
          }
          const fe = x[oe];
          fe && fe.connect(de);
        }
      }
      const z = new P(), B = new P();
      function U(q, te, de) {
        z.setFromMatrixPosition(te.matrixWorld), B.setFromMatrixPosition(de.matrixWorld);
        const oe = z.distanceTo(B), fe = te.projectionMatrix.elements, be = de.projectionMatrix.elements, F = fe[14] / (fe[10] - 1), Le = fe[14] / (fe[10] + 1), J = (fe[9] + 1) / fe[5], ie = (fe[9] - 1) / fe[5], Z = (fe[8] - 1) / fe[0], le = (be[8] + 1) / be[0], se = F * Z, ve = F * le, Ce = oe / (-Z + le), L = Ce * -Z;
        te.matrixWorld.decompose(q.position, q.quaternion, q.scale), q.translateX(L), q.translateZ(Ce), q.matrixWorld.compose(q.position, q.quaternion, q.scale), q.matrixWorldInverse.copy(q.matrixWorld).invert();
        const T = F + Ce, W = Le + Ce, Q = se - L, ae = ve + (oe - L), ne = J * Le / W * T, Ie = ie * Le / W * T;
        q.projectionMatrix.makePerspective(Q, ae, ne, Ie, T, W), q.projectionMatrixInverse.copy(q.projectionMatrix).invert();
      }
      function G(q, te) {
        te === null ? q.matrixWorld.copy(q.matrix) : q.matrixWorld.multiplyMatrices(te.matrixWorld, q.matrix), q.matrixWorldInverse.copy(q.matrixWorld).invert();
      }
      this.updateCamera = function(q) {
        if (i === null) return;
        v.texture !== null && (q.near = v.depthNear, q.far = v.depthFar), y.near = A.near = w.near = q.near, y.far = A.far = w.far = q.far, (C !== y.near || N !== y.far) && (i.updateRenderState({
          depthNear: y.near,
          depthFar: y.far
        }), C = y.near, N = y.far, w.near = C, w.far = N, A.near = C, A.far = N, w.updateProjectionMatrix(), A.updateProjectionMatrix(), q.updateProjectionMatrix());
        const te = q.parent, de = y.cameras;
        G(y, te);
        for (let oe = 0; oe < de.length; oe++) G(de[oe], te);
        de.length === 2 ? U(y, w, A) : y.projectionMatrix.copy(w.projectionMatrix), V(q, y, te);
      };
      function V(q, te, de) {
        de === null ? q.matrix.copy(te.matrixWorld) : (q.matrix.copy(de.matrixWorld), q.matrix.invert(), q.matrix.multiply(te.matrixWorld)), q.matrix.decompose(q.position, q.quaternion, q.scale), q.updateMatrixWorld(true), q.projectionMatrix.copy(te.projectionMatrix), q.projectionMatrixInverse.copy(te.projectionMatrixInverse), q.isPerspectiveCamera && (q.fov = ur * 2 * Math.atan(1 / q.projectionMatrix.elements[5]), q.zoom = 1);
      }
      this.getCamera = function() {
        return y;
      }, this.getFoveation = function() {
        if (!(h === null && f === null)) return l;
      }, this.setFoveation = function(q) {
        l = q, h !== null && (h.fixedFoveation = q), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = q);
      }, this.hasDepthSensing = function() {
        return v.texture !== null;
      };
      let K = null;
      function ce(q, te) {
        if (u = te.getViewerPose(c || o), m = te, u !== null) {
          const de = u.views;
          f !== null && (e.setRenderTargetFramebuffer(_, f.framebuffer), e.setRenderTarget(_));
          let oe = false;
          de.length !== y.cameras.length && (y.cameras.length = 0, oe = true);
          for (let be = 0; be < de.length; be++) {
            const F = de[be];
            let Le = null;
            if (f !== null) Le = f.getViewport(F);
            else {
              const ie = d.getViewSubImage(h, F);
              Le = ie.viewport, be === 0 && (e.setRenderTargetTextures(_, ie.colorTexture, h.ignoreDepthValues ? void 0 : ie.depthStencilTexture), e.setRenderTarget(_));
            }
            let J = M[be];
            J === void 0 && (J = new Et(), J.layers.enable(be), J.viewport = new rt(), M[be] = J), J.matrix.fromArray(F.transform.matrix), J.matrix.decompose(J.position, J.quaternion, J.scale), J.projectionMatrix.fromArray(F.projectionMatrix), J.projectionMatrixInverse.copy(J.projectionMatrix).invert(), J.viewport.set(Le.x, Le.y, Le.width, Le.height), be === 0 && (y.matrix.copy(J.matrix), y.matrix.decompose(y.position, y.quaternion, y.scale)), oe === true && y.cameras.push(J);
          }
          const fe = i.enabledFeatures;
          if (fe && fe.includes("depth-sensing")) {
            const be = d.getDepthInformation(de[0]);
            be && be.isValid && be.texture && v.init(e, be, i.renderState);
          }
        }
        for (let de = 0; de < x.length; de++) {
          const oe = b[de], fe = x[de];
          oe !== null && fe !== void 0 && fe.update(oe, te, c || o);
        }
        v.render(e, y), K && K(q, te), te.detectedPlanes && n.dispatchEvent({
          type: "planesdetected",
          data: te
        }), m = null;
      }
      const Te = new Bm();
      Te.setAnimationLoop(ce), this.setAnimationLoop = function(q) {
        K = q;
      }, this.dispose = function() {
      };
    }
  }
  const ns = new mn(), Cb = new De();
  function Rb(s, e) {
    function t(g, p) {
      g.matrixAutoUpdate === true && g.updateMatrix(), p.value.copy(g.matrix);
    }
    function n(g, p) {
      p.color.getRGB(g.fogColor.value, Um(s)), p.isFog ? (g.fogNear.value = p.near, g.fogFar.value = p.far) : p.isFogExp2 && (g.fogDensity.value = p.density);
    }
    function i(g, p, _, x, b) {
      p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(g, p) : p.isMeshToonMaterial ? (r(g, p), d(g, p)) : p.isMeshPhongMaterial ? (r(g, p), u(g, p)) : p.isMeshStandardMaterial ? (r(g, p), h(g, p), p.isMeshPhysicalMaterial && f(g, p, b)) : p.isMeshMatcapMaterial ? (r(g, p), m(g, p)) : p.isMeshDepthMaterial ? r(g, p) : p.isMeshDistanceMaterial ? (r(g, p), v(g, p)) : p.isMeshNormalMaterial ? r(g, p) : p.isLineBasicMaterial ? (o(g, p), p.isLineDashedMaterial && a(g, p)) : p.isPointsMaterial ? l(g, p, _, x) : p.isSpriteMaterial ? c(g, p) : p.isShadowMaterial ? (g.color.value.copy(p.color), g.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = false);
    }
    function r(g, p) {
      g.opacity.value = p.opacity, p.color && g.diffuse.value.copy(p.color), p.emissive && g.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (g.map.value = p.map, t(p.map, g.mapTransform)), p.alphaMap && (g.alphaMap.value = p.alphaMap, t(p.alphaMap, g.alphaMapTransform)), p.bumpMap && (g.bumpMap.value = p.bumpMap, t(p.bumpMap, g.bumpMapTransform), g.bumpScale.value = p.bumpScale, p.side === Zt && (g.bumpScale.value *= -1)), p.normalMap && (g.normalMap.value = p.normalMap, t(p.normalMap, g.normalMapTransform), g.normalScale.value.copy(p.normalScale), p.side === Zt && g.normalScale.value.negate()), p.displacementMap && (g.displacementMap.value = p.displacementMap, t(p.displacementMap, g.displacementMapTransform), g.displacementScale.value = p.displacementScale, g.displacementBias.value = p.displacementBias), p.emissiveMap && (g.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, g.emissiveMapTransform)), p.specularMap && (g.specularMap.value = p.specularMap, t(p.specularMap, g.specularMapTransform)), p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
      const _ = e.get(p), x = _.envMap, b = _.envMapRotation;
      if (x && (g.envMap.value = x, ns.copy(b), ns.x *= -1, ns.y *= -1, ns.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === false && (ns.y *= -1, ns.z *= -1), g.envMapRotation.value.setFromMatrix4(Cb.makeRotationFromEuler(ns)), g.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = p.reflectivity, g.ior.value = p.ior, g.refractionRatio.value = p.refractionRatio), p.lightMap) {
        g.lightMap.value = p.lightMap;
        const E = s._useLegacyLights === true ? Math.PI : 1;
        g.lightMapIntensity.value = p.lightMapIntensity * E, t(p.lightMap, g.lightMapTransform);
      }
      p.aoMap && (g.aoMap.value = p.aoMap, g.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, g.aoMapTransform));
    }
    function o(g, p) {
      g.diffuse.value.copy(p.color), g.opacity.value = p.opacity, p.map && (g.map.value = p.map, t(p.map, g.mapTransform));
    }
    function a(g, p) {
      g.dashSize.value = p.dashSize, g.totalSize.value = p.dashSize + p.gapSize, g.scale.value = p.scale;
    }
    function l(g, p, _, x) {
      g.diffuse.value.copy(p.color), g.opacity.value = p.opacity, g.size.value = p.size * _, g.scale.value = x * 0.5, p.map && (g.map.value = p.map, t(p.map, g.uvTransform)), p.alphaMap && (g.alphaMap.value = p.alphaMap, t(p.alphaMap, g.alphaMapTransform)), p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
    }
    function c(g, p) {
      g.diffuse.value.copy(p.color), g.opacity.value = p.opacity, g.rotation.value = p.rotation, p.map && (g.map.value = p.map, t(p.map, g.mapTransform)), p.alphaMap && (g.alphaMap.value = p.alphaMap, t(p.alphaMap, g.alphaMapTransform)), p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
    }
    function u(g, p) {
      g.specular.value.copy(p.specular), g.shininess.value = Math.max(p.shininess, 1e-4);
    }
    function d(g, p) {
      p.gradientMap && (g.gradientMap.value = p.gradientMap);
    }
    function h(g, p) {
      g.metalness.value = p.metalness, p.metalnessMap && (g.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, g.metalnessMapTransform)), g.roughness.value = p.roughness, p.roughnessMap && (g.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, g.roughnessMapTransform)), p.envMap && (g.envMapIntensity.value = p.envMapIntensity);
    }
    function f(g, p, _) {
      g.ior.value = p.ior, p.sheen > 0 && (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), g.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (g.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, g.sheenColorMapTransform)), p.sheenRoughnessMap && (g.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, g.sheenRoughnessMapTransform))), p.clearcoat > 0 && (g.clearcoat.value = p.clearcoat, g.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (g.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, g.clearcoatMapTransform)), p.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (g.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === Zt && g.clearcoatNormalScale.value.negate())), p.dispersion > 0 && (g.dispersion.value = p.dispersion), p.iridescence > 0 && (g.iridescence.value = p.iridescence, g.iridescenceIOR.value = p.iridescenceIOR, g.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (g.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, g.iridescenceMapTransform)), p.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), p.transmission > 0 && (g.transmission.value = p.transmission, g.transmissionSamplerMap.value = _.texture, g.transmissionSamplerSize.value.set(_.width, _.height), p.transmissionMap && (g.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, g.transmissionMapTransform)), g.thickness.value = p.thickness, p.thicknessMap && (g.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = p.attenuationDistance, g.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (g.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (g.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = p.specularIntensity, g.specularColor.value.copy(p.specularColor), p.specularColorMap && (g.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, g.specularColorMapTransform)), p.specularIntensityMap && (g.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, g.specularIntensityMapTransform));
    }
    function m(g, p) {
      p.matcap && (g.matcap.value = p.matcap);
    }
    function v(g, p) {
      const _ = e.get(p).light;
      g.referencePosition.value.setFromMatrixPosition(_.matrixWorld), g.nearDistance.value = _.shadow.camera.near, g.farDistance.value = _.shadow.camera.far;
    }
    return {
      refreshFogUniforms: n,
      refreshMaterialUniforms: i
    };
  }
  function Pb(s, e, t, n) {
    let i = {}, r = {}, o = [];
    const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(_, x) {
      const b = x.program;
      n.uniformBlockBinding(_, b);
    }
    function c(_, x) {
      let b = i[_.id];
      b === void 0 && (m(_), b = u(_), i[_.id] = b, _.addEventListener("dispose", g));
      const E = x.program;
      n.updateUBOMapping(_, E);
      const S = e.render.frame;
      r[_.id] !== S && (h(_), r[_.id] = S);
    }
    function u(_) {
      const x = d();
      _.__bindingPointIndex = x;
      const b = s.createBuffer(), E = _.__size, S = _.usage;
      return s.bindBuffer(s.UNIFORM_BUFFER, b), s.bufferData(s.UNIFORM_BUFFER, E, S), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, x, b), b;
    }
    function d() {
      for (let _ = 0; _ < a; _++) if (o.indexOf(_) === -1) return o.push(_), _;
      return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
    }
    function h(_) {
      const x = i[_.id], b = _.uniforms, E = _.__cache;
      s.bindBuffer(s.UNIFORM_BUFFER, x);
      for (let S = 0, w = b.length; S < w; S++) {
        const A = Array.isArray(b[S]) ? b[S] : [
          b[S]
        ];
        for (let M = 0, y = A.length; M < y; M++) {
          const C = A[M];
          if (f(C, S, M, E) === true) {
            const N = C.__offset, I = Array.isArray(C.value) ? C.value : [
              C.value
            ];
            let D = 0;
            for (let O = 0; O < I.length; O++) {
              const z = I[O], B = v(z);
              typeof z == "number" || typeof z == "boolean" ? (C.__data[0] = z, s.bufferSubData(s.UNIFORM_BUFFER, N + D, C.__data)) : z.isMatrix3 ? (C.__data[0] = z.elements[0], C.__data[1] = z.elements[1], C.__data[2] = z.elements[2], C.__data[3] = 0, C.__data[4] = z.elements[3], C.__data[5] = z.elements[4], C.__data[6] = z.elements[5], C.__data[7] = 0, C.__data[8] = z.elements[6], C.__data[9] = z.elements[7], C.__data[10] = z.elements[8], C.__data[11] = 0) : (z.toArray(C.__data, D), D += B.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            s.bufferSubData(s.UNIFORM_BUFFER, N, C.__data);
          }
        }
      }
      s.bindBuffer(s.UNIFORM_BUFFER, null);
    }
    function f(_, x, b, E) {
      const S = _.value, w = x + "_" + b;
      if (E[w] === void 0) return typeof S == "number" || typeof S == "boolean" ? E[w] = S : E[w] = S.clone(), true;
      {
        const A = E[w];
        if (typeof S == "number" || typeof S == "boolean") {
          if (A !== S) return E[w] = S, true;
        } else if (A.equals(S) === false) return A.copy(S), true;
      }
      return false;
    }
    function m(_) {
      const x = _.uniforms;
      let b = 0;
      const E = 16;
      for (let w = 0, A = x.length; w < A; w++) {
        const M = Array.isArray(x[w]) ? x[w] : [
          x[w]
        ];
        for (let y = 0, C = M.length; y < C; y++) {
          const N = M[y], I = Array.isArray(N.value) ? N.value : [
            N.value
          ];
          for (let D = 0, O = I.length; D < O; D++) {
            const z = I[D], B = v(z), U = b % E;
            U !== 0 && E - U < B.boundary && (b += E - U), N.__data = new Float32Array(B.storage / Float32Array.BYTES_PER_ELEMENT), N.__offset = b, b += B.storage;
          }
        }
      }
      const S = b % E;
      return S > 0 && (b += E - S), _.__size = b, _.__cache = {}, this;
    }
    function v(_) {
      const x = {
        boundary: 0,
        storage: 0
      };
      return typeof _ == "number" || typeof _ == "boolean" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x;
    }
    function g(_) {
      const x = _.target;
      x.removeEventListener("dispose", g);
      const b = o.indexOf(x.__bindingPointIndex);
      o.splice(b, 1), s.deleteBuffer(i[x.id]), delete i[x.id], delete r[x.id];
    }
    function p() {
      for (const _ in i) s.deleteBuffer(i[_]);
      o = [], i = {}, r = {};
    }
    return {
      bind: l,
      update: c,
      dispose: p
    };
  }
  class qm {
    constructor(e = {}) {
      const { canvas: t = Pm(), context: n = null, depth: i = true, stencil: r = false, alpha: o = false, antialias: a = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: u = "default", failIfMajorPerformanceCaveat: d = false } = e;
      this.isWebGLRenderer = true;
      let h;
      if (n !== null) {
        if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
        h = n.getContextAttributes().alpha;
      } else h = o;
      const f = new Uint32Array(4), m = new Int32Array(4);
      let v = null, g = null;
      const p = [], _ = [];
      this.domElement = t, this.debug = {
        checkShaderErrors: true,
        onShaderError: null
      }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Mn, this._useLegacyLights = false, this.toneMapping = fi, this.toneMappingExposure = 1;
      const x = this;
      let b = false, E = 0, S = 0, w = null, A = -1, M = null;
      const y = new rt(), C = new rt();
      let N = null;
      const I = new ye(0);
      let D = 0, O = t.width, z = t.height, B = 1, U = null, G = null;
      const V = new rt(0, 0, O, z), K = new rt(0, 0, O, z);
      let ce = false;
      const Te = new Oo();
      let q = false, te = false;
      const de = new De(), oe = new P(), fe = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
      };
      function be() {
        return w === null ? B : 1;
      }
      let F = n;
      function Le(R, H) {
        return t.getContext(R, H);
      }
      try {
        const R = {
          alpha: true,
          depth: i,
          stencil: r,
          antialias: a,
          premultipliedAlpha: l,
          preserveDrawingBuffer: c,
          powerPreference: u,
          failIfMajorPerformanceCaveat: d
        };
        if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${vl}`), t.addEventListener("webglcontextlost", k, false), t.addEventListener("webglcontextrestored", re, false), t.addEventListener("webglcontextcreationerror", j, false), F === null) {
          const H = "webgl2";
          if (F = Le(H, R), F === null) throw Le(H) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
      } catch (R) {
        throw console.error("THREE.WebGLRenderer: " + R.message), R;
      }
      let J, ie, Z, le, se, ve, Ce, L, T, W, Q, ae, ne, Ie, ge, me, ke, he, Pe, Ze, Ne, we, Xe, Je;
      function vt() {
        J = new Gy(F), J.init(), we = new Xm(F, J), ie = new zy(F, J, e, we), Z = new Mb(F), le = new Yy(F), se = new cb(), ve = new bb(F, J, Z, se, ie, we, le), Ce = new By(x), L = new Hy(x), T = new Qv(F), Xe = new Uy(F, T), W = new Wy(F, T, le, Xe), Q = new $y(F, W, T, le), Pe = new qy(F, ie, ve), me = new Fy(se), ae = new lb(x, Ce, L, J, ie, Xe, me), ne = new Rb(x, se), Ie = new ub(), ge = new vb(J), he = new Ny(x, Ce, L, Z, Q, h, l), ke = new yb(x, Q, ie), Je = new Pb(F, le, ie, Z), Ze = new Oy(F, J, le), Ne = new Xy(F, J, le), le.programs = ae.programs, x.capabilities = ie, x.extensions = J, x.properties = se, x.renderLists = Ie, x.shadowMap = ke, x.state = Z, x.info = le;
      }
      vt();
      const Ye = new Ab(x, F);
      this.xr = Ye, this.getContext = function() {
        return F;
      }, this.getContextAttributes = function() {
        return F.getContextAttributes();
      }, this.forceContextLoss = function() {
        const R = J.get("WEBGL_lose_context");
        R && R.loseContext();
      }, this.forceContextRestore = function() {
        const R = J.get("WEBGL_lose_context");
        R && R.restoreContext();
      }, this.getPixelRatio = function() {
        return B;
      }, this.setPixelRatio = function(R) {
        R !== void 0 && (B = R, this.setSize(O, z, false));
      }, this.getSize = function(R) {
        return R.set(O, z);
      }, this.setSize = function(R, H, $ = true) {
        if (Ye.isPresenting) {
          console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          return;
        }
        O = R, z = H, t.width = Math.floor(R * B), t.height = Math.floor(H * B), $ === true && (t.style.width = R + "px", t.style.height = H + "px"), this.setViewport(0, 0, R, H);
      }, this.getDrawingBufferSize = function(R) {
        return R.set(O * B, z * B).floor();
      }, this.setDrawingBufferSize = function(R, H, $) {
        O = R, z = H, B = $, t.width = Math.floor(R * $), t.height = Math.floor(H * $), this.setViewport(0, 0, R, H);
      }, this.getCurrentViewport = function(R) {
        return R.copy(y);
      }, this.getViewport = function(R) {
        return R.copy(V);
      }, this.setViewport = function(R, H, $, X) {
        R.isVector4 ? V.set(R.x, R.y, R.z, R.w) : V.set(R, H, $, X), Z.viewport(y.copy(V).multiplyScalar(B).round());
      }, this.getScissor = function(R) {
        return R.copy(K);
      }, this.setScissor = function(R, H, $, X) {
        R.isVector4 ? K.set(R.x, R.y, R.z, R.w) : K.set(R, H, $, X), Z.scissor(C.copy(K).multiplyScalar(B).round());
      }, this.getScissorTest = function() {
        return ce;
      }, this.setScissorTest = function(R) {
        Z.setScissorTest(ce = R);
      }, this.setOpaqueSort = function(R) {
        U = R;
      }, this.setTransparentSort = function(R) {
        G = R;
      }, this.getClearColor = function(R) {
        return R.copy(he.getClearColor());
      }, this.setClearColor = function() {
        he.setClearColor.apply(he, arguments);
      }, this.getClearAlpha = function() {
        return he.getClearAlpha();
      }, this.setClearAlpha = function() {
        he.setClearAlpha.apply(he, arguments);
      }, this.clear = function(R = true, H = true, $ = true) {
        let X = 0;
        if (R) {
          let Y = false;
          if (w !== null) {
            const _e = w.texture.format;
            Y = _e === au || _e === ou || _e === ru;
          }
          if (Y) {
            const _e = w.texture.type, Ae = _e === vi || _e === Ts || _e === eu || _e === _r || _e === nu || _e === iu, Re = he.getClearColor(), Ue = he.getClearAlpha(), Oe = Re.r, Ge = Re.g, $e = Re.b;
            Ae ? (f[0] = Oe, f[1] = Ge, f[2] = $e, f[3] = Ue, F.clearBufferuiv(F.COLOR, 0, f)) : (m[0] = Oe, m[1] = Ge, m[2] = $e, m[3] = Ue, F.clearBufferiv(F.COLOR, 0, m));
          } else X |= F.COLOR_BUFFER_BIT;
        }
        H && (X |= F.DEPTH_BUFFER_BIT), $ && (X |= F.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), F.clear(X);
      }, this.clearColor = function() {
        this.clear(true, false, false);
      }, this.clearDepth = function() {
        this.clear(false, true, false);
      }, this.clearStencil = function() {
        this.clear(false, false, true);
      }, this.dispose = function() {
        t.removeEventListener("webglcontextlost", k, false), t.removeEventListener("webglcontextrestored", re, false), t.removeEventListener("webglcontextcreationerror", j, false), Ie.dispose(), ge.dispose(), se.dispose(), Ce.dispose(), L.dispose(), Q.dispose(), Xe.dispose(), Je.dispose(), ae.dispose(), Ye.dispose(), Ye.removeEventListener("sessionstart", it), Ye.removeEventListener("sessionend", Hn), Gt.stop();
      };
      function k(R) {
        R.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = true;
      }
      function re() {
        console.log("THREE.WebGLRenderer: Context Restored."), b = false;
        const R = le.autoReset, H = ke.enabled, $ = ke.autoUpdate, X = ke.needsUpdate, Y = ke.type;
        vt(), le.autoReset = R, ke.enabled = H, ke.autoUpdate = $, ke.needsUpdate = X, ke.type = Y;
      }
      function j(R) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", R.statusMessage);
      }
      function xe(R) {
        const H = R.target;
        H.removeEventListener("dispose", xe), Me(H);
      }
      function Me(R) {
        je(R), se.remove(R);
      }
      function je(R) {
        const H = se.get(R).programs;
        H !== void 0 && (H.forEach(function($) {
          ae.releaseProgram($);
        }), R.isShaderMaterial && ae.releaseShaderCache(R));
      }
      this.renderBufferDirect = function(R, H, $, X, Y, _e) {
        H === null && (H = fe);
        const Ae = Y.isMesh && Y.matrixWorld.determinant() < 0, Re = p0(R, H, $, X, Y);
        Z.setMaterial(X, Ae);
        let Ue = $.index, Oe = 1;
        if (X.wireframe === true) {
          if (Ue = W.getWireframeAttribute($), Ue === void 0) return;
          Oe = 2;
        }
        const Ge = $.drawRange, $e = $.attributes.position;
        let _t = Ge.start * Oe, Nt = (Ge.start + Ge.count) * Oe;
        _e !== null && (_t = Math.max(_t, _e.start * Oe), Nt = Math.min(Nt, (_e.start + _e.count) * Oe)), Ue !== null ? (_t = Math.max(_t, 0), Nt = Math.min(Nt, Ue.count)) : $e != null && (_t = Math.max(_t, 0), Nt = Math.min(Nt, $e.count));
        const rn = Nt - _t;
        if (rn < 0 || rn === 1 / 0) return;
        Xe.setup(Y, X, Re, $, Ue);
        let ei, nt = Ze;
        if (Ue !== null && (ei = T.get(Ue), nt = Ne, nt.setIndex(ei)), Y.isMesh) X.wireframe === true ? (Z.setLineWidth(X.wireframeLinewidth * be()), nt.setMode(F.LINES)) : nt.setMode(F.TRIANGLES);
        else if (Y.isLine) {
          let ze = X.linewidth;
          ze === void 0 && (ze = 1), Z.setLineWidth(ze * be()), Y.isLineSegments ? nt.setMode(F.LINES) : Y.isLineLoop ? nt.setMode(F.LINE_LOOP) : nt.setMode(F.LINE_STRIP);
        } else Y.isPoints ? nt.setMode(F.POINTS) : Y.isSprite && nt.setMode(F.TRIANGLES);
        if (Y.isBatchedMesh) Y._multiDrawInstances !== null ? nt.renderMultiDrawInstances(Y._multiDrawStarts, Y._multiDrawCounts, Y._multiDrawCount, Y._multiDrawInstances) : nt.renderMultiDraw(Y._multiDrawStarts, Y._multiDrawCounts, Y._multiDrawCount);
        else if (Y.isInstancedMesh) nt.renderInstances(_t, rn, Y.count);
        else if ($.isInstancedBufferGeometry) {
          const ze = $._maxInstanceCount !== void 0 ? $._maxInstanceCount : 1 / 0, Ar = Math.min($.instanceCount, ze);
          nt.renderInstances(_t, rn, Ar);
        } else nt.render(_t, rn);
      };
      function ct(R, H, $) {
        R.transparent === true && R.side === Qt && R.forceSinglePass === false ? (R.side = Zt, R.needsUpdate = true, Yo(R, H, $), R.side = mi, R.needsUpdate = true, Yo(R, H, $), R.side = Qt) : Yo(R, H, $);
      }
      this.compile = function(R, H, $ = null) {
        $ === null && ($ = R), g = ge.get($), g.init(H), _.push(g), $.traverseVisible(function(Y) {
          Y.isLight && Y.layers.test(H.layers) && (g.pushLight(Y), Y.castShadow && g.pushShadow(Y));
        }), R !== $ && R.traverseVisible(function(Y) {
          Y.isLight && Y.layers.test(H.layers) && (g.pushLight(Y), Y.castShadow && g.pushShadow(Y));
        }), g.setupLights(x._useLegacyLights);
        const X = /* @__PURE__ */ new Set();
        return R.traverse(function(Y) {
          const _e = Y.material;
          if (_e) if (Array.isArray(_e)) for (let Ae = 0; Ae < _e.length; Ae++) {
            const Re = _e[Ae];
            ct(Re, $, Y), X.add(Re);
          }
          else ct(_e, $, Y), X.add(_e);
        }), _.pop(), g = null, X;
      }, this.compileAsync = function(R, H, $ = null) {
        const X = this.compile(R, H, $);
        return new Promise((Y) => {
          function _e() {
            if (X.forEach(function(Ae) {
              se.get(Ae).currentProgram.isReady() && X.delete(Ae);
            }), X.size === 0) {
              Y(R);
              return;
            }
            setTimeout(_e, 10);
          }
          J.get("KHR_parallel_shader_compile") !== null ? _e() : setTimeout(_e, 10);
        });
      };
      let ft = null;
      function Dt(R) {
        ft && ft(R);
      }
      function it() {
        Gt.stop();
      }
      function Hn() {
        Gt.start();
      }
      const Gt = new Bm();
      Gt.setAnimationLoop(Dt), typeof self < "u" && Gt.setContext(self), this.setAnimationLoop = function(R) {
        ft = R, Ye.setAnimationLoop(R), R === null ? Gt.stop() : Gt.start();
      }, Ye.addEventListener("sessionstart", it), Ye.addEventListener("sessionend", Hn), this.render = function(R, H) {
        if (H !== void 0 && H.isCamera !== true) {
          console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          return;
        }
        if (b === true) return;
        R.matrixWorldAutoUpdate === true && R.updateMatrixWorld(), H.parent === null && H.matrixWorldAutoUpdate === true && H.updateMatrixWorld(), Ye.enabled === true && Ye.isPresenting === true && (Ye.cameraAutoUpdate === true && Ye.updateCamera(H), H = Ye.getCamera()), R.isScene === true && R.onBeforeRender(x, R, H, w), g = ge.get(R, _.length), g.init(H), _.push(g), de.multiplyMatrices(H.projectionMatrix, H.matrixWorldInverse), Te.setFromProjectionMatrix(de), te = this.localClippingEnabled, q = me.init(this.clippingPlanes, te), v = Ie.get(R, p.length), v.init(), p.push(v), Ju(R, H, 0, x.sortObjects), v.finish(), x.sortObjects === true && v.sort(U, G);
        const $ = Ye.enabled === false || Ye.isPresenting === false || Ye.hasDepthSensing() === false;
        $ && he.addToRenderList(v, R), this.info.render.frame++, q === true && me.beginShadows();
        const X = g.state.shadowsArray;
        ke.render(X, R, H), q === true && me.endShadows(), this.info.autoReset === true && this.info.reset();
        const Y = v.opaque, _e = v.transmissive;
        if (g.setupLights(x._useLegacyLights), H.isArrayCamera) {
          const Ae = H.cameras;
          if (_e.length > 0) for (let Re = 0, Ue = Ae.length; Re < Ue; Re++) {
            const Oe = Ae[Re];
            ju(Y, _e, R, Oe);
          }
          $ && he.render(R);
          for (let Re = 0, Ue = Ae.length; Re < Ue; Re++) {
            const Oe = Ae[Re];
            Ku(v, R, Oe, Oe.viewport);
          }
        } else _e.length > 0 && ju(Y, _e, R, H), $ && he.render(R), Ku(v, R, H);
        w !== null && (ve.updateMultisampleRenderTarget(w), ve.updateRenderTargetMipmap(w)), R.isScene === true && R.onAfterRender(x, R, H), Xe.resetDefaultState(), A = -1, M = null, _.pop(), _.length > 0 ? (g = _[_.length - 1], q === true && me.setGlobalState(x.clippingPlanes, g.state.camera)) : g = null, p.pop(), p.length > 0 ? v = p[p.length - 1] : v = null;
      };
      function Ju(R, H, $, X) {
        if (R.visible === false) return;
        if (R.layers.test(H.layers)) {
          if (R.isGroup) $ = R.renderOrder;
          else if (R.isLOD) R.autoUpdate === true && R.update(H);
          else if (R.isLight) g.pushLight(R), R.castShadow && g.pushShadow(R);
          else if (R.isSprite) {
            if (!R.frustumCulled || Te.intersectsSprite(R)) {
              X && oe.setFromMatrixPosition(R.matrixWorld).applyMatrix4(de);
              const Ae = Q.update(R), Re = R.material;
              Re.visible && v.push(R, Ae, Re, $, oe.z, null);
            }
          } else if ((R.isMesh || R.isLine || R.isPoints) && (!R.frustumCulled || Te.intersectsObject(R))) {
            const Ae = Q.update(R), Re = R.material;
            if (X && (R.boundingSphere !== void 0 ? (R.boundingSphere === null && R.computeBoundingSphere(), oe.copy(R.boundingSphere.center)) : (Ae.boundingSphere === null && Ae.computeBoundingSphere(), oe.copy(Ae.boundingSphere.center)), oe.applyMatrix4(R.matrixWorld).applyMatrix4(de)), Array.isArray(Re)) {
              const Ue = Ae.groups;
              for (let Oe = 0, Ge = Ue.length; Oe < Ge; Oe++) {
                const $e = Ue[Oe], _t = Re[$e.materialIndex];
                _t && _t.visible && v.push(R, Ae, _t, $, oe.z, $e);
              }
            } else Re.visible && v.push(R, Ae, Re, $, oe.z, null);
          }
        }
        const _e = R.children;
        for (let Ae = 0, Re = _e.length; Ae < Re; Ae++) Ju(_e[Ae], H, $, X);
      }
      function Ku(R, H, $, X) {
        const Y = R.opaque, _e = R.transmissive, Ae = R.transparent;
        g.setupLightsView($), q === true && me.setGlobalState(x.clippingPlanes, $), X && Z.viewport(y.copy(X)), Y.length > 0 && Xo(Y, H, $), _e.length > 0 && Xo(_e, H, $), Ae.length > 0 && Xo(Ae, H, $), Z.buffers.depth.setTest(true), Z.buffers.depth.setMask(true), Z.buffers.color.setMask(true), Z.setPolygonOffset(false);
      }
      function ju(R, H, $, X) {
        if (($.isScene === true ? $.overrideMaterial : null) !== null) return;
        g.state.transmissionRenderTarget[X.id] === void 0 && (g.state.transmissionRenderTarget[X.id] = new zn(1, 1, {
          generateMipmaps: true,
          type: J.has("EXT_color_buffer_half_float") || J.has("EXT_color_buffer_float") ? Do : vi,
          minFilter: Xn,
          samples: 4,
          stencilBuffer: r,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false
        }));
        const _e = g.state.transmissionRenderTarget[X.id], Ae = X.viewport || y;
        _e.setSize(Ae.z, Ae.w);
        const Re = x.getRenderTarget();
        x.setRenderTarget(_e), x.getClearColor(I), D = x.getClearAlpha(), D < 1 && x.setClearColor(16777215, 0.5), x.clear();
        const Ue = x.toneMapping;
        x.toneMapping = fi;
        const Oe = X.viewport;
        if (X.viewport !== void 0 && (X.viewport = void 0), g.setupLightsView(X), q === true && me.setGlobalState(x.clippingPlanes, X), Xo(R, $, X), ve.updateMultisampleRenderTarget(_e), ve.updateRenderTargetMipmap(_e), J.has("WEBGL_multisampled_render_to_texture") === false) {
          let Ge = false;
          for (let $e = 0, _t = H.length; $e < _t; $e++) {
            const Nt = H[$e], rn = Nt.object, ei = Nt.geometry, nt = Nt.material, ze = Nt.group;
            if (nt.side === Qt && rn.layers.test(X.layers)) {
              const Ar = nt.side;
              nt.side = Zt, nt.needsUpdate = true, Qu(rn, $, X, ei, nt, ze), nt.side = Ar, nt.needsUpdate = true, Ge = true;
            }
          }
          Ge === true && (ve.updateMultisampleRenderTarget(_e), ve.updateRenderTargetMipmap(_e));
        }
        x.setRenderTarget(Re), x.setClearColor(I, D), Oe !== void 0 && (X.viewport = Oe), x.toneMapping = Ue;
      }
      function Xo(R, H, $) {
        const X = H.isScene === true ? H.overrideMaterial : null;
        for (let Y = 0, _e = R.length; Y < _e; Y++) {
          const Ae = R[Y], Re = Ae.object, Ue = Ae.geometry, Oe = X === null ? Ae.material : X, Ge = Ae.group;
          Re.layers.test($.layers) && Qu(Re, H, $, Ue, Oe, Ge);
        }
      }
      function Qu(R, H, $, X, Y, _e) {
        R.onBeforeRender(x, H, $, X, Y, _e), R.modelViewMatrix.multiplyMatrices($.matrixWorldInverse, R.matrixWorld), R.normalMatrix.getNormalMatrix(R.modelViewMatrix), Y.onBeforeRender(x, H, $, X, R, _e), Y.transparent === true && Y.side === Qt && Y.forceSinglePass === false ? (Y.side = Zt, Y.needsUpdate = true, x.renderBufferDirect($, H, X, Y, R, _e), Y.side = mi, Y.needsUpdate = true, x.renderBufferDirect($, H, X, Y, R, _e), Y.side = Qt) : x.renderBufferDirect($, H, X, Y, R, _e), R.onAfterRender(x, H, $, X, Y, _e);
      }
      function Yo(R, H, $) {
        H.isScene !== true && (H = fe);
        const X = se.get(R), Y = g.state.lights, _e = g.state.shadowsArray, Ae = Y.state.version, Re = ae.getParameters(R, Y.state, _e, H, $), Ue = ae.getProgramCacheKey(Re);
        let Oe = X.programs;
        X.environment = R.isMeshStandardMaterial ? H.environment : null, X.fog = H.fog, X.envMap = (R.isMeshStandardMaterial ? L : Ce).get(R.envMap || X.environment), X.envMapRotation = X.environment !== null && R.envMap === null ? H.environmentRotation : R.envMapRotation, Oe === void 0 && (R.addEventListener("dispose", xe), Oe = /* @__PURE__ */ new Map(), X.programs = Oe);
        let Ge = Oe.get(Ue);
        if (Ge !== void 0) {
          if (X.currentProgram === Ge && X.lightsStateVersion === Ae) return td(R, Re), Ge;
        } else Re.uniforms = ae.getUniforms(R), R.onBuild($, Re, x), R.onBeforeCompile(Re, x), Ge = ae.acquireProgram(Re, Ue), Oe.set(Ue, Ge), X.uniforms = Re.uniforms;
        const $e = X.uniforms;
        return (!R.isShaderMaterial && !R.isRawShaderMaterial || R.clipping === true) && ($e.clippingPlanes = me.uniform), td(R, Re), X.needsLights = g0(R), X.lightsStateVersion = Ae, X.needsLights && ($e.ambientLightColor.value = Y.state.ambient, $e.lightProbe.value = Y.state.probe, $e.directionalLights.value = Y.state.directional, $e.directionalLightShadows.value = Y.state.directionalShadow, $e.spotLights.value = Y.state.spot, $e.spotLightShadows.value = Y.state.spotShadow, $e.rectAreaLights.value = Y.state.rectArea, $e.ltc_1.value = Y.state.rectAreaLTC1, $e.ltc_2.value = Y.state.rectAreaLTC2, $e.pointLights.value = Y.state.point, $e.pointLightShadows.value = Y.state.pointShadow, $e.hemisphereLights.value = Y.state.hemi, $e.directionalShadowMap.value = Y.state.directionalShadowMap, $e.directionalShadowMatrix.value = Y.state.directionalShadowMatrix, $e.spotShadowMap.value = Y.state.spotShadowMap, $e.spotLightMatrix.value = Y.state.spotLightMatrix, $e.spotLightMap.value = Y.state.spotLightMap, $e.pointShadowMap.value = Y.state.pointShadowMap, $e.pointShadowMatrix.value = Y.state.pointShadowMatrix), X.currentProgram = Ge, X.uniformsList = null, Ge;
      }
      function ed(R) {
        if (R.uniformsList === null) {
          const H = R.currentProgram.getUniforms();
          R.uniformsList = Ya.seqWithValue(H.seq, R.uniforms);
        }
        return R.uniformsList;
      }
      function td(R, H) {
        const $ = se.get(R);
        $.outputColorSpace = H.outputColorSpace, $.batching = H.batching, $.instancing = H.instancing, $.instancingColor = H.instancingColor, $.instancingMorph = H.instancingMorph, $.skinning = H.skinning, $.morphTargets = H.morphTargets, $.morphNormals = H.morphNormals, $.morphColors = H.morphColors, $.morphTargetsCount = H.morphTargetsCount, $.numClippingPlanes = H.numClippingPlanes, $.numIntersection = H.numClipIntersection, $.vertexAlphas = H.vertexAlphas, $.vertexTangents = H.vertexTangents, $.toneMapping = H.toneMapping;
      }
      function p0(R, H, $, X, Y) {
        H.isScene !== true && (H = fe), ve.resetTextureUnits();
        const _e = H.fog, Ae = X.isMeshStandardMaterial ? H.environment : null, Re = w === null ? x.outputColorSpace : w.isXRRenderTarget === true ? w.texture.colorSpace : yi, Ue = (X.isMeshStandardMaterial ? L : Ce).get(X.envMap || Ae), Oe = X.vertexColors === true && !!$.attributes.color && $.attributes.color.itemSize === 4, Ge = !!$.attributes.tangent && (!!X.normalMap || X.anisotropy > 0), $e = !!$.morphAttributes.position, _t = !!$.morphAttributes.normal, Nt = !!$.morphAttributes.color;
        let rn = fi;
        X.toneMapped && (w === null || w.isXRRenderTarget === true) && (rn = x.toneMapping);
        const ei = $.morphAttributes.position || $.morphAttributes.normal || $.morphAttributes.color, nt = ei !== void 0 ? ei.length : 0, ze = se.get(X), Ar = g.state.lights;
        if (q === true && (te === true || R !== M)) {
          const gn = R === M && X.id === A;
          me.setState(X, R, gn);
        }
        let ut = false;
        X.version === ze.__version ? (ze.needsLights && ze.lightsStateVersion !== Ar.state.version || ze.outputColorSpace !== Re || Y.isBatchedMesh && ze.batching === false || !Y.isBatchedMesh && ze.batching === true || Y.isInstancedMesh && ze.instancing === false || !Y.isInstancedMesh && ze.instancing === true || Y.isSkinnedMesh && ze.skinning === false || !Y.isSkinnedMesh && ze.skinning === true || Y.isInstancedMesh && ze.instancingColor === true && Y.instanceColor === null || Y.isInstancedMesh && ze.instancingColor === false && Y.instanceColor !== null || Y.isInstancedMesh && ze.instancingMorph === true && Y.morphTexture === null || Y.isInstancedMesh && ze.instancingMorph === false && Y.morphTexture !== null || ze.envMap !== Ue || X.fog === true && ze.fog !== _e || ze.numClippingPlanes !== void 0 && (ze.numClippingPlanes !== me.numPlanes || ze.numIntersection !== me.numIntersection) || ze.vertexAlphas !== Oe || ze.vertexTangents !== Ge || ze.morphTargets !== $e || ze.morphNormals !== _t || ze.morphColors !== Nt || ze.toneMapping !== rn || ze.morphTargetsCount !== nt) && (ut = true) : (ut = true, ze.__version = X.version);
        let Ji = ze.currentProgram;
        ut === true && (Ji = Yo(X, H, Y));
        let nd = false, Cr = false, jl = false;
        const Ut = Ji.getUniforms(), Si = ze.uniforms;
        if (Z.useProgram(Ji.program) && (nd = true, Cr = true, jl = true), X.id !== A && (A = X.id, Cr = true), nd || M !== R) {
          Ut.setValue(F, "projectionMatrix", R.projectionMatrix), Ut.setValue(F, "viewMatrix", R.matrixWorldInverse);
          const gn = Ut.map.cameraPosition;
          gn !== void 0 && gn.setValue(F, oe.setFromMatrixPosition(R.matrixWorld)), ie.logarithmicDepthBuffer && Ut.setValue(F, "logDepthBufFC", 2 / (Math.log(R.far + 1) / Math.LN2)), (X.isMeshPhongMaterial || X.isMeshToonMaterial || X.isMeshLambertMaterial || X.isMeshBasicMaterial || X.isMeshStandardMaterial || X.isShaderMaterial) && Ut.setValue(F, "isOrthographic", R.isOrthographicCamera === true), M !== R && (M = R, Cr = true, jl = true);
        }
        if (Y.isSkinnedMesh) {
          Ut.setOptional(F, Y, "bindMatrix"), Ut.setOptional(F, Y, "bindMatrixInverse");
          const gn = Y.skeleton;
          gn && (gn.boneTexture === null && gn.computeBoneTexture(), Ut.setValue(F, "boneTexture", gn.boneTexture, ve));
        }
        Y.isBatchedMesh && (Ut.setOptional(F, Y, "batchingTexture"), Ut.setValue(F, "batchingTexture", Y._matricesTexture, ve));
        const Ql = $.morphAttributes;
        if ((Ql.position !== void 0 || Ql.normal !== void 0 || Ql.color !== void 0) && Pe.update(Y, $, Ji), (Cr || ze.receiveShadow !== Y.receiveShadow) && (ze.receiveShadow = Y.receiveShadow, Ut.setValue(F, "receiveShadow", Y.receiveShadow)), X.isMeshGouraudMaterial && X.envMap !== null && (Si.envMap.value = Ue, Si.flipEnvMap.value = Ue.isCubeTexture && Ue.isRenderTargetTexture === false ? -1 : 1), X.isMeshStandardMaterial && X.envMap === null && H.environment !== null && (Si.envMapIntensity.value = H.environmentIntensity), Cr && (Ut.setValue(F, "toneMappingExposure", x.toneMappingExposure), ze.needsLights && m0(Si, jl), _e && X.fog === true && ne.refreshFogUniforms(Si, _e), ne.refreshMaterialUniforms(Si, X, B, z, g.state.transmissionRenderTarget[R.id]), Ya.upload(F, ed(ze), Si, ve)), X.isShaderMaterial && X.uniformsNeedUpdate === true && (Ya.upload(F, ed(ze), Si, ve), X.uniformsNeedUpdate = false), X.isSpriteMaterial && Ut.setValue(F, "center", Y.center), Ut.setValue(F, "modelViewMatrix", Y.modelViewMatrix), Ut.setValue(F, "normalMatrix", Y.normalMatrix), Ut.setValue(F, "modelMatrix", Y.matrixWorld), X.isShaderMaterial || X.isRawShaderMaterial) {
          const gn = X.uniformsGroups;
          for (let ec = 0, v0 = gn.length; ec < v0; ec++) {
            const id = gn[ec];
            Je.update(id, Ji), Je.bind(id, Ji);
          }
        }
        return Ji;
      }
      function m0(R, H) {
        R.ambientLightColor.needsUpdate = H, R.lightProbe.needsUpdate = H, R.directionalLights.needsUpdate = H, R.directionalLightShadows.needsUpdate = H, R.pointLights.needsUpdate = H, R.pointLightShadows.needsUpdate = H, R.spotLights.needsUpdate = H, R.spotLightShadows.needsUpdate = H, R.rectAreaLights.needsUpdate = H, R.hemisphereLights.needsUpdate = H;
      }
      function g0(R) {
        return R.isMeshLambertMaterial || R.isMeshToonMaterial || R.isMeshPhongMaterial || R.isMeshStandardMaterial || R.isShadowMaterial || R.isShaderMaterial && R.lights === true;
      }
      this.getActiveCubeFace = function() {
        return E;
      }, this.getActiveMipmapLevel = function() {
        return S;
      }, this.getRenderTarget = function() {
        return w;
      }, this.setRenderTargetTextures = function(R, H, $) {
        se.get(R.texture).__webglTexture = H, se.get(R.depthTexture).__webglTexture = $;
        const X = se.get(R);
        X.__hasExternalTextures = true, X.__autoAllocateDepthBuffer = $ === void 0, X.__autoAllocateDepthBuffer || J.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), X.__useRenderToTexture = false);
      }, this.setRenderTargetFramebuffer = function(R, H) {
        const $ = se.get(R);
        $.__webglFramebuffer = H, $.__useDefaultFramebuffer = H === void 0;
      }, this.setRenderTarget = function(R, H = 0, $ = 0) {
        w = R, E = H, S = $;
        let X = true, Y = null, _e = false, Ae = false;
        if (R) {
          const Ue = se.get(R);
          Ue.__useDefaultFramebuffer !== void 0 ? (Z.bindFramebuffer(F.FRAMEBUFFER, null), X = false) : Ue.__webglFramebuffer === void 0 ? ve.setupRenderTarget(R) : Ue.__hasExternalTextures && ve.rebindTextures(R, se.get(R.texture).__webglTexture, se.get(R.depthTexture).__webglTexture);
          const Oe = R.texture;
          (Oe.isData3DTexture || Oe.isDataArrayTexture || Oe.isCompressedArrayTexture) && (Ae = true);
          const Ge = se.get(R).__webglFramebuffer;
          R.isWebGLCubeRenderTarget ? (Array.isArray(Ge[H]) ? Y = Ge[H][$] : Y = Ge[H], _e = true) : R.samples > 0 && ve.useMultisampledRTT(R) === false ? Y = se.get(R).__webglMultisampledFramebuffer : Array.isArray(Ge) ? Y = Ge[$] : Y = Ge, y.copy(R.viewport), C.copy(R.scissor), N = R.scissorTest;
        } else y.copy(V).multiplyScalar(B).floor(), C.copy(K).multiplyScalar(B).floor(), N = ce;
        if (Z.bindFramebuffer(F.FRAMEBUFFER, Y) && X && Z.drawBuffers(R, Y), Z.viewport(y), Z.scissor(C), Z.setScissorTest(N), _e) {
          const Ue = se.get(R.texture);
          F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + H, Ue.__webglTexture, $);
        } else if (Ae) {
          const Ue = se.get(R.texture), Oe = H || 0;
          F.framebufferTextureLayer(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ue.__webglTexture, $ || 0, Oe);
        }
        A = -1;
      }, this.readRenderTargetPixels = function(R, H, $, X, Y, _e, Ae) {
        if (!(R && R.isWebGLRenderTarget)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          return;
        }
        let Re = se.get(R).__webglFramebuffer;
        if (R.isWebGLCubeRenderTarget && Ae !== void 0 && (Re = Re[Ae]), Re) {
          Z.bindFramebuffer(F.FRAMEBUFFER, Re);
          try {
            const Ue = R.texture, Oe = Ue.format, Ge = Ue.type;
            if (!ie.textureFormatReadable(Oe)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              return;
            }
            if (!ie.textureTypeReadable(Ge)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              return;
            }
            H >= 0 && H <= R.width - X && $ >= 0 && $ <= R.height - Y && F.readPixels(H, $, X, Y, we.convert(Oe), we.convert(Ge), _e);
          } finally {
            const Ue = w !== null ? se.get(w).__webglFramebuffer : null;
            Z.bindFramebuffer(F.FRAMEBUFFER, Ue);
          }
        }
      }, this.copyFramebufferToTexture = function(R, H, $ = 0) {
        const X = Math.pow(2, -$), Y = Math.floor(H.image.width * X), _e = Math.floor(H.image.height * X);
        ve.setTexture2D(H, 0), F.copyTexSubImage2D(F.TEXTURE_2D, $, 0, 0, R.x, R.y, Y, _e), Z.unbindTexture();
      }, this.copyTextureToTexture = function(R, H, $, X = 0) {
        const Y = H.image.width, _e = H.image.height, Ae = we.convert($.format), Re = we.convert($.type);
        ve.setTexture2D($, 0), F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, $.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, $.unpackAlignment), H.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D, X, R.x, R.y, Y, _e, Ae, Re, H.image.data) : H.isCompressedTexture ? F.compressedTexSubImage2D(F.TEXTURE_2D, X, R.x, R.y, H.mipmaps[0].width, H.mipmaps[0].height, Ae, H.mipmaps[0].data) : F.texSubImage2D(F.TEXTURE_2D, X, R.x, R.y, Ae, Re, H.image), X === 0 && $.generateMipmaps && F.generateMipmap(F.TEXTURE_2D), Z.unbindTexture();
      }, this.copyTextureToTexture3D = function(R, H, $, X, Y = 0) {
        const _e = R.max.x - R.min.x, Ae = R.max.y - R.min.y, Re = R.max.z - R.min.z, Ue = we.convert(X.format), Oe = we.convert(X.type);
        let Ge;
        if (X.isData3DTexture) ve.setTexture3D(X, 0), Ge = F.TEXTURE_3D;
        else if (X.isDataArrayTexture || X.isCompressedArrayTexture) ve.setTexture2DArray(X, 0), Ge = F.TEXTURE_2D_ARRAY;
        else {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          return;
        }
        F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, X.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, X.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, X.unpackAlignment);
        const $e = F.getParameter(F.UNPACK_ROW_LENGTH), _t = F.getParameter(F.UNPACK_IMAGE_HEIGHT), Nt = F.getParameter(F.UNPACK_SKIP_PIXELS), rn = F.getParameter(F.UNPACK_SKIP_ROWS), ei = F.getParameter(F.UNPACK_SKIP_IMAGES), nt = $.isCompressedTexture ? $.mipmaps[Y] : $.image;
        F.pixelStorei(F.UNPACK_ROW_LENGTH, nt.width), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, nt.height), F.pixelStorei(F.UNPACK_SKIP_PIXELS, R.min.x), F.pixelStorei(F.UNPACK_SKIP_ROWS, R.min.y), F.pixelStorei(F.UNPACK_SKIP_IMAGES, R.min.z), $.isDataTexture || $.isData3DTexture ? F.texSubImage3D(Ge, Y, H.x, H.y, H.z, _e, Ae, Re, Ue, Oe, nt.data) : X.isCompressedArrayTexture ? F.compressedTexSubImage3D(Ge, Y, H.x, H.y, H.z, _e, Ae, Re, Ue, nt.data) : F.texSubImage3D(Ge, Y, H.x, H.y, H.z, _e, Ae, Re, Ue, Oe, nt), F.pixelStorei(F.UNPACK_ROW_LENGTH, $e), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, _t), F.pixelStorei(F.UNPACK_SKIP_PIXELS, Nt), F.pixelStorei(F.UNPACK_SKIP_ROWS, rn), F.pixelStorei(F.UNPACK_SKIP_IMAGES, ei), Y === 0 && X.generateMipmaps && F.generateMipmap(Ge), Z.unbindTexture();
      }, this.initTexture = function(R) {
        R.isCubeTexture ? ve.setTextureCube(R, 0) : R.isData3DTexture ? ve.setTexture3D(R, 0) : R.isDataArrayTexture || R.isCompressedArrayTexture ? ve.setTexture2DArray(R, 0) : ve.setTexture2D(R, 0), Z.unbindTexture();
      }, this.resetState = function() {
        E = 0, S = 0, w = null, Z.reset(), Xe.reset();
      }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    get coordinateSystem() {
      return Yn;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(e) {
      this._outputColorSpace = e;
      const t = this.getContext();
      t.drawingBufferColorSpace = e === Ml ? "display-p3" : "srgb", t.unpackColorSpace = st.workingColorSpace === No ? "display-p3" : "srgb";
    }
    get useLegacyLights() {
      return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
    }
    set useLegacyLights(e) {
      console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
    }
  }
  class Al {
    constructor(e, t = 25e-5) {
      this.isFogExp2 = true, this.name = "", this.color = new ye(e), this.density = t;
    }
    clone() {
      return new Al(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        name: this.name,
        color: this.color.getHex(),
        density: this.density
      };
    }
  }
  class Cl {
    constructor(e, t = 1, n = 1e3) {
      this.isFog = true, this.name = "", this.color = new ye(e), this.near = t, this.far = n;
    }
    clone() {
      return new Cl(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        name: this.name,
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  }
  class xu extends Qe {
    constructor() {
      super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new mn(), this.environmentIntensity = 1, this.environmentRotation = new mn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    copy(e, t) {
      return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
    }
  }
  class Rl {
    constructor(e, t) {
      this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = fo, this._updateRange = {
        offset: 0,
        count: -1
      }, this.updateRanges = [], this.version = 0, this.uuid = fn();
    }
    onUploadCallback() {
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    get updateRange() {
      return Im("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    addUpdateRange(e, t) {
      this.updateRanges.push({
        start: e,
        count: t
      });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(e) {
      return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
    }
    copyAt(e, t, n) {
      e *= this.stride, n *= t.stride;
      for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    clone(e) {
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    toJSON(e) {
      return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }
  const Wt = new P();
  class Es {
    constructor(e, t, n, i = false) {
      this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e) {
      this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
      for (let t = 0, n = this.data.count; t < n; t++) Wt.fromBufferAttribute(this, t), Wt.applyMatrix4(e), this.setXYZ(t, Wt.x, Wt.y, Wt.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, n = this.count; t < n; t++) Wt.fromBufferAttribute(this, t), Wt.applyNormalMatrix(e), this.setXYZ(t, Wt.x, Wt.y, Wt.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, n = this.count; t < n; t++) Wt.fromBufferAttribute(this, t), Wt.transformDirection(e), this.setXYZ(t, Wt.x, Wt.y, Wt.z);
      return this;
    }
    getComponent(e, t) {
      let n = this.array[e * this.data.stride + this.offset + t];
      return this.normalized && (n = $t(n, this.array)), n;
    }
    setComponent(e, t, n) {
      return this.normalized && (n = Be(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
    }
    setX(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
    }
    setY(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
    }
    setZ(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
    }
    setW(e, t) {
      return this.normalized && (t = Be(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
    }
    getX(e) {
      let t = this.data.array[e * this.data.stride + this.offset];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    getY(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 1];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    getZ(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 2];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    getW(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 3];
      return this.normalized && (t = $t(t, this.array)), t;
    }
    setXY(e, t, n) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = Be(t, this.array), n = Be(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
    }
    setXYZ(e, t, n, i) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = Be(t, this.array), n = Be(n, this.array), i = Be(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
    }
    setXYZW(e, t, n, i, r) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = Be(t, this.array), n = Be(n, this.array), i = Be(i, this.array), r = Be(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
    }
    clone(e) {
      if (e === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        const t = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
        }
        return new at(new this.array.constructor(t), this.itemSize, this.normalized);
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Es(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(e) {
      if (e === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        const t = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[i + r]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized
        };
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
  class _u extends Ht {
    constructor(e) {
      super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new ye(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
  }
  let qs;
  const Dr = new P(), $s = new P(), Zs = new P(), Js = new ee(), Nr = new ee(), $m = new De(), pa = new P(), Ur = new P(), ma = new P(), Xd = new ee(), Ec = new ee(), Yd = new ee();
  class Zm extends Qe {
    constructor(e = new _u()) {
      if (super(), this.isSprite = true, this.type = "Sprite", qs === void 0) {
        qs = new We();
        const t = new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]), n = new Rl(t, 5);
        qs.setIndex([
          0,
          1,
          2,
          0,
          2,
          3
        ]), qs.setAttribute("position", new Es(n, 3, 0, false)), qs.setAttribute("uv", new Es(n, 2, 3, false));
      }
      this.geometry = qs, this.material = e, this.center = new ee(0.5, 0.5);
    }
    raycast(e, t) {
      e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), $s.setFromMatrixScale(this.matrixWorld), $m.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Zs.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && $s.multiplyScalar(-Zs.z);
      const n = this.material.rotation;
      let i, r;
      n !== 0 && (r = Math.cos(n), i = Math.sin(n));
      const o = this.center;
      ga(pa.set(-0.5, -0.5, 0), Zs, o, $s, i, r), ga(Ur.set(0.5, -0.5, 0), Zs, o, $s, i, r), ga(ma.set(0.5, 0.5, 0), Zs, o, $s, i, r), Xd.set(0, 0), Ec.set(1, 0), Yd.set(1, 1);
      let a = e.ray.intersectTriangle(pa, Ur, ma, false, Dr);
      if (a === null && (ga(Ur.set(-0.5, 0.5, 0), Zs, o, $s, i, r), Ec.set(0, 1), a = e.ray.intersectTriangle(pa, ma, Ur, false, Dr), a === null)) return;
      const l = e.ray.origin.distanceTo(Dr);
      l < e.near || l > e.far || t.push({
        distance: l,
        point: Dr.clone(),
        uv: un.getInterpolation(Dr, pa, Ur, ma, Xd, Ec, Yd, new ee()),
        face: null,
        object: this
      });
    }
    copy(e, t) {
      return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
    }
  }
  function ga(s, e, t, n, i, r) {
    Js.subVectors(s, t).addScalar(0.5).multiply(n), i !== void 0 ? (Nr.x = r * Js.x - i * Js.y, Nr.y = i * Js.x + r * Js.y) : Nr.copy(Js), s.copy(e), s.x += Nr.x, s.y += Nr.y, s.applyMatrix4($m);
  }
  const va = new P(), qd = new P();
  class Jm extends Qe {
    constructor() {
      super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
        levels: {
          enumerable: true,
          value: []
        },
        isLOD: {
          value: true
        }
      }), this.autoUpdate = true;
    }
    copy(e) {
      super.copy(e, false);
      const t = e.levels;
      for (let n = 0, i = t.length; n < i; n++) {
        const r = t[n];
        this.addLevel(r.object.clone(), r.distance, r.hysteresis);
      }
      return this.autoUpdate = e.autoUpdate, this;
    }
    addLevel(e, t = 0, n = 0) {
      t = Math.abs(t);
      const i = this.levels;
      let r;
      for (r = 0; r < i.length && !(t < i[r].distance); r++) ;
      return i.splice(r, 0, {
        distance: t,
        hysteresis: n,
        object: e
      }), this.add(e), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(e) {
      const t = this.levels;
      if (t.length > 0) {
        let n, i;
        for (n = 1, i = t.length; n < i; n++) {
          let r = t[n].distance;
          if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r) break;
        }
        return t[n - 1].object;
      }
      return null;
    }
    raycast(e, t) {
      if (this.levels.length > 0) {
        va.setFromMatrixPosition(this.matrixWorld);
        const i = e.ray.origin.distanceTo(va);
        this.getObjectForDistance(i).raycast(e, t);
      }
    }
    update(e) {
      const t = this.levels;
      if (t.length > 1) {
        va.setFromMatrixPosition(e.matrixWorld), qd.setFromMatrixPosition(this.matrixWorld);
        const n = va.distanceTo(qd) / e.zoom;
        t[0].object.visible = true;
        let i, r;
        for (i = 1, r = t.length; i < r; i++) {
          let o = t[i].distance;
          if (t[i].object.visible && (o -= o * t[i].hysteresis), n >= o) t[i - 1].object.visible = false, t[i].object.visible = true;
          else break;
        }
        for (this._currentLevel = i - 1; i < r; i++) t[i].object.visible = false;
      }
    }
    toJSON(e) {
      const t = super.toJSON(e);
      this.autoUpdate === false && (t.object.autoUpdate = false), t.object.levels = [];
      const n = this.levels;
      for (let i = 0, r = n.length; i < r; i++) {
        const o = n[i];
        t.object.levels.push({
          object: o.object.uuid,
          distance: o.distance,
          hysteresis: o.hysteresis
        });
      }
      return t;
    }
  }
  const $d = new P(), Zd = new rt(), Jd = new rt(), Ib = new P(), Kd = new De(), xa = new P(), Ac = new kt(), jd = new De(), Cc = new yr();
  class Km extends ht {
    constructor(e, t) {
      super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = th, this.bindMatrix = new De(), this.bindMatrixInverse = new De(), this.boundingBox = null, this.boundingSphere = null;
    }
    computeBoundingBox() {
      const e = this.geometry;
      this.boundingBox === null && (this.boundingBox = new Bt()), this.boundingBox.makeEmpty();
      const t = e.getAttribute("position");
      for (let n = 0; n < t.count; n++) this.getVertexPosition(n, xa), this.boundingBox.expandByPoint(xa);
    }
    computeBoundingSphere() {
      const e = this.geometry;
      this.boundingSphere === null && (this.boundingSphere = new kt()), this.boundingSphere.makeEmpty();
      const t = e.getAttribute("position");
      for (let n = 0; n < t.count; n++) this.getVertexPosition(n, xa), this.boundingSphere.expandByPoint(xa);
    }
    copy(e, t) {
      return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
    }
    raycast(e, t) {
      const n = this.material, i = this.matrixWorld;
      n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ac.copy(this.boundingSphere), Ac.applyMatrix4(i), e.ray.intersectsSphere(Ac) !== false && (jd.copy(i).invert(), Cc.copy(e.ray).applyMatrix4(jd), !(this.boundingBox !== null && Cc.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, Cc)));
    }
    getVertexPosition(e, t) {
      return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
    }
    bind(e, t) {
      this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const e = new rt(), t = this.geometry.attributes.skinWeight;
      for (let n = 0, i = t.count; n < i; n++) {
        e.fromBufferAttribute(t, n);
        const r = 1 / e.manhattanLength();
        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.bindMode === th ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === om ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    applyBoneTransform(e, t) {
      const n = this.skeleton, i = this.geometry;
      Zd.fromBufferAttribute(i.attributes.skinIndex, e), Jd.fromBufferAttribute(i.attributes.skinWeight, e), $d.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
      for (let r = 0; r < 4; r++) {
        const o = Jd.getComponent(r);
        if (o !== 0) {
          const a = Zd.getComponent(r);
          Kd.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(Ib.copy($d).applyMatrix4(Kd), o);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    }
  }
  class yu extends Qe {
    constructor() {
      super(), this.isBone = true, this.type = "Bone";
    }
  }
  class Oi extends gt {
    constructor(e = null, t = 1, n = 1, i, r, o, a, l, c = At, u = At, d, h) {
      super(null, o, a, l, c, u, i, r, d, h), this.isDataTexture = true, this.image = {
        data: e,
        width: t,
        height: n
      }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  const Qd = new De(), Lb = new De();
  class Pl {
    constructor(e = [], t = []) {
      this.uuid = fn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
    }
    init() {
      const e = this.bones, t = this.boneInverses;
      if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
      else if (e.length !== t.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new De());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = new De();
        this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
      }
    }
    pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = this.bones[e];
        n && n.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = this.bones[e];
        n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
      }
    }
    update() {
      const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r] ? e[r].matrixWorld : Lb;
        Qd.multiplyMatrices(a, t[r]), Qd.toArray(n, r * 16);
      }
      i !== null && (i.needsUpdate = true);
    }
    clone() {
      return new Pl(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e = Math.sqrt(this.bones.length * 4);
      e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
      const t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      const n = new Oi(t, e, e, dn, Tn);
      return n.needsUpdate = true, this.boneMatrices = t, this.boneTexture = n, this;
    }
    getBoneByName(e) {
      for (let t = 0, n = this.bones.length; t < n; t++) {
        const i = this.bones[t];
        if (i.name === e) return i;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let n = 0, i = e.bones.length; n < i; n++) {
        const r = e.bones[n];
        let o = t[r];
        o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new yu()), this.bones.push(o), this.boneInverses.push(new De().fromArray(e.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      e.uuid = this.uuid;
      const t = this.bones, n = this.boneInverses;
      for (let i = 0, r = t.length; i < r; i++) {
        const o = t[i];
        e.bones.push(o.uuid);
        const a = n[i];
        e.boneInverses.push(a.toArray());
      }
      return e;
    }
  }
  class fr extends at {
    constructor(e, t, n, i = 1) {
      super(e, t, n), this.isInstancedBufferAttribute = true, this.meshPerAttribute = i;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
    }
  }
  const Ks = new De(), ef = new De(), _a = [], tf = new Bt(), Db = new De(), Or = new ht(), zr = new kt();
  class jm extends ht {
    constructor(e, t, n) {
      super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new fr(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
      for (let i = 0; i < n; i++) this.setMatrixAt(i, Db);
    }
    computeBoundingBox() {
      const e = this.geometry, t = this.count;
      this.boundingBox === null && (this.boundingBox = new Bt()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
      for (let n = 0; n < t; n++) this.getMatrixAt(n, Ks), tf.copy(e.boundingBox).applyMatrix4(Ks), this.boundingBox.union(tf);
    }
    computeBoundingSphere() {
      const e = this.geometry, t = this.count;
      this.boundingSphere === null && (this.boundingSphere = new kt()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
      for (let n = 0; n < t; n++) this.getMatrixAt(n, Ks), zr.copy(e.boundingSphere).applyMatrix4(Ks), this.boundingSphere.union(zr);
    }
    copy(e, t) {
      return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
    }
    getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, e * 16);
    }
    getMorphAt(e, t) {
      const n = t.morphTargetInfluences, i = this.morphTexture.source.data.data, r = n.length + 1, o = e * r + 1;
      for (let a = 0; a < n.length; a++) n[a] = i[o + a];
    }
    raycast(e, t) {
      const n = this.matrixWorld, i = this.count;
      if (Or.geometry = this.geometry, Or.material = this.material, Or.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), zr.copy(this.boundingSphere), zr.applyMatrix4(n), e.ray.intersectsSphere(zr) !== false)) for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Ks), ef.multiplyMatrices(n, Ks), Or.matrixWorld = ef, Or.raycast(e, _a);
        for (let o = 0, a = _a.length; o < a; o++) {
          const l = _a[o];
          l.instanceId = r, l.object = this, t.push(l);
        }
        _a.length = 0;
      }
    }
    setColorAt(e, t) {
      this.instanceColor === null && (this.instanceColor = new fr(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, e * 16);
    }
    setMorphAt(e, t) {
      const n = t.morphTargetInfluences, i = n.length + 1;
      this.morphTexture === null && (this.morphTexture = new Oi(new Float32Array(i * this.count), i, this.count, su, Tn));
      const r = this.morphTexture.source.data.data;
      let o = 0;
      for (let c = 0; c < n.length; c++) o += n[c];
      const a = this.geometry.morphTargetsRelative ? 1 : 1 - o, l = i * e;
      r[l] = a, r.set(n, l + 1);
    }
    updateMorphTargets() {
    }
    dispose() {
      return this.dispatchEvent({
        type: "dispose"
      }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
    }
  }
  function Nb(s, e) {
    return s.z - e.z;
  }
  function Ub(s, e) {
    return e.z - s.z;
  }
  class Ob {
    constructor() {
      this.index = 0, this.pool = [], this.list = [];
    }
    push(e, t) {
      const n = this.pool, i = this.list;
      this.index >= n.length && n.push({
        start: -1,
        count: -1,
        z: -1
      });
      const r = n[this.index];
      i.push(r), this.index++, r.start = e.start, r.count = e.count, r.z = t;
    }
    reset() {
      this.list.length = 0, this.index = 0;
    }
  }
  const js = "batchId", Pi = new De(), nf = new De(), zb = new De(), sf = new De(), Rc = new Oo(), ya = new Bt(), is = new kt(), Fr = new P(), Pc = new Ob(), Ft = new ht(), Ma = [];
  function Fb(s, e, t = 0) {
    const n = e.itemSize;
    if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
      const i = s.count;
      for (let r = 0; r < i; r++) for (let o = 0; o < n; o++) e.setComponent(r + t, o, s.getComponent(r, o));
    } else e.array.set(s.array, t * n);
    e.needsUpdate = true;
  }
  class Qm extends ht {
    get maxGeometryCount() {
      return this._maxGeometryCount;
    }
    constructor(e, t, n = t * 2, i) {
      super(new We(), i), this.isBatchedMesh = true, this.perObjectFrustumCulled = true, this.sortObjects = true, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = false, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._visibilityChanged = true, this._matricesTexture = null, this._initMatricesTexture();
    }
    _initMatricesTexture() {
      let e = Math.sqrt(this._maxGeometryCount * 4);
      e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
      const t = new Float32Array(e * e * 4), n = new Oi(t, e, e, dn, Tn);
      this._matricesTexture = n;
    }
    _initializeGeometry(e) {
      const t = this.geometry, n = this._maxVertexCount, i = this._maxGeometryCount, r = this._maxIndexCount;
      if (this._geometryInitialized === false) {
        for (const a in e.attributes) {
          const l = e.getAttribute(a), { array: c, itemSize: u, normalized: d } = l, h = new c.constructor(n * u), f = new at(h, u, d);
          t.setAttribute(a, f);
        }
        if (e.getIndex() !== null) {
          const a = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
          t.setIndex(new at(a, 1));
        }
        const o = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
        t.setAttribute(js, new at(o, 1)), this._geometryInitialized = true;
      }
    }
    _validateGeometry(e) {
      if (e.getAttribute(js)) throw new Error(`BatchedMesh: Geometry cannot use attribute "${js}"`);
      const t = this.geometry;
      if (!!e.getIndex() != !!t.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
      for (const n in t.attributes) {
        if (n === js) continue;
        if (!e.hasAttribute(n)) throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
        const i = e.getAttribute(n), r = t.getAttribute(n);
        if (i.itemSize !== r.itemSize || i.normalized !== r.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
      }
    }
    setCustomSort(e) {
      return this.customSort = e, this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Bt());
      const e = this._geometryCount, t = this.boundingBox, n = this._active;
      t.makeEmpty();
      for (let i = 0; i < e; i++) n[i] !== false && (this.getMatrixAt(i, Pi), this.getBoundingBoxAt(i, ya).applyMatrix4(Pi), t.union(ya));
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new kt());
      const e = this._geometryCount, t = this.boundingSphere, n = this._active;
      t.makeEmpty();
      for (let i = 0; i < e; i++) n[i] !== false && (this.getMatrixAt(i, Pi), this.getBoundingSphereAt(i, is).applyMatrix4(Pi), t.union(is));
    }
    addGeometry(e, t = -1, n = -1) {
      if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
      const i = {
        vertexStart: -1,
        vertexCount: -1,
        indexStart: -1,
        indexCount: -1
      };
      let r = null;
      const o = this._reservedRanges, a = this._drawRanges, l = this._bounds;
      this._geometryCount !== 0 && (r = o[o.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, r === null ? i.vertexStart = 0 : i.vertexStart = r.vertexStart + r.vertexCount;
      const c = e.getIndex(), u = c !== null;
      if (u && (n === -1 ? i.indexCount = c.count : i.indexCount = n, r === null ? i.indexStart = 0 : i.indexStart = r.indexStart + r.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
      const d = this._visibility, h = this._active, f = this._matricesTexture, m = this._matricesTexture.image.data;
      d.push(true), h.push(true);
      const v = this._geometryCount;
      this._geometryCount++, zb.toArray(m, v * 16), f.needsUpdate = true, o.push(i), a.push({
        start: u ? i.indexStart : i.vertexStart,
        count: -1
      }), l.push({
        boxInitialized: false,
        box: new Bt(),
        sphereInitialized: false,
        sphere: new kt()
      });
      const g = this.geometry.getAttribute(js);
      for (let p = 0; p < i.vertexCount; p++) g.setX(i.vertexStart + p, v);
      return g.needsUpdate = true, this.setGeometryAt(v, e), v;
    }
    setGeometryAt(e, t) {
      if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
      this._validateGeometry(t);
      const n = this.geometry, i = n.getIndex() !== null, r = n.getIndex(), o = t.getIndex(), a = this._reservedRanges[e];
      if (i && o.count > a.indexCount || t.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
      const l = a.vertexStart, c = a.vertexCount;
      for (const f in n.attributes) {
        if (f === js) continue;
        const m = t.getAttribute(f), v = n.getAttribute(f);
        Fb(m, v, l);
        const g = m.itemSize;
        for (let p = m.count, _ = c; p < _; p++) {
          const x = l + p;
          for (let b = 0; b < g; b++) v.setComponent(x, b, 0);
        }
        v.needsUpdate = true, v.addUpdateRange(l * g, c * g);
      }
      if (i) {
        const f = a.indexStart;
        for (let m = 0; m < o.count; m++) r.setX(f + m, l + o.getX(m));
        for (let m = o.count, v = a.indexCount; m < v; m++) r.setX(f + m, l);
        r.needsUpdate = true, r.addUpdateRange(f, a.indexCount);
      }
      const u = this._bounds[e];
      t.boundingBox !== null ? (u.box.copy(t.boundingBox), u.boxInitialized = true) : u.boxInitialized = false, t.boundingSphere !== null ? (u.sphere.copy(t.boundingSphere), u.sphereInitialized = true) : u.sphereInitialized = false;
      const d = this._drawRanges[e], h = t.getAttribute("position");
      return d.count = i ? o.count : h.count, this._visibilityChanged = true, e;
    }
    deleteGeometry(e) {
      const t = this._active;
      return e >= t.length || t[e] === false ? this : (t[e] = false, this._visibilityChanged = true, this);
    }
    getInstanceCountAt(e) {
      return this._multiDrawInstances === null ? null : this._multiDrawInstances[e];
    }
    setInstanceCountAt(e, t) {
      return this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)), this._multiDrawInstances[e] = t, e;
    }
    getBoundingBoxAt(e, t) {
      if (this._active[e] === false) return null;
      const i = this._bounds[e], r = i.box, o = this.geometry;
      if (i.boxInitialized === false) {
        r.makeEmpty();
        const a = o.index, l = o.attributes.position, c = this._drawRanges[e];
        for (let u = c.start, d = c.start + c.count; u < d; u++) {
          let h = u;
          a && (h = a.getX(h)), r.expandByPoint(Fr.fromBufferAttribute(l, h));
        }
        i.boxInitialized = true;
      }
      return t.copy(r), t;
    }
    getBoundingSphereAt(e, t) {
      if (this._active[e] === false) return null;
      const i = this._bounds[e], r = i.sphere, o = this.geometry;
      if (i.sphereInitialized === false) {
        r.makeEmpty(), this.getBoundingBoxAt(e, ya), ya.getCenter(r.center);
        const a = o.index, l = o.attributes.position, c = this._drawRanges[e];
        let u = 0;
        for (let d = c.start, h = c.start + c.count; d < h; d++) {
          let f = d;
          a && (f = a.getX(f)), Fr.fromBufferAttribute(l, f), u = Math.max(u, r.center.distanceToSquared(Fr));
        }
        r.radius = Math.sqrt(u), i.sphereInitialized = true;
      }
      return t.copy(r), t;
    }
    setMatrixAt(e, t) {
      const n = this._active, i = this._matricesTexture, r = this._matricesTexture.image.data, o = this._geometryCount;
      return e >= o || n[e] === false ? this : (t.toArray(r, e * 16), i.needsUpdate = true, this);
    }
    getMatrixAt(e, t) {
      const n = this._active, i = this._matricesTexture.image.data, r = this._geometryCount;
      return e >= r || n[e] === false ? null : t.fromArray(i, e * 16);
    }
    setVisibleAt(e, t) {
      const n = this._visibility, i = this._active, r = this._geometryCount;
      return e >= r || i[e] === false || n[e] === t ? this : (n[e] = t, this._visibilityChanged = true, this);
    }
    getVisibleAt(e) {
      const t = this._visibility, n = this._active, i = this._geometryCount;
      return e >= i || n[e] === false ? false : t[e];
    }
    raycast(e, t) {
      const n = this._visibility, i = this._active, r = this._drawRanges, o = this._geometryCount, a = this.matrixWorld, l = this.geometry;
      Ft.material = this.material, Ft.geometry.index = l.index, Ft.geometry.attributes = l.attributes, Ft.geometry.boundingBox === null && (Ft.geometry.boundingBox = new Bt()), Ft.geometry.boundingSphere === null && (Ft.geometry.boundingSphere = new kt());
      for (let c = 0; c < o; c++) {
        if (!n[c] || !i[c]) continue;
        const u = r[c];
        Ft.geometry.setDrawRange(u.start, u.count), this.getMatrixAt(c, Ft.matrixWorld).premultiply(a), this.getBoundingBoxAt(c, Ft.geometry.boundingBox), this.getBoundingSphereAt(c, Ft.geometry.boundingSphere), Ft.raycast(e, Ma);
        for (let d = 0, h = Ma.length; d < h; d++) {
          const f = Ma[d];
          f.object = this, f.batchId = c, t.push(f);
        }
        Ma.length = 0;
      }
      Ft.material = null, Ft.geometry.index = null, Ft.geometry.attributes = {}, Ft.geometry.setDrawRange(0, 1 / 0);
    }
    copy(e) {
      return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({
        ...t
      })), this._reservedRanges = e._reservedRanges.map((t) => ({
        ...t
      })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone()
      })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
    }
    dispose() {
      return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
    }
    onBeforeRender(e, t, n, i, r) {
      if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
      const o = i.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, l = this._active, c = this._visibility, u = this._multiDrawStarts, d = this._multiDrawCounts, h = this._drawRanges, f = this.perObjectFrustumCulled;
      f && (sf.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), Rc.setFromProjectionMatrix(sf, e.coordinateSystem));
      let m = 0;
      if (this.sortObjects) {
        nf.copy(this.matrixWorld).invert(), Fr.setFromMatrixPosition(n.matrixWorld).applyMatrix4(nf);
        for (let p = 0, _ = c.length; p < _; p++) if (c[p] && l[p]) {
          this.getMatrixAt(p, Pi), this.getBoundingSphereAt(p, is).applyMatrix4(Pi);
          let x = false;
          if (f && (x = !Rc.intersectsSphere(is)), !x) {
            const b = Fr.distanceTo(is.center);
            Pc.push(h[p], b);
          }
        }
        const v = Pc.list, g = this.customSort;
        g === null ? v.sort(r.transparent ? Ub : Nb) : g.call(this, v, n);
        for (let p = 0, _ = v.length; p < _; p++) {
          const x = v[p];
          u[m] = x.start * a, d[m] = x.count, m++;
        }
        Pc.reset();
      } else for (let v = 0, g = c.length; v < g; v++) if (c[v] && l[v]) {
        let p = false;
        if (f && (this.getMatrixAt(v, Pi), this.getBoundingSphereAt(v, is).applyMatrix4(Pi), p = !Rc.intersectsSphere(is)), !p) {
          const _ = h[v];
          u[m] = _.start * a, d[m] = _.count, m++;
        }
      }
      this._multiDrawCount = m, this._visibilityChanged = false;
    }
    onBeforeShadow(e, t, n, i, r, o) {
      this.onBeforeRender(e, null, i, r, o);
    }
  }
  class Jt extends Ht {
    constructor(e) {
      super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new ye(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
    }
  }
  const Za = new P(), Ja = new P(), rf = new De(), Br = new yr(), ba = new kt(), Ic = new P(), of = new P();
  class ki extends Qe {
    constructor(e = new We(), t = new Jt()) {
      super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
    }
    computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
        const t = e.attributes.position, n = [
          0
        ];
        for (let i = 1, r = t.count; i < r; i++) Za.fromBufferAttribute(t, i - 1), Ja.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += Za.distanceTo(Ja);
        e.setAttribute("lineDistance", new Ee(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, o = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), ba.copy(n.boundingSphere), ba.applyMatrix4(i), ba.radius += r, e.ray.intersectsSphere(ba) === false) return;
      rf.copy(i).invert(), Br.copy(e.ray).applyMatrix4(rf);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = this.isLineSegments ? 2 : 1, u = n.index, h = n.attributes.position;
      if (u !== null) {
        const f = Math.max(0, o.start), m = Math.min(u.count, o.start + o.count);
        for (let v = f, g = m - 1; v < g; v += c) {
          const p = u.getX(v), _ = u.getX(v + 1), x = Sa(this, e, Br, l, p, _);
          x && t.push(x);
        }
        if (this.isLineLoop) {
          const v = u.getX(m - 1), g = u.getX(f), p = Sa(this, e, Br, l, v, g);
          p && t.push(p);
        }
      } else {
        const f = Math.max(0, o.start), m = Math.min(h.count, o.start + o.count);
        for (let v = f, g = m - 1; v < g; v += c) {
          const p = Sa(this, e, Br, l, v, v + 1);
          p && t.push(p);
        }
        if (this.isLineLoop) {
          const v = Sa(this, e, Br, l, m - 1, f);
          v && t.push(v);
        }
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    }
  }
  function Sa(s, e, t, n, i, r) {
    const o = s.geometry.attributes.position;
    if (Za.fromBufferAttribute(o, i), Ja.fromBufferAttribute(o, r), t.distanceSqToSegment(Za, Ja, Ic, of) > n) return;
    Ic.applyMatrix4(s.matrixWorld);
    const l = e.ray.origin.distanceTo(Ic);
    if (!(l < e.near || l > e.far)) return {
      distance: l,
      point: of.clone().applyMatrix4(s.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: s
    };
  }
  const af = new P(), lf = new P();
  class Kn extends ki {
    constructor(e, t) {
      super(e, t), this.isLineSegments = true, this.type = "LineSegments";
    }
    computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
        const t = e.attributes.position, n = [];
        for (let i = 0, r = t.count; i < r; i += 2) af.fromBufferAttribute(t, i), lf.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + af.distanceTo(lf);
        e.setAttribute("lineDistance", new Ee(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class eg extends ki {
    constructor(e, t) {
      super(e, t), this.isLineLoop = true, this.type = "LineLoop";
    }
  }
  class Mu extends Ht {
    constructor(e) {
      super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new ye(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
  }
  const cf = new De(), Lh = new yr(), wa = new kt(), Ta = new P();
  class tg extends Qe {
    constructor(e = new We(), t = new Mu()) {
      super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, o = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), wa.copy(n.boundingSphere), wa.applyMatrix4(i), wa.radius += r, e.ray.intersectsSphere(wa) === false) return;
      cf.copy(i).invert(), Lh.copy(e.ray).applyMatrix4(cf);
      const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = n.index, d = n.attributes.position;
      if (c !== null) {
        const h = Math.max(0, o.start), f = Math.min(c.count, o.start + o.count);
        for (let m = h, v = f; m < v; m++) {
          const g = c.getX(m);
          Ta.fromBufferAttribute(d, g), hf(Ta, g, l, i, e, t, this);
        }
      } else {
        const h = Math.max(0, o.start), f = Math.min(d.count, o.start + o.count);
        for (let m = h, v = f; m < v; m++) Ta.fromBufferAttribute(d, m), hf(Ta, m, l, i, e, t, this);
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let r = 0, o = i.length; r < o; r++) {
            const a = i[r].name || String(r);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
          }
        }
      }
    }
  }
  function hf(s, e, t, n, i, r, o) {
    const a = Lh.distanceSqToPoint(s);
    if (a < t) {
      const l = new P();
      Lh.closestPointToPoint(s, l), l.applyMatrix4(n);
      const c = i.ray.origin.distanceTo(l);
      if (c < i.near || c > i.far) return;
      r.push({
        distance: c,
        distanceToRay: Math.sqrt(a),
        point: l,
        index: e,
        face: null,
        object: o
      });
    }
  }
  class Bb extends gt {
    constructor(e, t, n, i, r, o, a, l, c) {
      super(e, t, n, i, r, o, a, l, c), this.isVideoTexture = true, this.minFilter = o !== void 0 ? o : Mt, this.magFilter = r !== void 0 ? r : Mt, this.generateMipmaps = false;
      const u = this;
      function d() {
        u.needsUpdate = true, e.requestVideoFrameCallback(d);
      }
      "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const e = this.image;
      "requestVideoFrameCallback" in e === false && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }
  class kb extends gt {
    constructor(e, t) {
      super({
        width: e,
        height: t
      }), this.isFramebufferTexture = true, this.magFilter = At, this.minFilter = At, this.generateMipmaps = false, this.needsUpdate = true;
    }
  }
  class Il extends gt {
    constructor(e, t, n, i, r, o, a, l, c, u, d, h) {
      super(null, o, a, l, c, u, i, r, d, h), this.isCompressedTexture = true, this.image = {
        width: t,
        height: n
      }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false;
    }
  }
  class Vb extends Il {
    constructor(e, t, n, i, r, o) {
      super(e, t, n, r, o), this.isCompressedArrayTexture = true, this.image.depth = i, this.wrapR = wn;
    }
  }
  class Hb extends Il {
    constructor(e, t, n) {
      super(void 0, e[0].width, e[0].height, t, n, gi), this.isCompressedCubeTexture = true, this.isCubeTexture = true, this.image = e;
    }
  }
  class ng extends gt {
    constructor(e, t, n, i, r, o, a, l, c) {
      super(e, t, n, i, r, o, a, l, c), this.isCanvasTexture = true, this.needsUpdate = true;
    }
  }
  class kn {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e, t) {
      const n = this.getUtoTmapping(e);
      return this.getPoint(n, t);
    }
    getPoints(e = 5) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return t;
    }
    getSpacedPoints(e = 5) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
      return t;
    }
    getLength() {
      const e = this.getLengths();
      return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = false;
      const t = [];
      let n, i = this.getPoint(0), r = 0;
      t.push(0);
      for (let o = 1; o <= e; o++) n = this.getPoint(o / e), r += n.distanceTo(i), t.push(r), i = n;
      return this.cacheArcLengths = t, t;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e, t) {
      const n = this.getLengths();
      let i = 0;
      const r = n.length;
      let o;
      t ? o = t : o = e * n[r - 1];
      let a = 0, l = r - 1, c;
      for (; a <= l; ) if (i = Math.floor(a + (l - a) / 2), c = n[i] - o, c < 0) a = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
      if (i = l, n[i] === o) return i / (r - 1);
      const u = n[i], h = n[i + 1] - u, f = (o - u) / h;
      return (i + f) / (r - 1);
    }
    getTangent(e, t) {
      let i = e - 1e-4, r = e + 1e-4;
      i < 0 && (i = 0), r > 1 && (r = 1);
      const o = this.getPoint(i), a = this.getPoint(r), l = t || (o.isVector2 ? new ee() : new P());
      return l.copy(a).sub(o).normalize(), l;
    }
    getTangentAt(e, t) {
      const n = this.getUtoTmapping(e);
      return this.getTangent(n, t);
    }
    computeFrenetFrames(e, t) {
      const n = new P(), i = [], r = [], o = [], a = new P(), l = new De();
      for (let f = 0; f <= e; f++) {
        const m = f / e;
        i[f] = this.getTangentAt(m, new P());
      }
      r[0] = new P(), o[0] = new P();
      let c = Number.MAX_VALUE;
      const u = Math.abs(i[0].x), d = Math.abs(i[0].y), h = Math.abs(i[0].z);
      u <= c && (c = u, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), o[0].crossVectors(i[0], r[0]);
      for (let f = 1; f <= e; f++) {
        if (r[f] = r[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(i[f - 1], i[f]), a.length() > Number.EPSILON) {
          a.normalize();
          const m = Math.acos(mt(i[f - 1].dot(i[f]), -1, 1));
          r[f].applyMatrix4(l.makeRotationAxis(a, m));
        }
        o[f].crossVectors(i[f], r[f]);
      }
      if (t === true) {
        let f = Math.acos(mt(r[0].dot(r[e]), -1, 1));
        f /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
        for (let m = 1; m <= e; m++) r[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)), o[m].crossVectors(i[m], r[m]);
      }
      return {
        tangents: i,
        normals: r,
        binormals: o
      };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
    }
    fromJSON(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
  }
  class Ll extends kn {
    constructor(e = 0, t = 0, n = 1, i = 1, r = 0, o = Math.PI * 2, a = false, l = 0) {
      super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
    }
    getPoint(e, t = new ee()) {
      const n = t, i = Math.PI * 2;
      let r = this.aEndAngle - this.aStartAngle;
      const o = Math.abs(r) < Number.EPSILON;
      for (; r < 0; ) r += i;
      for (; r > i; ) r -= i;
      r < Number.EPSILON && (o ? r = 0 : r = i), this.aClockwise === true && !o && (r === i ? r = -i : r = r - i);
      const a = this.aStartAngle + e * r;
      let l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
      if (this.aRotation !== 0) {
        const u = Math.cos(this.aRotation), d = Math.sin(this.aRotation), h = l - this.aX, f = c - this.aY;
        l = h * u - f * d + this.aX, c = h * d + f * u + this.aY;
      }
      return n.set(l, c);
    }
    copy(e) {
      return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
  }
  class ig extends Ll {
    constructor(e, t, n, i, r, o) {
      super(e, t, n, n, i, r, o), this.isArcCurve = true, this.type = "ArcCurve";
    }
  }
  function bu() {
    let s = 0, e = 0, t = 0, n = 0;
    function i(r, o, a, l) {
      s = r, e = a, t = -3 * r + 3 * o - 2 * a - l, n = 2 * r - 2 * o + a + l;
    }
    return {
      initCatmullRom: function(r, o, a, l, c) {
        i(o, a, c * (a - r), c * (l - o));
      },
      initNonuniformCatmullRom: function(r, o, a, l, c, u, d) {
        let h = (o - r) / c - (a - r) / (c + u) + (a - o) / u, f = (a - o) / u - (l - o) / (u + d) + (l - a) / d;
        h *= u, f *= u, i(o, a, h, f);
      },
      calc: function(r) {
        const o = r * r, a = o * r;
        return s + e * r + t * o + n * a;
      }
    };
  }
  const Ea = new P(), Lc = new bu(), Dc = new bu(), Nc = new bu();
  class sg extends kn {
    constructor(e = [], t = false, n = "centripetal", i = 0.5) {
      super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
    }
    getPoint(e, t = new P()) {
      const n = t, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * e;
      let a = Math.floor(o), l = o - a;
      this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
      let c, u;
      this.closed || a > 0 ? c = i[(a - 1) % r] : (Ea.subVectors(i[0], i[1]).add(i[0]), c = Ea);
      const d = i[a % r], h = i[(a + 1) % r];
      if (this.closed || a + 2 < r ? u = i[(a + 2) % r] : (Ea.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), u = Ea), this.curveType === "centripetal" || this.curveType === "chordal") {
        const f = this.curveType === "chordal" ? 0.5 : 0.25;
        let m = Math.pow(c.distanceToSquared(d), f), v = Math.pow(d.distanceToSquared(h), f), g = Math.pow(h.distanceToSquared(u), f);
        v < 1e-4 && (v = 1), m < 1e-4 && (m = v), g < 1e-4 && (g = v), Lc.initNonuniformCatmullRom(c.x, d.x, h.x, u.x, m, v, g), Dc.initNonuniformCatmullRom(c.y, d.y, h.y, u.y, m, v, g), Nc.initNonuniformCatmullRom(c.z, d.z, h.z, u.z, m, v, g);
      } else this.curveType === "catmullrom" && (Lc.initCatmullRom(c.x, d.x, h.x, u.x, this.tension), Dc.initCatmullRom(c.y, d.y, h.y, u.y, this.tension), Nc.initCatmullRom(c.z, d.z, h.z, u.z, this.tension));
      return n.set(Lc.calc(l), Dc.calc(l), Nc.calc(l)), n;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(i.clone());
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
    toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const i = this.points[t];
        e.points.push(i.toArray());
      }
      return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(new P().fromArray(i));
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
  }
  function uf(s, e, t, n, i) {
    const r = (n - e) * 0.5, o = (i - t) * 0.5, a = s * s, l = s * a;
    return (2 * t - 2 * n + r + o) * l + (-3 * t + 3 * n - 2 * r - o) * a + r * s + t;
  }
  function Gb(s, e) {
    const t = 1 - s;
    return t * t * e;
  }
  function Wb(s, e) {
    return 2 * (1 - s) * s * e;
  }
  function Xb(s, e) {
    return s * s * e;
  }
  function Jr(s, e, t, n) {
    return Gb(s, e) + Wb(s, t) + Xb(s, n);
  }
  function Yb(s, e) {
    const t = 1 - s;
    return t * t * t * e;
  }
  function qb(s, e) {
    const t = 1 - s;
    return 3 * t * t * s * e;
  }
  function $b(s, e) {
    return 3 * (1 - s) * s * s * e;
  }
  function Zb(s, e) {
    return s * s * s * e;
  }
  function Kr(s, e, t, n, i) {
    return Yb(s, e) + qb(s, t) + $b(s, n) + Zb(s, i);
  }
  class Su extends kn {
    constructor(e = new ee(), t = new ee(), n = new ee(), i = new ee()) {
      super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
    }
    getPoint(e, t = new ee()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
      return n.set(Kr(e, i.x, r.x, o.x, a.x), Kr(e, i.y, r.y, o.y, a.y)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
  }
  class rg extends kn {
    constructor(e = new P(), t = new P(), n = new P(), i = new P()) {
      super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
    }
    getPoint(e, t = new P()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
      return n.set(Kr(e, i.x, r.x, o.x, a.x), Kr(e, i.y, r.y, o.y, a.y), Kr(e, i.z, r.z, o.z, a.z)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
  }
  class wu extends kn {
    constructor(e = new ee(), t = new ee()) {
      super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new ee()) {
      const n = t;
      return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t = new ee()) {
      return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
      return this.getTangent(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class og extends kn {
    constructor(e = new P(), t = new P()) {
      super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new P()) {
      const n = t;
      return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t = new P()) {
      return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
      return this.getTangent(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class Tu extends kn {
    constructor(e = new ee(), t = new ee(), n = new ee()) {
      super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
    }
    getPoint(e, t = new ee()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2;
      return n.set(Jr(e, i.x, r.x, o.x), Jr(e, i.y, r.y, o.y)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class Eu extends kn {
    constructor(e = new P(), t = new P(), n = new P()) {
      super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
    }
    getPoint(e, t = new P()) {
      const n = t, i = this.v0, r = this.v1, o = this.v2;
      return n.set(Jr(e, i.x, r.x, o.x), Jr(e, i.y, r.y, o.y), Jr(e, i.z, r.z, o.z)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class Au extends kn {
    constructor(e = []) {
      super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
    }
    getPoint(e, t = new ee()) {
      const n = t, i = this.points, r = (i.length - 1) * e, o = Math.floor(r), a = r - o, l = i[o === 0 ? o : o - 1], c = i[o], u = i[o > i.length - 2 ? i.length - 1 : o + 1], d = i[o > i.length - 3 ? i.length - 1 : o + 2];
      return n.set(uf(a, l.x, c.x, u.x, d.x), uf(a, l.y, c.y, u.y, d.y)), n;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(i.clone());
      }
      return this;
    }
    toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const i = this.points[t];
        e.points.push(i.toArray());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(new ee().fromArray(i));
      }
      return this;
    }
  }
  var Ka = Object.freeze({
    __proto__: null,
    ArcCurve: ig,
    CatmullRomCurve3: sg,
    CubicBezierCurve: Su,
    CubicBezierCurve3: rg,
    EllipseCurve: Ll,
    LineCurve: wu,
    LineCurve3: og,
    QuadraticBezierCurve: Tu,
    QuadraticBezierCurve3: Eu,
    SplineCurve: Au
  });
  class ag extends kn {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(e) {
      this.curves.push(e);
    }
    closePath() {
      const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
      if (!e.equals(t)) {
        const n = e.isVector2 === true ? "LineCurve" : "LineCurve3";
        this.curves.push(new Ka[n](t, e));
      }
      return this;
    }
    getPoint(e, t) {
      const n = e * this.getLength(), i = this.getCurveLengths();
      let r = 0;
      for (; r < i.length; ) {
        if (i[r] >= n) {
          const o = i[r] - n, a = this.curves[r], l = a.getLength(), c = l === 0 ? 0 : 1 - o / l;
          return a.getPointAt(c, t);
        }
        r++;
      }
      return null;
    }
    getLength() {
      const e = this.getCurveLengths();
      return e[e.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      const e = [];
      let t = 0;
      for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
      return this.cacheLengths = e, e;
    }
    getSpacedPoints(e = 40) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
      const t = [];
      let n;
      for (let i = 0, r = this.curves; i < r.length; i++) {
        const o = r[i], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
        for (let c = 0; c < l.length; c++) {
          const u = l[c];
          n && n.equals(u) || (t.push(u), n = u);
        }
      }
      return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
    }
    copy(e) {
      super.copy(e), this.curves = [];
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const i = e.curves[t];
        this.curves.push(i.clone());
      }
      return this.autoClose = e.autoClose, this;
    }
    toJSON() {
      const e = super.toJSON();
      e.autoClose = this.autoClose, e.curves = [];
      for (let t = 0, n = this.curves.length; t < n; t++) {
        const i = this.curves[t];
        e.curves.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const i = e.curves[t];
        this.curves.push(new Ka[i.type]().fromJSON(i));
      }
      return this;
    }
  }
  class As extends ag {
    constructor(e) {
      super(), this.type = "Path", this.currentPoint = new ee(), e && this.setFromPoints(e);
    }
    setFromPoints(e) {
      this.moveTo(e[0].x, e[0].y);
      for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
      return this;
    }
    moveTo(e, t) {
      return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
      const n = new wu(this.currentPoint.clone(), new ee(e, t));
      return this.curves.push(n), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, n, i) {
      const r = new Tu(this.currentPoint.clone(), new ee(e, t), new ee(n, i));
      return this.curves.push(r), this.currentPoint.set(n, i), this;
    }
    bezierCurveTo(e, t, n, i, r, o) {
      const a = new Su(this.currentPoint.clone(), new ee(e, t), new ee(n, i), new ee(r, o));
      return this.curves.push(a), this.currentPoint.set(r, o), this;
    }
    splineThru(e) {
      const t = [
        this.currentPoint.clone()
      ].concat(e), n = new Au(t);
      return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, n, i, r, o) {
      const a = this.currentPoint.x, l = this.currentPoint.y;
      return this.absarc(e + a, t + l, n, i, r, o), this;
    }
    absarc(e, t, n, i, r, o) {
      return this.absellipse(e, t, n, n, i, r, o), this;
    }
    ellipse(e, t, n, i, r, o, a, l) {
      const c = this.currentPoint.x, u = this.currentPoint.y;
      return this.absellipse(e + c, t + u, n, i, r, o, a, l), this;
    }
    absellipse(e, t, n, i, r, o, a, l) {
      const c = new Ll(e, t, n, i, r, o, a, l);
      if (this.curves.length > 0) {
        const d = c.getPoint(0);
        d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
      }
      this.curves.push(c);
      const u = c.getPoint(1);
      return this.currentPoint.copy(u), this;
    }
    copy(e) {
      return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.currentPoint = this.currentPoint.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
    }
  }
  class zo extends We {
    constructor(e = [
      new ee(0, -0.5),
      new ee(0.5, 0),
      new ee(0, 0.5)
    ], t = 12, n = 0, i = Math.PI * 2) {
      super(), this.type = "LatheGeometry", this.parameters = {
        points: e,
        segments: t,
        phiStart: n,
        phiLength: i
      }, t = Math.floor(t), i = mt(i, 0, Math.PI * 2);
      const r = [], o = [], a = [], l = [], c = [], u = 1 / t, d = new P(), h = new ee(), f = new P(), m = new P(), v = new P();
      let g = 0, p = 0;
      for (let _ = 0; _ <= e.length - 1; _++) switch (_) {
        case 0:
          g = e[_ + 1].x - e[_].x, p = e[_ + 1].y - e[_].y, f.x = p * 1, f.y = -g, f.z = p * 0, v.copy(f), f.normalize(), l.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          l.push(v.x, v.y, v.z);
          break;
        default:
          g = e[_ + 1].x - e[_].x, p = e[_ + 1].y - e[_].y, f.x = p * 1, f.y = -g, f.z = p * 0, m.copy(f), f.x += v.x, f.y += v.y, f.z += v.z, f.normalize(), l.push(f.x, f.y, f.z), v.copy(m);
      }
      for (let _ = 0; _ <= t; _++) {
        const x = n + _ * u * i, b = Math.sin(x), E = Math.cos(x);
        for (let S = 0; S <= e.length - 1; S++) {
          d.x = e[S].x * b, d.y = e[S].y, d.z = e[S].x * E, o.push(d.x, d.y, d.z), h.x = _ / t, h.y = S / (e.length - 1), a.push(h.x, h.y);
          const w = l[3 * S + 0] * b, A = l[3 * S + 1], M = l[3 * S + 0] * E;
          c.push(w, A, M);
        }
      }
      for (let _ = 0; _ < t; _++) for (let x = 0; x < e.length - 1; x++) {
        const b = x + _ * e.length, E = b, S = b + e.length, w = b + e.length + 1, A = b + 1;
        r.push(E, S, A), r.push(w, A, S);
      }
      this.setIndex(r), this.setAttribute("position", new Ee(o, 3)), this.setAttribute("uv", new Ee(a, 2)), this.setAttribute("normal", new Ee(c, 3));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new zo(e.points, e.segments, e.phiStart, e.phiLength);
    }
  }
  class Dl extends zo {
    constructor(e = 1, t = 1, n = 4, i = 8) {
      const r = new As();
      r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
        radius: e,
        length: t,
        capSegments: n,
        radialSegments: i
      };
    }
    static fromJSON(e) {
      return new Dl(e.radius, e.length, e.capSegments, e.radialSegments);
    }
  }
  class Nl extends We {
    constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
      super(), this.type = "CircleGeometry", this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: i
      }, t = Math.max(3, t);
      const r = [], o = [], a = [], l = [], c = new P(), u = new ee();
      o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
      for (let d = 0, h = 3; d <= t; d++, h += 3) {
        const f = n + d / t * i;
        c.x = e * Math.cos(f), c.y = e * Math.sin(f), o.push(c.x, c.y, c.z), a.push(0, 0, 1), u.x = (o[h] / e + 1) / 2, u.y = (o[h + 1] / e + 1) / 2, l.push(u.x, u.y);
      }
      for (let d = 1; d <= t; d++) r.push(d, d + 1, 0);
      this.setIndex(r), this.setAttribute("position", new Ee(o, 3)), this.setAttribute("normal", new Ee(a, 3)), this.setAttribute("uv", new Ee(l, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Nl(e.radius, e.segments, e.thetaStart, e.thetaLength);
    }
  }
  class Sr extends We {
    constructor(e = 1, t = 1, n = 1, i = 32, r = 1, o = false, a = 0, l = Math.PI * 2) {
      super(), this.type = "CylinderGeometry", this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: r,
        openEnded: o,
        thetaStart: a,
        thetaLength: l
      };
      const c = this;
      i = Math.floor(i), r = Math.floor(r);
      const u = [], d = [], h = [], f = [];
      let m = 0;
      const v = [], g = n / 2;
      let p = 0;
      _(), o === false && (e > 0 && x(true), t > 0 && x(false)), this.setIndex(u), this.setAttribute("position", new Ee(d, 3)), this.setAttribute("normal", new Ee(h, 3)), this.setAttribute("uv", new Ee(f, 2));
      function _() {
        const b = new P(), E = new P();
        let S = 0;
        const w = (t - e) / n;
        for (let A = 0; A <= r; A++) {
          const M = [], y = A / r, C = y * (t - e) + e;
          for (let N = 0; N <= i; N++) {
            const I = N / i, D = I * l + a, O = Math.sin(D), z = Math.cos(D);
            E.x = C * O, E.y = -y * n + g, E.z = C * z, d.push(E.x, E.y, E.z), b.set(O, w, z).normalize(), h.push(b.x, b.y, b.z), f.push(I, 1 - y), M.push(m++);
          }
          v.push(M);
        }
        for (let A = 0; A < i; A++) for (let M = 0; M < r; M++) {
          const y = v[M][A], C = v[M + 1][A], N = v[M + 1][A + 1], I = v[M][A + 1];
          u.push(y, C, I), u.push(C, N, I), S += 6;
        }
        c.addGroup(p, S, 0), p += S;
      }
      function x(b) {
        const E = m, S = new ee(), w = new P();
        let A = 0;
        const M = b === true ? e : t, y = b === true ? 1 : -1;
        for (let N = 1; N <= i; N++) d.push(0, g * y, 0), h.push(0, y, 0), f.push(0.5, 0.5), m++;
        const C = m;
        for (let N = 0; N <= i; N++) {
          const D = N / i * l + a, O = Math.cos(D), z = Math.sin(D);
          w.x = M * z, w.y = g * y, w.z = M * O, d.push(w.x, w.y, w.z), h.push(0, y, 0), S.x = O * 0.5 + 0.5, S.y = z * 0.5 * y + 0.5, f.push(S.x, S.y), m++;
        }
        for (let N = 0; N < i; N++) {
          const I = E + N, D = C + N;
          b === true ? u.push(D, D + 1, I) : u.push(D + 1, D, I), A += 3;
        }
        c.addGroup(p, A, b === true ? 1 : 2), p += A;
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Sr(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
    }
  }
  class Ul extends Sr {
    constructor(e = 1, t = 1, n = 32, i = 1, r = false, o = 0, a = Math.PI * 2) {
      super(0, e, t, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: r,
        thetaStart: o,
        thetaLength: a
      };
    }
    static fromJSON(e) {
      return new Ul(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
    }
  }
  class Yi extends We {
    constructor(e = [], t = [], n = 1, i = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = {
        vertices: e,
        indices: t,
        radius: n,
        detail: i
      };
      const r = [], o = [];
      a(i), c(n), u(), this.setAttribute("position", new Ee(r, 3)), this.setAttribute("normal", new Ee(r.slice(), 3)), this.setAttribute("uv", new Ee(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
      function a(_) {
        const x = new P(), b = new P(), E = new P();
        for (let S = 0; S < t.length; S += 3) f(t[S + 0], x), f(t[S + 1], b), f(t[S + 2], E), l(x, b, E, _);
      }
      function l(_, x, b, E) {
        const S = E + 1, w = [];
        for (let A = 0; A <= S; A++) {
          w[A] = [];
          const M = _.clone().lerp(b, A / S), y = x.clone().lerp(b, A / S), C = S - A;
          for (let N = 0; N <= C; N++) N === 0 && A === S ? w[A][N] = M : w[A][N] = M.clone().lerp(y, N / C);
        }
        for (let A = 0; A < S; A++) for (let M = 0; M < 2 * (S - A) - 1; M++) {
          const y = Math.floor(M / 2);
          M % 2 === 0 ? (h(w[A][y + 1]), h(w[A + 1][y]), h(w[A][y])) : (h(w[A][y + 1]), h(w[A + 1][y + 1]), h(w[A + 1][y]));
        }
      }
      function c(_) {
        const x = new P();
        for (let b = 0; b < r.length; b += 3) x.x = r[b + 0], x.y = r[b + 1], x.z = r[b + 2], x.normalize().multiplyScalar(_), r[b + 0] = x.x, r[b + 1] = x.y, r[b + 2] = x.z;
      }
      function u() {
        const _ = new P();
        for (let x = 0; x < r.length; x += 3) {
          _.x = r[x + 0], _.y = r[x + 1], _.z = r[x + 2];
          const b = g(_) / 2 / Math.PI + 0.5, E = p(_) / Math.PI + 0.5;
          o.push(b, 1 - E);
        }
        m(), d();
      }
      function d() {
        for (let _ = 0; _ < o.length; _ += 6) {
          const x = o[_ + 0], b = o[_ + 2], E = o[_ + 4], S = Math.max(x, b, E), w = Math.min(x, b, E);
          S > 0.9 && w < 0.1 && (x < 0.2 && (o[_ + 0] += 1), b < 0.2 && (o[_ + 2] += 1), E < 0.2 && (o[_ + 4] += 1));
        }
      }
      function h(_) {
        r.push(_.x, _.y, _.z);
      }
      function f(_, x) {
        const b = _ * 3;
        x.x = e[b + 0], x.y = e[b + 1], x.z = e[b + 2];
      }
      function m() {
        const _ = new P(), x = new P(), b = new P(), E = new P(), S = new ee(), w = new ee(), A = new ee();
        for (let M = 0, y = 0; M < r.length; M += 9, y += 6) {
          _.set(r[M + 0], r[M + 1], r[M + 2]), x.set(r[M + 3], r[M + 4], r[M + 5]), b.set(r[M + 6], r[M + 7], r[M + 8]), S.set(o[y + 0], o[y + 1]), w.set(o[y + 2], o[y + 3]), A.set(o[y + 4], o[y + 5]), E.copy(_).add(x).add(b).divideScalar(3);
          const C = g(E);
          v(S, y + 0, _, C), v(w, y + 2, x, C), v(A, y + 4, b, C);
        }
      }
      function v(_, x, b, E) {
        E < 0 && _.x === 1 && (o[x] = _.x - 1), b.x === 0 && b.z === 0 && (o[x] = E / 2 / Math.PI + 0.5);
      }
      function g(_) {
        return Math.atan2(_.z, -_.x);
      }
      function p(_) {
        return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Yi(e.vertices, e.indices, e.radius, e.details);
    }
  }
  class Ol extends Yi {
    constructor(e = 1, t = 0) {
      const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i
      ], o = [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ];
      super(r, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new Ol(e.radius, e.detail);
    }
  }
  const Aa = new P(), Ca = new P(), Uc = new P(), Ra = new un();
  class lg extends We {
    constructor(e = null, t = 1) {
      if (super(), this.type = "EdgesGeometry", this.parameters = {
        geometry: e,
        thresholdAngle: t
      }, e !== null) {
        const i = Math.pow(10, 4), r = Math.cos(ws * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, c = [
          0,
          0,
          0
        ], u = [
          "a",
          "b",
          "c"
        ], d = new Array(3), h = {}, f = [];
        for (let m = 0; m < l; m += 3) {
          o ? (c[0] = o.getX(m), c[1] = o.getX(m + 1), c[2] = o.getX(m + 2)) : (c[0] = m, c[1] = m + 1, c[2] = m + 2);
          const { a: v, b: g, c: p } = Ra;
          if (v.fromBufferAttribute(a, c[0]), g.fromBufferAttribute(a, c[1]), p.fromBufferAttribute(a, c[2]), Ra.getNormal(Uc), d[0] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${Math.round(v.z * i)}`, d[1] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(g.z * i)}`, d[2] = `${Math.round(p.x * i)},${Math.round(p.y * i)},${Math.round(p.z * i)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let _ = 0; _ < 3; _++) {
            const x = (_ + 1) % 3, b = d[_], E = d[x], S = Ra[u[_]], w = Ra[u[x]], A = `${b}_${E}`, M = `${E}_${b}`;
            M in h && h[M] ? (Uc.dot(h[M].normal) <= r && (f.push(S.x, S.y, S.z), f.push(w.x, w.y, w.z)), h[M] = null) : A in h || (h[A] = {
              index0: c[_],
              index1: c[x],
              normal: Uc.clone()
            });
          }
        }
        for (const m in h) if (h[m]) {
          const { index0: v, index1: g } = h[m];
          Aa.fromBufferAttribute(a, v), Ca.fromBufferAttribute(a, g), f.push(Aa.x, Aa.y, Aa.z), f.push(Ca.x, Ca.y, Ca.z);
        }
        this.setAttribute("position", new Ee(f, 3));
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
  }
  class Pt extends As {
    constructor(e) {
      super(e), this.uuid = fn(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e) {
      const t = [];
      for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
      return t;
    }
    extractPoints(e) {
      return {
        shape: this.getPoints(e),
        holes: this.getPointsHoles(e)
      };
    }
    copy(e) {
      super.copy(e), this.holes = [];
      for (let t = 0, n = e.holes.length; t < n; t++) {
        const i = e.holes[t];
        this.holes.push(i.clone());
      }
      return this;
    }
    toJSON() {
      const e = super.toJSON();
      e.uuid = this.uuid, e.holes = [];
      for (let t = 0, n = this.holes.length; t < n; t++) {
        const i = this.holes[t];
        e.holes.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
      for (let t = 0, n = e.holes.length; t < n; t++) {
        const i = e.holes[t];
        this.holes.push(new As().fromJSON(i));
      }
      return this;
    }
  }
  const Jb = {
    triangulate: function(s, e, t = 2) {
      const n = e && e.length, i = n ? e[0] * t : s.length;
      let r = cg(s, 0, i, t, true);
      const o = [];
      if (!r || r.next === r.prev) return o;
      let a, l, c, u, d, h, f;
      if (n && (r = tS(s, e, r, t)), s.length > 80 * t) {
        a = c = s[0], l = u = s[1];
        for (let m = t; m < i; m += t) d = s[m], h = s[m + 1], d < a && (a = d), h < l && (l = h), d > c && (c = d), h > u && (u = h);
        f = Math.max(c - a, u - l), f = f !== 0 ? 32767 / f : 0;
      }
      return go(r, o, t, a, l, f, 0), o;
    }
  };
  function cg(s, e, t, n, i) {
    let r, o;
    if (i === dS(s, e, t, n) > 0) for (r = e; r < t; r += n) o = df(r, s[r], s[r + 1], o);
    else for (r = t - n; r >= e; r -= n) o = df(r, s[r], s[r + 1], o);
    return o && zl(o, o.next) && (xo(o), o = o.next), o;
  }
  function Cs(s, e) {
    if (!s) return s;
    e || (e = s);
    let t = s, n;
    do
      if (n = false, !t.steiner && (zl(t, t.next) || dt(t.prev, t, t.next) === 0)) {
        if (xo(t), t = e = t.prev, t === t.next) break;
        n = true;
      } else t = t.next;
    while (n || t !== e);
    return e;
  }
  function go(s, e, t, n, i, r, o) {
    if (!s) return;
    !o && r && oS(s, n, i, r);
    let a = s, l, c;
    for (; s.prev !== s.next; ) {
      if (l = s.prev, c = s.next, r ? jb(s, n, i, r) : Kb(s)) {
        e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(c.i / t | 0), xo(s), s = c.next, a = c.next;
        continue;
      }
      if (s = c, s === a) {
        o ? o === 1 ? (s = Qb(Cs(s), e, t), go(s, e, t, n, i, r, 2)) : o === 2 && eS(s, e, t, n, i, r) : go(Cs(s), e, t, n, i, r, 1);
        break;
      }
    }
  }
  function Kb(s) {
    const e = s.prev, t = s, n = s.next;
    if (dt(e, t, n) >= 0) return false;
    const i = e.x, r = t.x, o = n.x, a = e.y, l = t.y, c = n.y, u = i < r ? i < o ? i : o : r < o ? r : o, d = a < l ? a < c ? a : c : l < c ? l : c, h = i > r ? i > o ? i : o : r > o ? r : o, f = a > l ? a > c ? a : c : l > c ? l : c;
    let m = n.next;
    for (; m !== e; ) {
      if (m.x >= u && m.x <= h && m.y >= d && m.y <= f && nr(i, a, r, l, o, c, m.x, m.y) && dt(m.prev, m, m.next) >= 0) return false;
      m = m.next;
    }
    return true;
  }
  function jb(s, e, t, n) {
    const i = s.prev, r = s, o = s.next;
    if (dt(i, r, o) >= 0) return false;
    const a = i.x, l = r.x, c = o.x, u = i.y, d = r.y, h = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, m = u < d ? u < h ? u : h : d < h ? d : h, v = a > l ? a > c ? a : c : l > c ? l : c, g = u > d ? u > h ? u : h : d > h ? d : h, p = Dh(f, m, e, t, n), _ = Dh(v, g, e, t, n);
    let x = s.prevZ, b = s.nextZ;
    for (; x && x.z >= p && b && b.z <= _; ) {
      if (x.x >= f && x.x <= v && x.y >= m && x.y <= g && x !== i && x !== o && nr(a, u, l, d, c, h, x.x, x.y) && dt(x.prev, x, x.next) >= 0 || (x = x.prevZ, b.x >= f && b.x <= v && b.y >= m && b.y <= g && b !== i && b !== o && nr(a, u, l, d, c, h, b.x, b.y) && dt(b.prev, b, b.next) >= 0)) return false;
      b = b.nextZ;
    }
    for (; x && x.z >= p; ) {
      if (x.x >= f && x.x <= v && x.y >= m && x.y <= g && x !== i && x !== o && nr(a, u, l, d, c, h, x.x, x.y) && dt(x.prev, x, x.next) >= 0) return false;
      x = x.prevZ;
    }
    for (; b && b.z <= _; ) {
      if (b.x >= f && b.x <= v && b.y >= m && b.y <= g && b !== i && b !== o && nr(a, u, l, d, c, h, b.x, b.y) && dt(b.prev, b, b.next) >= 0) return false;
      b = b.nextZ;
    }
    return true;
  }
  function Qb(s, e, t) {
    let n = s;
    do {
      const i = n.prev, r = n.next.next;
      !zl(i, r) && hg(i, n, n.next, r) && vo(i, r) && vo(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), xo(n), xo(n.next), n = s = r), n = n.next;
    } while (n !== s);
    return Cs(n);
  }
  function eS(s, e, t, n, i, r) {
    let o = s;
    do {
      let a = o.next.next;
      for (; a !== o.prev; ) {
        if (o.i !== a.i && cS(o, a)) {
          let l = ug(o, a);
          o = Cs(o, o.next), l = Cs(l, l.next), go(o, e, t, n, i, r, 0), go(l, e, t, n, i, r, 0);
          return;
        }
        a = a.next;
      }
      o = o.next;
    } while (o !== s);
  }
  function tS(s, e, t, n) {
    const i = [];
    let r, o, a, l, c;
    for (r = 0, o = e.length; r < o; r++) a = e[r] * n, l = r < o - 1 ? e[r + 1] * n : s.length, c = cg(s, a, l, n, false), c === c.next && (c.steiner = true), i.push(lS(c));
    for (i.sort(nS), r = 0; r < i.length; r++) t = iS(i[r], t);
    return t;
  }
  function nS(s, e) {
    return s.x - e.x;
  }
  function iS(s, e) {
    const t = sS(s, e);
    if (!t) return e;
    const n = ug(t, s);
    return Cs(n, n.next), Cs(t, t.next);
  }
  function sS(s, e) {
    let t = e, n = -1 / 0, i;
    const r = s.x, o = s.y;
    do {
      if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
        const h = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
        if (h <= r && h > n && (n = h, i = t.x < t.next.x ? t : t.next, h === r)) return i;
      }
      t = t.next;
    } while (t !== e);
    if (!i) return null;
    const a = i, l = i.x, c = i.y;
    let u = 1 / 0, d;
    t = i;
    do
      r >= t.x && t.x >= l && r !== t.x && nr(o < c ? r : n, o, l, c, o < c ? n : r, o, t.x, t.y) && (d = Math.abs(o - t.y) / (r - t.x), vo(t, s) && (d < u || d === u && (t.x > i.x || t.x === i.x && rS(i, t))) && (i = t, u = d)), t = t.next;
    while (t !== a);
    return i;
  }
  function rS(s, e) {
    return dt(s.prev, s, e.prev) < 0 && dt(e.next, s, s.next) < 0;
  }
  function oS(s, e, t, n) {
    let i = s;
    do
      i.z === 0 && (i.z = Dh(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
    while (i !== s);
    i.prevZ.nextZ = null, i.prevZ = null, aS(i);
  }
  function aS(s) {
    let e, t, n, i, r, o, a, l, c = 1;
    do {
      for (t = s, s = null, r = null, o = 0; t; ) {
        for (o++, n = t, a = 0, e = 0; e < c && (a++, n = n.nextZ, !!n); e++) ;
        for (l = c; a > 0 || l > 0 && n; ) a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, l--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
        t = n;
      }
      r.nextZ = null, c *= 2;
    } while (o > 1);
    return s;
  }
  function Dh(s, e, t, n, i) {
    return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
  }
  function lS(s) {
    let e = s, t = s;
    do
      (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
    while (e !== s);
    return t;
  }
  function nr(s, e, t, n, i, r, o, a) {
    return (i - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (i - o) * (n - a);
  }
  function cS(s, e) {
    return s.next.i !== e.i && s.prev.i !== e.i && !hS(s, e) && (vo(s, e) && vo(e, s) && uS(s, e) && (dt(s.prev, s, e.prev) || dt(s, e.prev, e)) || zl(s, e) && dt(s.prev, s, s.next) > 0 && dt(e.prev, e, e.next) > 0);
  }
  function dt(s, e, t) {
    return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
  }
  function zl(s, e) {
    return s.x === e.x && s.y === e.y;
  }
  function hg(s, e, t, n) {
    const i = Ia(dt(s, e, t)), r = Ia(dt(s, e, n)), o = Ia(dt(t, n, s)), a = Ia(dt(t, n, e));
    return !!(i !== r && o !== a || i === 0 && Pa(s, t, e) || r === 0 && Pa(s, n, e) || o === 0 && Pa(t, s, n) || a === 0 && Pa(t, e, n));
  }
  function Pa(s, e, t) {
    return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
  }
  function Ia(s) {
    return s > 0 ? 1 : s < 0 ? -1 : 0;
  }
  function hS(s, e) {
    let t = s;
    do {
      if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && hg(t, t.next, s, e)) return true;
      t = t.next;
    } while (t !== s);
    return false;
  }
  function vo(s, e) {
    return dt(s.prev, s, s.next) < 0 ? dt(s, e, s.next) >= 0 && dt(s, s.prev, e) >= 0 : dt(s, e, s.prev) < 0 || dt(s, s.next, e) < 0;
  }
  function uS(s, e) {
    let t = s, n = false;
    const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
    do
      t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
    while (t !== s);
    return n;
  }
  function ug(s, e) {
    const t = new Nh(s.i, s.x, s.y), n = new Nh(e.i, e.x, e.y), i = s.next, r = e.prev;
    return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
  }
  function df(s, e, t, n) {
    const i = new Nh(s, e, t);
    return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
  }
  function xo(s) {
    s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
  }
  function Nh(s, e, t) {
    this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function dS(s, e, t, n) {
    let i = 0;
    for (let r = e, o = t - n; r < t; r += n) i += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
    return i;
  }
  class qn {
    static area(e) {
      const t = e.length;
      let n = 0;
      for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
      return n * 0.5;
    }
    static isClockWise(e) {
      return qn.area(e) < 0;
    }
    static triangulateShape(e, t) {
      const n = [], i = [], r = [];
      ff(e), pf(n, e);
      let o = e.length;
      t.forEach(ff);
      for (let l = 0; l < t.length; l++) i.push(o), o += t[l].length, pf(n, t[l]);
      const a = Jb.triangulate(n, i);
      for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
      return r;
    }
  }
  function ff(s) {
    const e = s.length;
    e > 2 && s[e - 1].equals(s[0]) && s.pop();
  }
  function pf(s, e) {
    for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
  }
  class ln extends We {
    constructor(e = new Pt([
      new ee(0.5, 0.5),
      new ee(-0.5, 0.5),
      new ee(-0.5, -0.5),
      new ee(0.5, -0.5)
    ]), t = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = {
        shapes: e,
        options: t
      }, e = Array.isArray(e) ? e : [
        e
      ];
      const n = this, i = [], r = [];
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a];
        o(c);
      }
      this.setAttribute("position", new Ee(i, 3)), this.setAttribute("uv", new Ee(r, 2)), this.computeVertexNormals();
      function o(a) {
        const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1;
        let h = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1, v = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
        const p = t.extrudePath, _ = t.UVGenerator !== void 0 ? t.UVGenerator : fS;
        let x, b = false, E, S, w, A;
        p && (x = p.getSpacedPoints(u), b = true, h = false, E = p.computeFrenetFrames(u, false), S = new P(), w = new P(), A = new P()), h || (g = 0, f = 0, m = 0, v = 0);
        const M = a.extractPoints(c);
        let y = M.shape;
        const C = M.holes;
        if (!qn.isClockWise(y)) {
          y = y.reverse();
          for (let J = 0, ie = C.length; J < ie; J++) {
            const Z = C[J];
            qn.isClockWise(Z) && (C[J] = Z.reverse());
          }
        }
        const I = qn.triangulateShape(y, C), D = y;
        for (let J = 0, ie = C.length; J < ie; J++) {
          const Z = C[J];
          y = y.concat(Z);
        }
        function O(J, ie, Z) {
          return ie || console.error("THREE.ExtrudeGeometry: vec does not exist"), J.clone().addScaledVector(ie, Z);
        }
        const z = y.length, B = I.length;
        function U(J, ie, Z) {
          let le, se, ve;
          const Ce = J.x - ie.x, L = J.y - ie.y, T = Z.x - J.x, W = Z.y - J.y, Q = Ce * Ce + L * L, ae = Ce * W - L * T;
          if (Math.abs(ae) > Number.EPSILON) {
            const ne = Math.sqrt(Q), Ie = Math.sqrt(T * T + W * W), ge = ie.x - L / ne, me = ie.y + Ce / ne, ke = Z.x - W / Ie, he = Z.y + T / Ie, Pe = ((ke - ge) * W - (he - me) * T) / (Ce * W - L * T);
            le = ge + Ce * Pe - J.x, se = me + L * Pe - J.y;
            const Ze = le * le + se * se;
            if (Ze <= 2) return new ee(le, se);
            ve = Math.sqrt(Ze / 2);
          } else {
            let ne = false;
            Ce > Number.EPSILON ? T > Number.EPSILON && (ne = true) : Ce < -Number.EPSILON ? T < -Number.EPSILON && (ne = true) : Math.sign(L) === Math.sign(W) && (ne = true), ne ? (le = -L, se = Ce, ve = Math.sqrt(Q)) : (le = Ce, se = L, ve = Math.sqrt(Q / 2));
          }
          return new ee(le / ve, se / ve);
        }
        const G = [];
        for (let J = 0, ie = D.length, Z = ie - 1, le = J + 1; J < ie; J++, Z++, le++) Z === ie && (Z = 0), le === ie && (le = 0), G[J] = U(D[J], D[Z], D[le]);
        const V = [];
        let K, ce = G.concat();
        for (let J = 0, ie = C.length; J < ie; J++) {
          const Z = C[J];
          K = [];
          for (let le = 0, se = Z.length, ve = se - 1, Ce = le + 1; le < se; le++, ve++, Ce++) ve === se && (ve = 0), Ce === se && (Ce = 0), K[le] = U(Z[le], Z[ve], Z[Ce]);
          V.push(K), ce = ce.concat(K);
        }
        for (let J = 0; J < g; J++) {
          const ie = J / g, Z = f * Math.cos(ie * Math.PI / 2), le = m * Math.sin(ie * Math.PI / 2) + v;
          for (let se = 0, ve = D.length; se < ve; se++) {
            const Ce = O(D[se], G[se], le);
            oe(Ce.x, Ce.y, -Z);
          }
          for (let se = 0, ve = C.length; se < ve; se++) {
            const Ce = C[se];
            K = V[se];
            for (let L = 0, T = Ce.length; L < T; L++) {
              const W = O(Ce[L], K[L], le);
              oe(W.x, W.y, -Z);
            }
          }
        }
        const Te = m + v;
        for (let J = 0; J < z; J++) {
          const ie = h ? O(y[J], ce[J], Te) : y[J];
          b ? (w.copy(E.normals[0]).multiplyScalar(ie.x), S.copy(E.binormals[0]).multiplyScalar(ie.y), A.copy(x[0]).add(w).add(S), oe(A.x, A.y, A.z)) : oe(ie.x, ie.y, 0);
        }
        for (let J = 1; J <= u; J++) for (let ie = 0; ie < z; ie++) {
          const Z = h ? O(y[ie], ce[ie], Te) : y[ie];
          b ? (w.copy(E.normals[J]).multiplyScalar(Z.x), S.copy(E.binormals[J]).multiplyScalar(Z.y), A.copy(x[J]).add(w).add(S), oe(A.x, A.y, A.z)) : oe(Z.x, Z.y, d / u * J);
        }
        for (let J = g - 1; J >= 0; J--) {
          const ie = J / g, Z = f * Math.cos(ie * Math.PI / 2), le = m * Math.sin(ie * Math.PI / 2) + v;
          for (let se = 0, ve = D.length; se < ve; se++) {
            const Ce = O(D[se], G[se], le);
            oe(Ce.x, Ce.y, d + Z);
          }
          for (let se = 0, ve = C.length; se < ve; se++) {
            const Ce = C[se];
            K = V[se];
            for (let L = 0, T = Ce.length; L < T; L++) {
              const W = O(Ce[L], K[L], le);
              b ? oe(W.x, W.y + x[u - 1].y, x[u - 1].x + Z) : oe(W.x, W.y, d + Z);
            }
          }
        }
        q(), te();
        function q() {
          const J = i.length / 3;
          if (h) {
            let ie = 0, Z = z * ie;
            for (let le = 0; le < B; le++) {
              const se = I[le];
              fe(se[2] + Z, se[1] + Z, se[0] + Z);
            }
            ie = u + g * 2, Z = z * ie;
            for (let le = 0; le < B; le++) {
              const se = I[le];
              fe(se[0] + Z, se[1] + Z, se[2] + Z);
            }
          } else {
            for (let ie = 0; ie < B; ie++) {
              const Z = I[ie];
              fe(Z[2], Z[1], Z[0]);
            }
            for (let ie = 0; ie < B; ie++) {
              const Z = I[ie];
              fe(Z[0] + z * u, Z[1] + z * u, Z[2] + z * u);
            }
          }
          n.addGroup(J, i.length / 3 - J, 0);
        }
        function te() {
          const J = i.length / 3;
          let ie = 0;
          de(D, ie), ie += D.length;
          for (let Z = 0, le = C.length; Z < le; Z++) {
            const se = C[Z];
            de(se, ie), ie += se.length;
          }
          n.addGroup(J, i.length / 3 - J, 1);
        }
        function de(J, ie) {
          let Z = J.length;
          for (; --Z >= 0; ) {
            const le = Z;
            let se = Z - 1;
            se < 0 && (se = J.length - 1);
            for (let ve = 0, Ce = u + g * 2; ve < Ce; ve++) {
              const L = z * ve, T = z * (ve + 1), W = ie + le + L, Q = ie + se + L, ae = ie + se + T, ne = ie + le + T;
              be(W, Q, ae, ne);
            }
          }
        }
        function oe(J, ie, Z) {
          l.push(J), l.push(ie), l.push(Z);
        }
        function fe(J, ie, Z) {
          F(J), F(ie), F(Z);
          const le = i.length / 3, se = _.generateTopUV(n, i, le - 3, le - 2, le - 1);
          Le(se[0]), Le(se[1]), Le(se[2]);
        }
        function be(J, ie, Z, le) {
          F(J), F(ie), F(le), F(ie), F(Z), F(le);
          const se = i.length / 3, ve = _.generateSideWallUV(n, i, se - 6, se - 3, se - 2, se - 1);
          Le(ve[0]), Le(ve[1]), Le(ve[3]), Le(ve[1]), Le(ve[2]), Le(ve[3]);
        }
        function F(J) {
          i.push(l[J * 3 + 0]), i.push(l[J * 3 + 1]), i.push(l[J * 3 + 2]);
        }
        function Le(J) {
          r.push(J.x), r.push(J.y);
        }
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    toJSON() {
      const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
      return pS(t, n, e);
    }
    static fromJSON(e, t) {
      const n = [];
      for (let r = 0, o = e.shapes.length; r < o; r++) {
        const a = t[e.shapes[r]];
        n.push(a);
      }
      const i = e.options.extrudePath;
      return i !== void 0 && (e.options.extrudePath = new Ka[i.type]().fromJSON(i)), new ln(n, e.options);
    }
  }
  const fS = {
    generateTopUV: function(s, e, t, n, i) {
      const r = e[t * 3], o = e[t * 3 + 1], a = e[n * 3], l = e[n * 3 + 1], c = e[i * 3], u = e[i * 3 + 1];
      return [
        new ee(r, o),
        new ee(a, l),
        new ee(c, u)
      ];
    },
    generateSideWallUV: function(s, e, t, n, i, r) {
      const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], c = e[n * 3], u = e[n * 3 + 1], d = e[n * 3 + 2], h = e[i * 3], f = e[i * 3 + 1], m = e[i * 3 + 2], v = e[r * 3], g = e[r * 3 + 1], p = e[r * 3 + 2];
      return Math.abs(a - u) < Math.abs(o - c) ? [
        new ee(o, 1 - l),
        new ee(c, 1 - d),
        new ee(h, 1 - m),
        new ee(v, 1 - p)
      ] : [
        new ee(a, 1 - l),
        new ee(u, 1 - d),
        new ee(f, 1 - m),
        new ee(g, 1 - p)
      ];
    }
  };
  function pS(s, e, t) {
    if (t.shapes = [], Array.isArray(s)) for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
    else t.shapes.push(s.uuid);
    return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
  }
  class Fl extends Yi {
    constructor(e = 1, t = 0) {
      const n = (1 + Math.sqrt(5)) / 2, i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1
      ], r = [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ];
      super(i, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new Fl(e.radius, e.detail);
    }
  }
  class Fo extends Yi {
    constructor(e = 1, t = 0) {
      const n = [
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1
      ], i = [
        0,
        2,
        4,
        0,
        4,
        3,
        0,
        3,
        5,
        0,
        5,
        2,
        1,
        2,
        5,
        1,
        5,
        3,
        1,
        3,
        4,
        1,
        4,
        2
      ];
      super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new Fo(e.radius, e.detail);
    }
  }
  class Bl extends We {
    constructor(e = 0.5, t = 1, n = 32, i = 1, r = 0, o = Math.PI * 2) {
      super(), this.type = "RingGeometry", this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: r,
        thetaLength: o
      }, n = Math.max(3, n), i = Math.max(1, i);
      const a = [], l = [], c = [], u = [];
      let d = e;
      const h = (t - e) / i, f = new P(), m = new ee();
      for (let v = 0; v <= i; v++) {
        for (let g = 0; g <= n; g++) {
          const p = r + g / n * o;
          f.x = d * Math.cos(p), f.y = d * Math.sin(p), l.push(f.x, f.y, f.z), c.push(0, 0, 1), m.x = (f.x / t + 1) / 2, m.y = (f.y / t + 1) / 2, u.push(m.x, m.y);
        }
        d += h;
      }
      for (let v = 0; v < i; v++) {
        const g = v * (n + 1);
        for (let p = 0; p < n; p++) {
          const _ = p + g, x = _, b = _ + n + 1, E = _ + n + 2, S = _ + 1;
          a.push(x, b, S), a.push(b, E, S);
        }
      }
      this.setIndex(a), this.setAttribute("position", new Ee(l, 3)), this.setAttribute("normal", new Ee(c, 3)), this.setAttribute("uv", new Ee(u, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Bl(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
    }
  }
  class Bo extends We {
    constructor(e = new Pt([
      new ee(0, 0.5),
      new ee(-0.5, -0.5),
      new ee(0.5, -0.5)
    ]), t = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = {
        shapes: e,
        curveSegments: t
      };
      const n = [], i = [], r = [], o = [];
      let a = 0, l = 0;
      if (Array.isArray(e) === false) c(e);
      else for (let u = 0; u < e.length; u++) c(e[u]), this.addGroup(a, l, u), a += l, l = 0;
      this.setIndex(n), this.setAttribute("position", new Ee(i, 3)), this.setAttribute("normal", new Ee(r, 3)), this.setAttribute("uv", new Ee(o, 2));
      function c(u) {
        const d = i.length / 3, h = u.extractPoints(t);
        let f = h.shape;
        const m = h.holes;
        qn.isClockWise(f) === false && (f = f.reverse());
        for (let g = 0, p = m.length; g < p; g++) {
          const _ = m[g];
          qn.isClockWise(_) === true && (m[g] = _.reverse());
        }
        const v = qn.triangulateShape(f, m);
        for (let g = 0, p = m.length; g < p; g++) {
          const _ = m[g];
          f = f.concat(_);
        }
        for (let g = 0, p = f.length; g < p; g++) {
          const _ = f[g];
          i.push(_.x, _.y, 0), r.push(0, 0, 1), o.push(_.x, _.y);
        }
        for (let g = 0, p = v.length; g < p; g++) {
          const _ = v[g], x = _[0] + d, b = _[1] + d, E = _[2] + d;
          n.push(x, b, E), l += 3;
        }
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    toJSON() {
      const e = super.toJSON(), t = this.parameters.shapes;
      return mS(t, e);
    }
    static fromJSON(e, t) {
      const n = [];
      for (let i = 0, r = e.shapes.length; i < r; i++) {
        const o = t[e.shapes[i]];
        n.push(o);
      }
      return new Bo(n, e.curveSegments);
    }
  }
  function mS(s, e) {
    if (e.shapes = [], Array.isArray(s)) for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
    else e.shapes.push(s.uuid);
    return e;
  }
  class ko extends We {
    constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: a
      }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
      const l = Math.min(o + a, Math.PI);
      let c = 0;
      const u = [], d = new P(), h = new P(), f = [], m = [], v = [], g = [];
      for (let p = 0; p <= n; p++) {
        const _ = [], x = p / n;
        let b = 0;
        p === 0 && o === 0 ? b = 0.5 / t : p === n && l === Math.PI && (b = -0.5 / t);
        for (let E = 0; E <= t; E++) {
          const S = E / t;
          d.x = -e * Math.cos(i + S * r) * Math.sin(o + x * a), d.y = e * Math.cos(o + x * a), d.z = e * Math.sin(i + S * r) * Math.sin(o + x * a), m.push(d.x, d.y, d.z), h.copy(d).normalize(), v.push(h.x, h.y, h.z), g.push(S + b, 1 - x), _.push(c++);
        }
        u.push(_);
      }
      for (let p = 0; p < n; p++) for (let _ = 0; _ < t; _++) {
        const x = u[p][_ + 1], b = u[p][_], E = u[p + 1][_], S = u[p + 1][_ + 1];
        (p !== 0 || o > 0) && f.push(x, b, S), (p !== n - 1 || l < Math.PI) && f.push(b, E, S);
      }
      this.setIndex(f), this.setAttribute("position", new Ee(m, 3)), this.setAttribute("normal", new Ee(v, 3)), this.setAttribute("uv", new Ee(g, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new ko(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
    }
  }
  class kl extends Yi {
    constructor(e = 1, t = 0) {
      const n = [
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        1,
        -1,
        -1
      ], i = [
        2,
        1,
        0,
        0,
        3,
        2,
        1,
        3,
        0,
        2,
        3,
        1
      ];
      super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new kl(e.radius, e.detail);
    }
  }
  class Vl extends We {
    constructor(e = 1, t = 0.4, n = 12, i = 48, r = Math.PI * 2) {
      super(), this.type = "TorusGeometry", this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: i,
        arc: r
      }, n = Math.floor(n), i = Math.floor(i);
      const o = [], a = [], l = [], c = [], u = new P(), d = new P(), h = new P();
      for (let f = 0; f <= n; f++) for (let m = 0; m <= i; m++) {
        const v = m / i * r, g = f / n * Math.PI * 2;
        d.x = (e + t * Math.cos(g)) * Math.cos(v), d.y = (e + t * Math.cos(g)) * Math.sin(v), d.z = t * Math.sin(g), a.push(d.x, d.y, d.z), u.x = e * Math.cos(v), u.y = e * Math.sin(v), h.subVectors(d, u).normalize(), l.push(h.x, h.y, h.z), c.push(m / i), c.push(f / n);
      }
      for (let f = 1; f <= n; f++) for (let m = 1; m <= i; m++) {
        const v = (i + 1) * f + m - 1, g = (i + 1) * (f - 1) + m - 1, p = (i + 1) * (f - 1) + m, _ = (i + 1) * f + m;
        o.push(v, g, _), o.push(g, p, _);
      }
      this.setIndex(o), this.setAttribute("position", new Ee(a, 3)), this.setAttribute("normal", new Ee(l, 3)), this.setAttribute("uv", new Ee(c, 2));
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Vl(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
    }
  }
  class Hl extends We {
    constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, o = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: i,
        p: r,
        q: o
      }, n = Math.floor(n), i = Math.floor(i);
      const a = [], l = [], c = [], u = [], d = new P(), h = new P(), f = new P(), m = new P(), v = new P(), g = new P(), p = new P();
      for (let x = 0; x <= n; ++x) {
        const b = x / n * r * Math.PI * 2;
        _(b, r, o, e, f), _(b + 0.01, r, o, e, m), g.subVectors(m, f), p.addVectors(m, f), v.crossVectors(g, p), p.crossVectors(v, g), v.normalize(), p.normalize();
        for (let E = 0; E <= i; ++E) {
          const S = E / i * Math.PI * 2, w = -t * Math.cos(S), A = t * Math.sin(S);
          d.x = f.x + (w * p.x + A * v.x), d.y = f.y + (w * p.y + A * v.y), d.z = f.z + (w * p.z + A * v.z), l.push(d.x, d.y, d.z), h.subVectors(d, f).normalize(), c.push(h.x, h.y, h.z), u.push(x / n), u.push(E / i);
        }
      }
      for (let x = 1; x <= n; x++) for (let b = 1; b <= i; b++) {
        const E = (i + 1) * (x - 1) + (b - 1), S = (i + 1) * x + (b - 1), w = (i + 1) * x + b, A = (i + 1) * (x - 1) + b;
        a.push(E, S, A), a.push(S, w, A);
      }
      this.setIndex(a), this.setAttribute("position", new Ee(l, 3)), this.setAttribute("normal", new Ee(c, 3)), this.setAttribute("uv", new Ee(u, 2));
      function _(x, b, E, S, w) {
        const A = Math.cos(x), M = Math.sin(x), y = E / b * x, C = Math.cos(y);
        w.x = S * (2 + C) * 0.5 * A, w.y = S * (2 + C) * M * 0.5, w.z = S * Math.sin(y) * 0.5;
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    static fromJSON(e) {
      return new Hl(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
    }
  }
  class Gl extends We {
    constructor(e = new Eu(new P(-1, -1, 0), new P(-1, 1, 0), new P(1, 1, 0)), t = 64, n = 1, i = 8, r = false) {
      super(), this.type = "TubeGeometry", this.parameters = {
        path: e,
        tubularSegments: t,
        radius: n,
        radialSegments: i,
        closed: r
      };
      const o = e.computeFrenetFrames(t, r);
      this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
      const a = new P(), l = new P(), c = new ee();
      let u = new P();
      const d = [], h = [], f = [], m = [];
      v(), this.setIndex(m), this.setAttribute("position", new Ee(d, 3)), this.setAttribute("normal", new Ee(h, 3)), this.setAttribute("uv", new Ee(f, 2));
      function v() {
        for (let x = 0; x < t; x++) g(x);
        g(r === false ? t : 0), _(), p();
      }
      function g(x) {
        u = e.getPointAt(x / t, u);
        const b = o.normals[x], E = o.binormals[x];
        for (let S = 0; S <= i; S++) {
          const w = S / i * Math.PI * 2, A = Math.sin(w), M = -Math.cos(w);
          l.x = M * b.x + A * E.x, l.y = M * b.y + A * E.y, l.z = M * b.z + A * E.z, l.normalize(), h.push(l.x, l.y, l.z), a.x = u.x + n * l.x, a.y = u.y + n * l.y, a.z = u.z + n * l.z, d.push(a.x, a.y, a.z);
        }
      }
      function p() {
        for (let x = 1; x <= t; x++) for (let b = 1; b <= i; b++) {
          const E = (i + 1) * (x - 1) + (b - 1), S = (i + 1) * x + (b - 1), w = (i + 1) * x + b, A = (i + 1) * (x - 1) + b;
          m.push(E, S, A), m.push(S, w, A);
        }
      }
      function _() {
        for (let x = 0; x <= t; x++) for (let b = 0; b <= i; b++) c.x = x / t, c.y = b / i, f.push(c.x, c.y);
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e;
    }
    static fromJSON(e) {
      return new Gl(new Ka[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
    }
  }
  class dg extends We {
    constructor(e = null) {
      if (super(), this.type = "WireframeGeometry", this.parameters = {
        geometry: e
      }, e !== null) {
        const t = [], n = /* @__PURE__ */ new Set(), i = new P(), r = new P();
        if (e.index !== null) {
          const o = e.attributes.position, a = e.index;
          let l = e.groups;
          l.length === 0 && (l = [
            {
              start: 0,
              count: a.count,
              materialIndex: 0
            }
          ]);
          for (let c = 0, u = l.length; c < u; ++c) {
            const d = l[c], h = d.start, f = d.count;
            for (let m = h, v = h + f; m < v; m += 3) for (let g = 0; g < 3; g++) {
              const p = a.getX(m + g), _ = a.getX(m + (g + 1) % 3);
              i.fromBufferAttribute(o, p), r.fromBufferAttribute(o, _), mf(i, r, n) === true && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
            }
          }
        } else {
          const o = e.attributes.position;
          for (let a = 0, l = o.count / 3; a < l; a++) for (let c = 0; c < 3; c++) {
            const u = 3 * a + c, d = 3 * a + (c + 1) % 3;
            i.fromBufferAttribute(o, u), r.fromBufferAttribute(o, d), mf(i, r, n) === true && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
          }
        }
        this.setAttribute("position", new Ee(t, 3));
      }
    }
    copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
    }
  }
  function mf(s, e, t) {
    const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
    return t.has(n) === true || t.has(i) === true ? false : (t.add(n), t.add(i), true);
  }
  var gf = Object.freeze({
    __proto__: null,
    BoxGeometry: bi,
    CapsuleGeometry: Dl,
    CircleGeometry: Nl,
    ConeGeometry: Ul,
    CylinderGeometry: Sr,
    DodecahedronGeometry: Ol,
    EdgesGeometry: lg,
    ExtrudeGeometry: ln,
    IcosahedronGeometry: Fl,
    LatheGeometry: zo,
    OctahedronGeometry: Fo,
    PlaneGeometry: Mr,
    PolyhedronGeometry: Yi,
    RingGeometry: Bl,
    ShapeGeometry: Bo,
    SphereGeometry: ko,
    TetrahedronGeometry: kl,
    TorusGeometry: Vl,
    TorusKnotGeometry: Hl,
    TubeGeometry: Gl,
    WireframeGeometry: dg
  });
  class fg extends Ht {
    constructor(e) {
      super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new ye(0), this.transparent = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
    }
  }
  class pg extends Fn {
    constructor(e) {
      super(e), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
    }
  }
  class qt extends Ht {
    constructor(e) {
      super(), this.isMeshStandardMaterial = true, this.defines = {
        STANDARD: ""
      }, this.type = "MeshStandardMaterial", this.color = new ye(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wi, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new mn(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.defines = {
        STANDARD: ""
      }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class mg extends qt {
    constructor(e) {
      super(), this.isMeshPhysicalMaterial = true, this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ee(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
        get: function() {
          return mt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        }
      }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
        100,
        400
      ], this.iridescenceThicknessMap = null, this.sheenColor = new ye(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ye(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ye(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(e) {
      this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e) {
      this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e) {
      this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
    }
    get dispersion() {
      return this._dispersion;
    }
    set dispersion(e) {
      this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e) {
      this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e) {
      this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
    }
    copy(e) {
      return super.copy(e), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
        ...e.iridescenceThicknessRange
      ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
    }
  }
  class gg extends Ht {
    constructor(e) {
      super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new ye(16777215), this.specular = new ye(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wi, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new mn(), this.combine = Lo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class vg extends Ht {
    constructor(e) {
      super(), this.isMeshToonMaterial = true, this.defines = {
        TOON: ""
      }, this.type = "MeshToonMaterial", this.color = new ye(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wi, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
  }
  class xg extends Ht {
    constructor(e) {
      super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wi, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
    }
  }
  class _g extends Ht {
    constructor(e) {
      super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new ye(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wi, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new mn(), this.combine = Lo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class yg extends Ht {
    constructor(e) {
      super(), this.isMeshMatcapMaterial = true, this.defines = {
        MATCAP: ""
      }, this.type = "MeshMatcapMaterial", this.color = new ye(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Wi, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.defines = {
        MATCAP: ""
      }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class Mg extends Jt {
    constructor(e) {
      super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
    }
  }
  function _s(s, e, t) {
    return !s || !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
  }
  function bg(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView);
  }
  function Sg(s) {
    function e(i, r) {
      return s[i] - s[r];
    }
    const t = s.length, n = new Array(t);
    for (let i = 0; i !== t; ++i) n[i] = i;
    return n.sort(e), n;
  }
  function Uh(s, e, t) {
    const n = s.length, i = new s.constructor(n);
    for (let r = 0, o = 0; o !== n; ++r) {
      const a = t[r] * e;
      for (let l = 0; l !== e; ++l) i[o++] = s[a + l];
    }
    return i;
  }
  function Cu(s, e, t, n) {
    let i = 1, r = s[0];
    for (; r !== void 0 && r[n] === void 0; ) r = s[i++];
    if (r === void 0) return;
    let o = r[n];
    if (o !== void 0) if (Array.isArray(o)) do
      o = r[n], o !== void 0 && (e.push(r.time), t.push.apply(t, o)), r = s[i++];
    while (r !== void 0);
    else if (o.toArray !== void 0) do
      o = r[n], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = s[i++];
    while (r !== void 0);
    else do
      o = r[n], o !== void 0 && (e.push(r.time), t.push(o)), r = s[i++];
    while (r !== void 0);
  }
  function gS(s, e, t, n, i = 30) {
    const r = s.clone();
    r.name = e;
    const o = [];
    for (let l = 0; l < r.tracks.length; ++l) {
      const c = r.tracks[l], u = c.getValueSize(), d = [], h = [];
      for (let f = 0; f < c.times.length; ++f) {
        const m = c.times[f] * i;
        if (!(m < t || m >= n)) {
          d.push(c.times[f]);
          for (let v = 0; v < u; ++v) h.push(c.values[f * u + v]);
        }
      }
      d.length !== 0 && (c.times = _s(d, c.times.constructor), c.values = _s(h, c.values.constructor), o.push(c));
    }
    r.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < r.tracks.length; ++l) a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
    for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
    return r.resetDuration(), r;
  }
  function vS(s, e = 0, t = s, n = 30) {
    n <= 0 && (n = 30);
    const i = t.tracks.length, r = e / n;
    for (let o = 0; o < i; ++o) {
      const a = t.tracks[o], l = a.ValueTypeName;
      if (l === "bool" || l === "string") continue;
      const c = s.tracks.find(function(p) {
        return p.name === a.name && p.ValueTypeName === l;
      });
      if (c === void 0) continue;
      let u = 0;
      const d = a.getValueSize();
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = d / 3);
      let h = 0;
      const f = c.getValueSize();
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = f / 3);
      const m = a.times.length - 1;
      let v;
      if (r <= a.times[0]) {
        const p = u, _ = d - u;
        v = a.values.slice(p, _);
      } else if (r >= a.times[m]) {
        const p = m * d + u, _ = p + d - u;
        v = a.values.slice(p, _);
      } else {
        const p = a.createInterpolant(), _ = u, x = d - u;
        p.evaluate(r), v = p.resultBuffer.slice(_, x);
      }
      l === "quaternion" && new en().fromArray(v).normalize().conjugate().toArray(v);
      const g = c.times.length;
      for (let p = 0; p < g; ++p) {
        const _ = p * f + h;
        if (l === "quaternion") en.multiplyQuaternionsFlat(c.values, _, v, 0, c.values, _);
        else {
          const x = f - h * 2;
          for (let b = 0; b < x; ++b) c.values[_ + b] -= v[b];
        }
      }
    }
    return s.blendMode = lu, s;
  }
  const xS = {
    convertArray: _s,
    isTypedArray: bg,
    getKeyframeOrder: Sg,
    sortedArray: Uh,
    flattenJSON: Cu,
    subclip: gS,
    makeClipAdditive: vS
  };
  class Vo {
    constructor(e, t, n, i) {
      this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(e) {
      const t = this.parameterPositions;
      let n = this._cachedIndex, i = t[n], r = t[n - 1];
      e: {
        t: {
          let o;
          n: {
            i: if (!(e < i)) {
              for (let a = n + 2; ; ) {
                if (i === void 0) {
                  if (e < r) break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === a) break;
                if (r = i, i = t[++n], e < i) break t;
              }
              o = t.length;
              break n;
            }
            if (!(e >= r)) {
              const a = t[1];
              e < a && (n = 2, r = a);
              for (let l = n - 2; ; ) {
                if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (n === l) break;
                if (i = r, r = t[--n - 1], e >= r) break t;
              }
              o = n, n = 0;
              break n;
            }
            break e;
          }
          for (; n < o; ) {
            const a = n + o >>> 1;
            e < t[a] ? o = a : n = a + 1;
          }
          if (i = t[n], r = t[n - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
          if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
        }
        this._cachedIndex = n, this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, e, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
      const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
      for (let o = 0; o !== i; ++o) t[o] = n[r + o];
      return t;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  class wg extends Vo {
    constructor(e, t, n, i) {
      super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
        endingStart: gs,
        endingEnd: gs
      };
    }
    intervalChanged_(e, t, n) {
      const i = this.parameterPositions;
      let r = e - 2, o = e + 1, a = i[r], l = i[o];
      if (a === void 0) switch (this.getSettings_().endingStart) {
        case vs:
          r = e, a = 2 * t - n;
          break;
        case lo:
          r = i.length - 2, a = t + i[r] - i[r + 1];
          break;
        default:
          r = e, a = n;
      }
      if (l === void 0) switch (this.getSettings_().endingEnd) {
        case vs:
          o = e, l = 2 * n - t;
          break;
        case lo:
          o = 1, l = n + i[1] - i[0];
          break;
        default:
          o = e - 1, l = t;
      }
      const c = (n - t) * 0.5, u = this.valueSize;
      this._weightPrev = c / (t - a), this._weightNext = c / (l - n), this._offsetPrev = r * u, this._offsetNext = o * u;
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = this._offsetPrev, d = this._offsetNext, h = this._weightPrev, f = this._weightNext, m = (n - t) / (i - t), v = m * m, g = v * m, p = -h * g + 2 * h * v - h * m, _ = (1 + h) * g + (-1.5 - 2 * h) * v + (-0.5 + h) * m + 1, x = (-1 - f) * g + (1.5 + f) * v + 0.5 * m, b = f * g - f * v;
      for (let E = 0; E !== a; ++E) r[E] = p * o[u + E] + _ * o[c + E] + x * o[l + E] + b * o[d + E];
      return r;
    }
  }
  class Ru extends Vo {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, c = l - a, u = (n - t) / (i - t), d = 1 - u;
      for (let h = 0; h !== a; ++h) r[h] = o[c + h] * d + o[l + h] * u;
      return r;
    }
  }
  class Tg extends Vo {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e) {
      return this.copySampleValue_(e - 1);
    }
  }
  class Vn {
    constructor(e, t, n, i) {
      if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
      this.name = e, this.times = _s(t, this.TimeBufferType), this.values = _s(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(e) {
      const t = e.constructor;
      let n;
      if (t.toJSON !== this.toJSON) n = t.toJSON(e);
      else {
        n = {
          name: e.name,
          times: _s(e.times, Array),
          values: _s(e.values, Array)
        };
        const i = e.getInterpolation();
        i !== e.DefaultInterpolation && (n.interpolation = i);
      }
      return n.type = e.ValueTypeName, n;
    }
    InterpolantFactoryMethodDiscrete(e) {
      return new Tg(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
      return new Ru(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
      return new wg(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
      let t;
      switch (e) {
        case oo:
          t = this.InterpolantFactoryMethodDiscrete;
          break;
        case ao:
          t = this.InterpolantFactoryMethodLinear;
          break;
        case Xa:
          t = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (t === void 0) {
        const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
        return console.warn("THREE.KeyframeTrack:", n), this;
      }
      return this.createInterpolant = t, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return oo;
        case this.InterpolantFactoryMethodLinear:
          return ao;
        case this.InterpolantFactoryMethodSmooth:
          return Xa;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e) {
      if (e !== 0) {
        const t = this.times;
        for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
      }
      return this;
    }
    scale(e) {
      if (e !== 1) {
        const t = this.times;
        for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
      }
      return this;
    }
    trim(e, t) {
      const n = this.times, i = n.length;
      let r = 0, o = i - 1;
      for (; r !== i && n[r] < e; ) ++r;
      for (; o !== -1 && n[o] > t; ) --o;
      if (++o, r !== 0 || o !== i) {
        r >= o && (o = Math.max(o, 1), r = o - 1);
        const a = this.getValueSize();
        this.times = n.slice(r, o), this.values = this.values.slice(r * a, o * a);
      }
      return this;
    }
    validate() {
      let e = true;
      const t = this.getValueSize();
      t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
      const n = this.times, i = this.values, r = n.length;
      r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
      let o = null;
      for (let a = 0; a !== r; a++) {
        const l = n[a];
        if (typeof l == "number" && isNaN(l)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = false;
          break;
        }
        if (o !== null && o > l) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = false;
          break;
        }
        o = l;
      }
      if (i !== void 0 && bg(i)) for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = false;
          break;
        }
      }
      return e;
    }
    optimize() {
      const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === Xa, r = e.length - 1;
      let o = 1;
      for (let a = 1; a < r; ++a) {
        let l = false;
        const c = e[a], u = e[a + 1];
        if (c !== u && (a !== 1 || c !== e[0])) if (i) l = true;
        else {
          const d = a * n, h = d - n, f = d + n;
          for (let m = 0; m !== n; ++m) {
            const v = t[d + m];
            if (v !== t[h + m] || v !== t[f + m]) {
              l = true;
              break;
            }
          }
        }
        if (l) {
          if (a !== o) {
            e[o] = e[a];
            const d = a * n, h = o * n;
            for (let f = 0; f !== n; ++f) t[h + f] = t[d + f];
          }
          ++o;
        }
      }
      if (r > 0) {
        e[o] = e[r];
        for (let a = r * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
        ++o;
      }
      return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this;
    }
    clone() {
      const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
      return i.createInterpolant = this.createInterpolant, i;
    }
  }
  Vn.prototype.TimeBufferType = Float32Array;
  Vn.prototype.ValueBufferType = Float32Array;
  Vn.prototype.DefaultInterpolation = ao;
  class Rs extends Vn {
  }
  Rs.prototype.ValueTypeName = "bool";
  Rs.prototype.ValueBufferType = Array;
  Rs.prototype.DefaultInterpolation = oo;
  Rs.prototype.InterpolantFactoryMethodLinear = void 0;
  Rs.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Pu extends Vn {
  }
  Pu.prototype.ValueTypeName = "color";
  class _o extends Vn {
  }
  _o.prototype.ValueTypeName = "number";
  class Eg extends Vo {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e, t, n, i) {
      const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - t) / (i - t);
      let c = e * a;
      for (let u = c + a; c !== u; c += 4) en.slerpFlat(r, 0, o, c - a, o, c, l);
      return r;
    }
  }
  class wr extends Vn {
    InterpolantFactoryMethodLinear(e) {
      return new Eg(this.times, this.values, this.getValueSize(), e);
    }
  }
  wr.prototype.ValueTypeName = "quaternion";
  wr.prototype.DefaultInterpolation = ao;
  wr.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Ps extends Vn {
  }
  Ps.prototype.ValueTypeName = "string";
  Ps.prototype.ValueBufferType = Array;
  Ps.prototype.DefaultInterpolation = oo;
  Ps.prototype.InterpolantFactoryMethodLinear = void 0;
  Ps.prototype.InterpolantFactoryMethodSmooth = void 0;
  class yo extends Vn {
  }
  yo.prototype.ValueTypeName = "vector";
  class Mo {
    constructor(e = "", t = -1, n = [], i = yl) {
      this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = fn(), this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
      const t = [], n = e.tracks, i = 1 / (e.fps || 1);
      for (let o = 0, a = n.length; o !== a; ++o) t.push(yS(n[o]).scale(i));
      const r = new this(e.name, e.duration, t, e.blendMode);
      return r.uuid = e.uuid, r;
    }
    static toJSON(e) {
      const t = [], n = e.tracks, i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode
      };
      for (let r = 0, o = n.length; r !== o; ++r) t.push(Vn.toJSON(n[r]));
      return i;
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
      const r = t.length, o = [];
      for (let a = 0; a < r; a++) {
        let l = [], c = [];
        l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
        const u = Sg(l);
        l = Uh(l, 1, u), c = Uh(c, 1, u), !i && l[0] === 0 && (l.push(r), c.push(c[0])), o.push(new _o(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n));
      }
      return new this(e, -1, o);
    }
    static findByName(e, t) {
      let n = e;
      if (!Array.isArray(e)) {
        const i = e;
        n = i.geometry && i.geometry.animations || i.animations;
      }
      for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
      const i = {}, r = /^([\w-]*?)([\d]+)$/;
      for (let a = 0, l = e.length; a < l; a++) {
        const c = e[a], u = c.name.match(r);
        if (u && u.length > 1) {
          const d = u[1];
          let h = i[d];
          h || (i[d] = h = []), h.push(c);
        }
      }
      const o = [];
      for (const a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
      return o;
    }
    static parseAnimation(e, t) {
      if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n = function(d, h, f, m, v) {
        if (f.length !== 0) {
          const g = [], p = [];
          Cu(f, g, p, m), g.length !== 0 && v.push(new d(h, g, p));
        }
      }, i = [], r = e.name || "default", o = e.fps || 30, a = e.blendMode;
      let l = e.length || -1;
      const c = e.hierarchy || [];
      for (let d = 0; d < c.length; d++) {
        const h = c[d].keys;
        if (!(!h || h.length === 0)) if (h[0].morphTargets) {
          const f = {};
          let m;
          for (m = 0; m < h.length; m++) if (h[m].morphTargets) for (let v = 0; v < h[m].morphTargets.length; v++) f[h[m].morphTargets[v]] = -1;
          for (const v in f) {
            const g = [], p = [];
            for (let _ = 0; _ !== h[m].morphTargets.length; ++_) {
              const x = h[m];
              g.push(x.time), p.push(x.morphTarget === v ? 1 : 0);
            }
            i.push(new _o(".morphTargetInfluence[" + v + "]", g, p));
          }
          l = f.length * o;
        } else {
          const f = ".bones[" + t[d].name + "]";
          n(yo, f + ".position", h, "pos", i), n(wr, f + ".quaternion", h, "rot", i), n(yo, f + ".scale", h, "scl", i);
        }
      }
      return i.length === 0 ? null : new this(r, l, i, a);
    }
    resetDuration() {
      const e = this.tracks;
      let t = 0;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const r = this.tracks[n];
        t = Math.max(t, r.times[r.times.length - 1]);
      }
      return this.duration = t, this;
    }
    trim() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
      return this;
    }
    validate() {
      let e = true;
      for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
      return e;
    }
    optimize() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
      return this;
    }
    clone() {
      const e = [];
      for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
      return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function _S(s) {
    switch (s.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return _o;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return yo;
      case "color":
        return Pu;
      case "quaternion":
        return wr;
      case "bool":
      case "boolean":
        return Rs;
      case "string":
        return Ps;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
  }
  function yS(s) {
    if (s.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = _S(s.type);
    if (s.times === void 0) {
      const t = [], n = [];
      Cu(s.keys, t, n, "value"), s.times = t, s.values = n;
    }
    return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
  }
  const hi = {
    enabled: false,
    files: {},
    add: function(s, e) {
      this.enabled !== false && (this.files[s] = e);
    },
    get: function(s) {
      if (this.enabled !== false) return this.files[s];
    },
    remove: function(s) {
      delete this.files[s];
    },
    clear: function() {
      this.files = {};
    }
  };
  class Iu {
    constructor(e, t, n) {
      const i = this;
      let r = false, o = 0, a = 0, l;
      const c = [];
      this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
        a++, r === false && i.onStart !== void 0 && i.onStart(u, o, a), r = true;
      }, this.itemEnd = function(u) {
        o++, i.onProgress !== void 0 && i.onProgress(u, o, a), o === a && (r = false, i.onLoad !== void 0 && i.onLoad());
      }, this.itemError = function(u) {
        i.onError !== void 0 && i.onError(u);
      }, this.resolveURL = function(u) {
        return l ? l(u) : u;
      }, this.setURLModifier = function(u) {
        return l = u, this;
      }, this.addHandler = function(u, d) {
        return c.push(u, d), this;
      }, this.removeHandler = function(u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }, this.getHandler = function(u) {
        for (let d = 0, h = c.length; d < h; d += 2) {
          const f = c[d], m = c[d + 1];
          if (f.global && (f.lastIndex = 0), f.test(u)) return m;
        }
        return null;
      };
    }
  }
  const Ag = new Iu();
  class sn {
    constructor(e) {
      this.manager = e !== void 0 ? e : Ag, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(e, t) {
      const n = this;
      return new Promise(function(i, r) {
        n.load(e, i, t, r);
      });
    }
    parse() {
    }
    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }
    setWithCredentials(e) {
      return this.withCredentials = e, this;
    }
    setPath(e) {
      return this.path = e, this;
    }
    setResourcePath(e) {
      return this.resourcePath = e, this;
    }
    setRequestHeader(e) {
      return this.requestHeader = e, this;
    }
  }
  sn.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  const oi = {};
  class MS extends Error {
    constructor(e, t) {
      super(e), this.response = t;
    }
  }
  class xi extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = hi.get(e);
      if (r !== void 0) return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
      if (oi[e] !== void 0) {
        oi[e].push({
          onLoad: t,
          onProgress: n,
          onError: i
        });
        return;
      }
      oi[e] = [], oi[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
      }), a = this.mimeType, l = this.responseType;
      fetch(o).then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
          const u = oi[e], d = c.body.getReader(), h = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), f = h ? parseInt(h) : 0, m = f !== 0;
          let v = 0;
          const g = new ReadableStream({
            start(p) {
              _();
              function _() {
                d.read().then(({ done: x, value: b }) => {
                  if (x) p.close();
                  else {
                    v += b.byteLength;
                    const E = new ProgressEvent("progress", {
                      lengthComputable: m,
                      loaded: v,
                      total: f
                    });
                    for (let S = 0, w = u.length; S < w; S++) {
                      const A = u[S];
                      A.onProgress && A.onProgress(E);
                    }
                    p.enqueue(b), _();
                  }
                });
              }
            }
          });
          return new Response(g);
        } else throw new MS(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
      }).then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a), h = d && d[1] ? d[1].toLowerCase() : void 0, f = new TextDecoder(h);
              return c.arrayBuffer().then((m) => f.decode(m));
            }
        }
      }).then((c) => {
        hi.add(e, c);
        const u = oi[e];
        delete oi[e];
        for (let d = 0, h = u.length; d < h; d++) {
          const f = u[d];
          f.onLoad && f.onLoad(c);
        }
      }).catch((c) => {
        const u = oi[e];
        if (u === void 0) throw this.manager.itemError(e), c;
        delete oi[e];
        for (let d = 0, h = u.length; d < h; d++) {
          const f = u[d];
          f.onError && f.onError(c);
        }
        this.manager.itemError(e);
      }).finally(() => {
        this.manager.itemEnd(e);
      }), this.manager.itemStart(e);
    }
    setResponseType(e) {
      return this.responseType = e, this;
    }
    setMimeType(e) {
      return this.mimeType = e, this;
    }
  }
  class bS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = new xi(this.manager);
      o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
        try {
          t(r.parse(JSON.parse(a)));
        } catch (l) {
          i ? i(l) : console.error(l), r.manager.itemError(e);
        }
      }, n, i);
    }
    parse(e) {
      const t = [];
      for (let n = 0; n < e.length; n++) {
        const i = Mo.parse(e[n]);
        t.push(i);
      }
      return t;
    }
  }
  class SS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = [], a = new Il(), l = new xi(this.manager);
      l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
      let c = 0;
      function u(d) {
        l.load(e[d], function(h) {
          const f = r.parse(h, true);
          o[d] = {
            width: f.width,
            height: f.height,
            format: f.format,
            mipmaps: f.mipmaps
          }, c += 1, c === 6 && (f.mipmapCount === 1 && (a.minFilter = Mt), a.image = o, a.format = f.format, a.needsUpdate = true, t && t(a));
        }, n, i);
      }
      if (Array.isArray(e)) for (let d = 0, h = e.length; d < h; ++d) u(d);
      else l.load(e, function(d) {
        const h = r.parse(d, true);
        if (h.isCubemap) {
          const f = h.mipmaps.length / h.mipmapCount;
          for (let m = 0; m < f; m++) {
            o[m] = {
              mipmaps: []
            };
            for (let v = 0; v < h.mipmapCount; v++) o[m].mipmaps.push(h.mipmaps[m * h.mipmapCount + v]), o[m].format = h.format, o[m].width = h.width, o[m].height = h.height;
          }
          a.image = o;
        } else a.image.width = h.width, a.image.height = h.height, a.mipmaps = h.mipmaps;
        h.mipmapCount === 1 && (a.minFilter = Mt), a.format = h.format, a.needsUpdate = true, t && t(a);
      }, n, i);
      return a;
    }
  }
  class bo extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = this, o = hi.get(e);
      if (o !== void 0) return r.manager.itemStart(e), setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
      const a = mo("img");
      function l() {
        u(), hi.add(e, this), t && t(this), r.manager.itemEnd(e);
      }
      function c(d) {
        u(), i && i(d), r.manager.itemError(e), r.manager.itemEnd(e);
      }
      function u() {
        a.removeEventListener("load", l, false), a.removeEventListener("error", c, false);
      }
      return a.addEventListener("load", l, false), a.addEventListener("error", c, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
    }
  }
  class wS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = new Uo();
      r.colorSpace = Mn;
      const o = new bo(this.manager);
      o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
      let a = 0;
      function l(c) {
        o.load(e[c], function(u) {
          r.images[c] = u, a++, a === 6 && (r.needsUpdate = true, t && t(r));
        }, void 0, i);
      }
      for (let c = 0; c < e.length; ++c) l(c);
      return r;
    }
  }
  class TS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = new Oi(), a = new xi(this.manager);
      return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function(l) {
        let c;
        try {
          c = r.parse(l);
        } catch (u) {
          if (i !== void 0) i(u);
          else {
            console.error(u);
            return;
          }
        }
        c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : wn, o.wrapT = c.wrapT !== void 0 ? c.wrapT : wn, o.magFilter = c.magFilter !== void 0 ? c.magFilter : Mt, o.minFilter = c.minFilter !== void 0 ? c.minFilter : Mt, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = Xn), c.mipmapCount === 1 && (o.minFilter = Mt), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = true, t && t(o, c);
      }, n, i), o;
    }
  }
  class ES extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = new gt(), o = new bo(this.manager);
      return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
        r.image = a, r.needsUpdate = true, t !== void 0 && t(r);
      }, n, i), r;
    }
  }
  class qi extends Qe {
    constructor(e, t = 1) {
      super(), this.isLight = true, this.type = "Light", this.color = new ye(e), this.intensity = t;
    }
    dispose() {
    }
    copy(e, t) {
      return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
  }
  class Cg extends qi {
    constructor(e, t, n) {
      super(e, n), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(Qe.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ye(t);
    }
    copy(e, t) {
      return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
    }
  }
  const Oc = new De(), vf = new P(), xf = new P();
  class Lu {
    constructor(e) {
      this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ee(512, 512), this.map = null, this.mapPass = null, this.matrix = new De(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Oo(), this._frameExtents = new ee(1, 1), this._viewportCount = 1, this._viewports = [
        new rt(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e) {
      const t = this.camera, n = this.matrix;
      vf.setFromMatrixPosition(e.matrixWorld), t.position.copy(vf), xf.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(xf), t.updateMatrixWorld(), Oc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Oc), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(Oc);
    }
    getViewport(e) {
      return this._viewports[e];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
      return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e = {};
      return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
    }
  }
  class AS extends Lu {
    constructor() {
      super(new Et(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
    }
    updateMatrices(e) {
      const t = this.camera, n = ur * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
      (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
    }
    copy(e) {
      return super.copy(e), this.focus = e.focus, this;
    }
  }
  class Rg extends qi {
    constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
      super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Qe.DEFAULT_UP), this.updateMatrix(), this.target = new Qe(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new AS();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
  }
  const _f = new De(), kr = new P(), zc = new P();
  class CS extends Lu {
    constructor() {
      super(new Et(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new ee(4, 2), this._viewportCount = 6, this._viewports = [
        new rt(2, 1, 1, 1),
        new rt(0, 1, 1, 1),
        new rt(3, 1, 1, 1),
        new rt(1, 1, 1, 1),
        new rt(3, 0, 1, 1),
        new rt(1, 0, 1, 1)
      ], this._cubeDirections = [
        new P(1, 0, 0),
        new P(-1, 0, 0),
        new P(0, 0, 1),
        new P(0, 0, -1),
        new P(0, 1, 0),
        new P(0, -1, 0)
      ], this._cubeUps = [
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 0, 1),
        new P(0, 0, -1)
      ];
    }
    updateMatrices(e, t = 0) {
      const n = this.camera, i = this.matrix, r = e.distance || n.far;
      r !== n.far && (n.far = r, n.updateProjectionMatrix()), kr.setFromMatrixPosition(e.matrixWorld), n.position.copy(kr), zc.copy(n.position), zc.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(zc), n.updateMatrixWorld(), i.makeTranslation(-kr.x, -kr.y, -kr.z), _f.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_f);
    }
  }
  class Pg extends qi {
    constructor(e, t, n = 0, i = 2) {
      super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new CS();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(e) {
      this.intensity = e / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
    }
  }
  class RS extends Lu {
    constructor() {
      super(new Tl(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
    }
  }
  class ja extends qi {
    constructor(e, t) {
      super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(Qe.DEFAULT_UP), this.updateMatrix(), this.target = new Qe(), this.shadow = new RS();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e) {
      return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
  }
  class Du extends qi {
    constructor(e, t) {
      super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
    }
  }
  class Ig extends qi {
    constructor(e, t, n = 10, i = 10) {
      super(e, t), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = n, this.height = i;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
      this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
      return super.copy(e), this.width = e.width, this.height = e.height, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.width = this.width, t.object.height = this.height, t;
    }
  }
  class Lg {
    constructor() {
      this.isSphericalHarmonics3 = true, this.coefficients = [];
      for (let e = 0; e < 9; e++) this.coefficients.push(new P());
    }
    set(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
      return this;
    }
    zero() {
      for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
      return this;
    }
    getAt(e, t) {
      const n = e.x, i = e.y, r = e.z, o = this.coefficients;
      return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * i), t.addScaledVector(o[2], 0.488603 * r), t.addScaledVector(o[3], 0.488603 * n), t.addScaledVector(o[4], 1.092548 * (n * i)), t.addScaledVector(o[5], 1.092548 * (i * r)), t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(o[7], 1.092548 * (n * r)), t.addScaledVector(o[8], 0.546274 * (n * n - i * i)), t;
    }
    getIrradianceAt(e, t) {
      const n = e.x, i = e.y, r = e.z, o = this.coefficients;
      return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * i), t.addScaledVector(o[2], 2 * 0.511664 * r), t.addScaledVector(o[3], 2 * 0.511664 * n), t.addScaledVector(o[4], 2 * 0.429043 * n * i), t.addScaledVector(o[5], 2 * 0.429043 * i * r), t.addScaledVector(o[6], 0.743125 * r * r - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * n * r), t.addScaledVector(o[8], 0.429043 * (n * n - i * i)), t;
    }
    add(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
      return this;
    }
    addScaledSH(e, t) {
      for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
      return this;
    }
    scale(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
      return this;
    }
    lerp(e, t) {
      for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
      return this;
    }
    equals(e) {
      for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return false;
      return true;
    }
    copy(e) {
      return this.set(e.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
      return e;
    }
    static getBasisAt(e, t) {
      const n = e.x, i = e.y, r = e.z;
      t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - i * i);
    }
  }
  class Dg extends qi {
    constructor(e = new Lg(), t = 1) {
      super(void 0, t), this.isLightProbe = true, this.sh = e;
    }
    copy(e) {
      return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
      return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.sh = this.sh.toArray(), t;
    }
  }
  class Wl extends sn {
    constructor(e) {
      super(e), this.textures = {};
    }
    load(e, t, n, i) {
      const r = this, o = new xi(r.manager);
      o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
        try {
          t(r.parse(JSON.parse(a)));
        } catch (l) {
          i ? i(l) : console.error(l), r.manager.itemError(e);
        }
      }, n, i);
    }
    parse(e) {
      const t = this.textures;
      function n(r) {
        return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
      }
      const i = Wl.createMaterialFromType(e.type);
      if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new ye().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const r in e.uniforms) {
        const o = e.uniforms[r];
        switch (i.uniforms[r] = {}, o.type) {
          case "t":
            i.uniforms[r].value = n(o.value);
            break;
          case "c":
            i.uniforms[r].value = new ye().setHex(o.value);
            break;
          case "v2":
            i.uniforms[r].value = new ee().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[r].value = new P().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[r].value = new rt().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[r].value = new Fe().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[r].value = new De().fromArray(o.value);
            break;
          default:
            i.uniforms[r].value = o.value;
        }
      }
      if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0) for (const r in e.extensions) i.extensions[r] = e.extensions[r];
      if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
        let r = e.normalScale;
        Array.isArray(r) === false && (r = [
          r,
          r
        ]), i.normalScale = new ee().fromArray(r);
      }
      return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new ee().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
    }
    setTextures(e) {
      return this.textures = e, this;
    }
    static createMaterialFromType(e) {
      const t = {
        ShadowMaterial: fg,
        SpriteMaterial: _u,
        RawShaderMaterial: pg,
        ShaderMaterial: Fn,
        PointsMaterial: Mu,
        MeshPhysicalMaterial: mg,
        MeshStandardMaterial: qt,
        MeshPhongMaterial: gg,
        MeshToonMaterial: vg,
        MeshNormalMaterial: xg,
        MeshLambertMaterial: _g,
        MeshDepthMaterial: gu,
        MeshDistanceMaterial: vu,
        MeshBasicMaterial: Xi,
        MeshMatcapMaterial: yg,
        LineDashedMaterial: Mg,
        LineBasicMaterial: Jt,
        Material: Ht
      };
      return new t[e]();
    }
  }
  class Oh {
    static decodeText(e) {
      if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
      let t = "";
      for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
      try {
        return decodeURIComponent(escape(t));
      } catch {
        return t;
      }
    }
    static extractUrlBase(e) {
      const t = e.lastIndexOf("/");
      return t === -1 ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
      return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
    }
  }
  class Ng extends We {
    constructor() {
      super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(e) {
      return super.copy(e), this.instanceCount = e.instanceCount, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = true, e;
    }
  }
  class Ug extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = new xi(r.manager);
      o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
        try {
          t(r.parse(JSON.parse(a)));
        } catch (l) {
          i ? i(l) : console.error(l), r.manager.itemError(e);
        }
      }, n, i);
    }
    parse(e) {
      const t = {}, n = {};
      function i(f, m) {
        if (t[m] !== void 0) return t[m];
        const g = f.interleavedBuffers[m], p = r(f, g.buffer), _ = er(g.type, p), x = new Rl(_, g.stride);
        return x.uuid = g.uuid, t[m] = x, x;
      }
      function r(f, m) {
        if (n[m] !== void 0) return n[m];
        const g = f.arrayBuffers[m], p = new Uint32Array(g).buffer;
        return n[m] = p, p;
      }
      const o = e.isInstancedBufferGeometry ? new Ng() : new We(), a = e.data.index;
      if (a !== void 0) {
        const f = er(a.type, a.array);
        o.setIndex(new at(f, 1));
      }
      const l = e.data.attributes;
      for (const f in l) {
        const m = l[f];
        let v;
        if (m.isInterleavedBufferAttribute) {
          const g = i(e.data, m.data);
          v = new Es(g, m.itemSize, m.offset, m.normalized);
        } else {
          const g = er(m.type, m.array), p = m.isInstancedBufferAttribute ? fr : at;
          v = new p(g, m.itemSize, m.normalized);
        }
        m.name !== void 0 && (v.name = m.name), m.usage !== void 0 && v.setUsage(m.usage), o.setAttribute(f, v);
      }
      const c = e.data.morphAttributes;
      if (c) for (const f in c) {
        const m = c[f], v = [];
        for (let g = 0, p = m.length; g < p; g++) {
          const _ = m[g];
          let x;
          if (_.isInterleavedBufferAttribute) {
            const b = i(e.data, _.data);
            x = new Es(b, _.itemSize, _.offset, _.normalized);
          } else {
            const b = er(_.type, _.array);
            x = new at(b, _.itemSize, _.normalized);
          }
          _.name !== void 0 && (x.name = _.name), v.push(x);
        }
        o.morphAttributes[f] = v;
      }
      e.data.morphTargetsRelative && (o.morphTargetsRelative = true);
      const d = e.data.groups || e.data.drawcalls || e.data.offsets;
      if (d !== void 0) for (let f = 0, m = d.length; f !== m; ++f) {
        const v = d[f];
        o.addGroup(v.start, v.count, v.materialIndex);
      }
      const h = e.data.boundingSphere;
      if (h !== void 0) {
        const f = new P();
        h.center !== void 0 && f.fromArray(h.center), o.boundingSphere = new kt(f, h.radius);
      }
      return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
    }
  }
  class PS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = this.path === "" ? Oh.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || o;
      const a = new xi(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
        let c = null;
        try {
          c = JSON.parse(l);
        } catch (d) {
          i !== void 0 && i(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
          return;
        }
        const u = c.metadata;
        if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
          i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
          return;
        }
        r.parse(c, t);
      }, n, i);
    }
    async loadAsync(e, t) {
      const n = this, i = this.path === "" ? Oh.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || i;
      const r = new xi(this.manager);
      r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
      const o = await r.loadAsync(e, t), a = JSON.parse(o), l = a.metadata;
      if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
      return await n.parseAsync(a);
    }
    parse(e, t) {
      const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), o = this.parseImages(e.images, function() {
        t !== void 0 && t(c);
      }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), c = this.parseObject(e.object, r, l, a, n), u = this.parseSkeletons(e.skeletons, c);
      if (this.bindSkeletons(c, u), t !== void 0) {
        let d = false;
        for (const h in o) if (o[h].data instanceof HTMLImageElement) {
          d = true;
          break;
        }
        d === false && t(c);
      }
      return c;
    }
    async parseAsync(e) {
      const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, r), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, i, a, o, t), c = this.parseSkeletons(e.skeletons, l);
      return this.bindSkeletons(l, c), l;
    }
    parseShapes(e) {
      const t = {};
      if (e !== void 0) for (let n = 0, i = e.length; n < i; n++) {
        const r = new Pt().fromJSON(e[n]);
        t[r.uuid] = r;
      }
      return t;
    }
    parseSkeletons(e, t) {
      const n = {}, i = {};
      if (t.traverse(function(r) {
        r.isBone && (i[r.uuid] = r);
      }), e !== void 0) for (let r = 0, o = e.length; r < o; r++) {
        const a = new Pl().fromJSON(e[r], i);
        n[a.uuid] = a;
      }
      return n;
    }
    parseGeometries(e, t) {
      const n = {};
      if (e !== void 0) {
        const i = new Ug();
        for (let r = 0, o = e.length; r < o; r++) {
          let a;
          const l = e[r];
          switch (l.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              a = i.parse(l);
              break;
            default:
              l.type in gf ? a = gf[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
          }
          a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
        }
      }
      return n;
    }
    parseMaterials(e, t) {
      const n = {}, i = {};
      if (e !== void 0) {
        const r = new Wl();
        r.setTextures(t);
        for (let o = 0, a = e.length; o < a; o++) {
          const l = e[o];
          n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)), i[l.uuid] = n[l.uuid];
        }
      }
      return i;
    }
    parseAnimations(e) {
      const t = {};
      if (e !== void 0) for (let n = 0; n < e.length; n++) {
        const i = e[n], r = Mo.parse(i);
        t[r.uuid] = r;
      }
      return t;
    }
    parseImages(e, t) {
      const n = this, i = {};
      let r;
      function o(l) {
        return n.manager.itemStart(l), r.load(l, function() {
          n.manager.itemEnd(l);
        }, void 0, function() {
          n.manager.itemError(l), n.manager.itemEnd(l);
        });
      }
      function a(l) {
        if (typeof l == "string") {
          const c = l, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
          return o(u);
        } else return l.data ? {
          data: er(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
      }
      if (e !== void 0 && e.length > 0) {
        const l = new Iu(t);
        r = new bo(l), r.setCrossOrigin(this.crossOrigin);
        for (let c = 0, u = e.length; c < u; c++) {
          const d = e[c], h = d.url;
          if (Array.isArray(h)) {
            const f = [];
            for (let m = 0, v = h.length; m < v; m++) {
              const g = h[m], p = a(g);
              p !== null && (p instanceof HTMLImageElement ? f.push(p) : f.push(new Oi(p.data, p.width, p.height)));
            }
            i[d.uuid] = new xs(f);
          } else {
            const f = a(d.url);
            i[d.uuid] = new xs(f);
          }
        }
      }
      return i;
    }
    async parseImagesAsync(e) {
      const t = this, n = {};
      let i;
      async function r(o) {
        if (typeof o == "string") {
          const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
          return await i.loadAsync(l);
        } else return o.data ? {
          data: er(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
      }
      if (e !== void 0 && e.length > 0) {
        i = new bo(this.manager), i.setCrossOrigin(this.crossOrigin);
        for (let o = 0, a = e.length; o < a; o++) {
          const l = e[o], c = l.url;
          if (Array.isArray(c)) {
            const u = [];
            for (let d = 0, h = c.length; d < h; d++) {
              const f = c[d], m = await r(f);
              m !== null && (m instanceof HTMLImageElement ? u.push(m) : u.push(new Oi(m.data, m.width, m.height)));
            }
            n[l.uuid] = new xs(u);
          } else {
            const u = await r(l.url);
            n[l.uuid] = new xs(u);
          }
        }
      }
      return n;
    }
    parseTextures(e, t) {
      function n(r, o) {
        return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), o[r]);
      }
      const i = {};
      if (e !== void 0) for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image], c = l.data;
        let u;
        Array.isArray(c) ? (u = new Uo(), c.length === 6 && (u.needsUpdate = true)) : (c && c.data ? u = new Oi() : u = new gt(), c && (u.needsUpdate = true)), u.source = l, u.uuid = a.uuid, a.name !== void 0 && (u.name = a.name), a.mapping !== void 0 && (u.mapping = n(a.mapping, IS)), a.channel !== void 0 && (u.channel = a.channel), a.offset !== void 0 && u.offset.fromArray(a.offset), a.repeat !== void 0 && u.repeat.fromArray(a.repeat), a.center !== void 0 && u.center.fromArray(a.center), a.rotation !== void 0 && (u.rotation = a.rotation), a.wrap !== void 0 && (u.wrapS = n(a.wrap[0], yf), u.wrapT = n(a.wrap[1], yf)), a.format !== void 0 && (u.format = a.format), a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat), a.type !== void 0 && (u.type = a.type), a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace), a.minFilter !== void 0 && (u.minFilter = n(a.minFilter, Mf)), a.magFilter !== void 0 && (u.magFilter = n(a.magFilter, Mf)), a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy), a.flipY !== void 0 && (u.flipY = a.flipY), a.generateMipmaps !== void 0 && (u.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (u.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (u.compareFunction = a.compareFunction), a.userData !== void 0 && (u.userData = a.userData), i[a.uuid] = u;
      }
      return i;
    }
    parseObject(e, t, n, i, r) {
      let o;
      function a(h) {
        return t[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", h), t[h];
      }
      function l(h) {
        if (h !== void 0) {
          if (Array.isArray(h)) {
            const f = [];
            for (let m = 0, v = h.length; m < v; m++) {
              const g = h[m];
              n[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g), f.push(n[g]);
            }
            return f;
          }
          return n[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", h), n[h];
        }
      }
      function c(h) {
        return i[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", h), i[h];
      }
      let u, d;
      switch (e.type) {
        case "Scene":
          o = new xu(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new ye(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new Cl(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Al(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
          break;
        case "PerspectiveCamera":
          o = new Et(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
          break;
        case "OrthographicCamera":
          o = new Tl(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
          break;
        case "AmbientLight":
          o = new Du(e.color, e.intensity);
          break;
        case "DirectionalLight":
          o = new ja(e.color, e.intensity);
          break;
        case "PointLight":
          o = new Pg(e.color, e.intensity, e.distance, e.decay);
          break;
        case "RectAreaLight":
          o = new Ig(e.color, e.intensity, e.width, e.height);
          break;
        case "SpotLight":
          o = new Rg(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
          break;
        case "HemisphereLight":
          o = new Cg(e.color, e.groundColor, e.intensity);
          break;
        case "LightProbe":
          o = new Dg().fromJSON(e);
          break;
        case "SkinnedMesh":
          u = a(e.geometry), d = l(e.material), o = new Km(u, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
          break;
        case "Mesh":
          u = a(e.geometry), d = l(e.material), o = new ht(u, d);
          break;
        case "InstancedMesh":
          u = a(e.geometry), d = l(e.material);
          const h = e.count, f = e.instanceMatrix, m = e.instanceColor;
          o = new jm(u, d, h), o.instanceMatrix = new fr(new Float32Array(f.array), 16), m !== void 0 && (o.instanceColor = new fr(new Float32Array(m.array), m.itemSize));
          break;
        case "BatchedMesh":
          u = a(e.geometry), d = l(e.material), o = new Qm(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, d), o.geometry = u, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((v) => {
            const g = new Bt();
            g.min.fromArray(v.boxMin), g.max.fromArray(v.boxMax);
            const p = new kt();
            return p.radius = v.sphereRadius, p.center.fromArray(v.sphereCenter), {
              boxInitialized: v.boxInitialized,
              box: g,
              sphereInitialized: v.sphereInitialized,
              sphere: p
            };
          }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = c(e.matricesTexture.uuid);
          break;
        case "LOD":
          o = new Jm();
          break;
        case "Line":
          o = new ki(a(e.geometry), l(e.material));
          break;
        case "LineLoop":
          o = new eg(a(e.geometry), l(e.material));
          break;
        case "LineSegments":
          o = new Kn(a(e.geometry), l(e.material));
          break;
        case "PointCloud":
        case "Points":
          o = new tg(a(e.geometry), l(e.material));
          break;
        case "Sprite":
          o = new Zm(l(e.material));
          break;
        case "Group":
          o = new Ln();
          break;
        case "Bone":
          o = new yu();
          break;
        default:
          o = new Qe();
      }
      if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
        const h = e.children;
        for (let f = 0; f < h.length; f++) o.add(this.parseObject(h[f], t, n, i, r));
      }
      if (e.animations !== void 0) {
        const h = e.animations;
        for (let f = 0; f < h.length; f++) {
          const m = h[f];
          o.animations.push(r[m]);
        }
      }
      if (e.type === "LOD") {
        e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
        const h = e.levels;
        for (let f = 0; f < h.length; f++) {
          const m = h[f], v = o.getObjectByProperty("uuid", m.object);
          v !== void 0 && o.addLevel(v, m.distance, m.hysteresis);
        }
      }
      return o;
    }
    bindSkeletons(e, t) {
      Object.keys(t).length !== 0 && e.traverse(function(n) {
        if (n.isSkinnedMesh === true && n.skeleton !== void 0) {
          const i = t[n.skeleton];
          i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
        }
      });
    }
  }
  const IS = {
    UVMapping: _l,
    CubeReflectionMapping: gi,
    CubeRefractionMapping: Bi,
    EquirectangularReflectionMapping: cr,
    EquirectangularRefractionMapping: io,
    CubeUVReflectionMapping: xr
  }, yf = {
    RepeatWrapping: so,
    ClampToEdgeWrapping: wn,
    MirroredRepeatWrapping: ro
  }, Mf = {
    NearestFilter: At,
    NearestMipmapNearestFilter: Qh,
    NearestMipmapLinearFilter: Qs,
    LinearFilter: Mt,
    LinearMipmapNearestFilter: $r,
    LinearMipmapLinearFilter: Xn
  };
  class LS extends sn {
    constructor(e) {
      super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
        premultiplyAlpha: "none"
      };
    }
    setOptions(e) {
      return this.options = e, this;
    }
    load(e, t, n, i) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = this, o = hi.get(e);
      if (o !== void 0) {
        if (r.manager.itemStart(e), o.then) {
          o.then((c) => {
            t && t(c), r.manager.itemEnd(e);
          }).catch((c) => {
            i && i(c);
          });
          return;
        }
        return setTimeout(function() {
          t && t(o), r.manager.itemEnd(e);
        }, 0), o;
      }
      const a = {};
      a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
      const l = fetch(e, a).then(function(c) {
        return c.blob();
      }).then(function(c) {
        return createImageBitmap(c, Object.assign(r.options, {
          colorSpaceConversion: "none"
        }));
      }).then(function(c) {
        return hi.add(e, c), t && t(c), r.manager.itemEnd(e), c;
      }).catch(function(c) {
        i && i(c), hi.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
      });
      hi.add(e, l), r.manager.itemStart(e);
    }
  }
  let La;
  class Nu {
    static getContext() {
      return La === void 0 && (La = new (window.AudioContext || window.webkitAudioContext)()), La;
    }
    static setContext(e) {
      La = e;
    }
  }
  class DS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const r = this, o = new xi(this.manager);
      o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
        try {
          const c = l.slice(0);
          Nu.getContext().decodeAudioData(c, function(d) {
            t(d);
          }).catch(a);
        } catch (c) {
          a(c);
        }
      }, n, i);
      function a(l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }
  }
  const bf = new De(), Sf = new De(), ss = new De();
  class NS {
    constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Et(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Et(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
      };
    }
    update(e) {
      const t = this._cache;
      if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ss.copy(e.projectionMatrix);
        const i = t.eyeSep / 2, r = i * t.near / t.focus, o = t.near * Math.tan(ws * t.fov * 0.5) / t.zoom;
        let a, l;
        Sf.elements[12] = -i, bf.elements[12] = i, a = -o * t.aspect + r, l = o * t.aspect + r, ss.elements[0] = 2 * t.near / (l - a), ss.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ss), a = -o * t.aspect - r, l = o * t.aspect - r, ss.elements[0] = 2 * t.near / (l - a), ss.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ss);
      }
      this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Sf), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(bf);
    }
  }
  class Og {
    constructor(e = true) {
      this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = wf(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const t = wf();
        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
      }
      return e;
    }
  }
  function wf() {
    return (typeof performance > "u" ? Date : performance).now();
  }
  const rs = new P(), Tf = new en(), US = new P(), os = new P();
  class OS extends Qe {
    constructor() {
      super(), this.type = "AudioListener", this.context = Nu.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Og();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(e) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e);
      const t = this.context.listener, n = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(rs, Tf, US), os.set(0, 0, -1).applyQuaternion(Tf), t.positionX) {
        const i = this.context.currentTime + this.timeDelta;
        t.positionX.linearRampToValueAtTime(rs.x, i), t.positionY.linearRampToValueAtTime(rs.y, i), t.positionZ.linearRampToValueAtTime(rs.z, i), t.forwardX.linearRampToValueAtTime(os.x, i), t.forwardY.linearRampToValueAtTime(os.y, i), t.forwardZ.linearRampToValueAtTime(os.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
      } else t.setPosition(rs.x, rs.y, rs.z), t.setOrientation(os.x, os.y, os.z, n.x, n.y, n.z);
    }
  }
  class zg extends Qe {
    constructor(e) {
      super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(e) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this;
    }
    setMediaElementSource(e) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
    }
    setMediaStreamSource(e) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
    }
    setBuffer(e) {
      return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(e = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + e;
      const t = this.context.createBufferSource();
      return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = false, this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this._connected !== false) {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this._connected = false, this;
      }
    }
    getFilters() {
      return this.filters;
    }
    setFilters(e) {
      return e || (e = []), this._connected === true ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
    }
    setDetune(e) {
      return this.detune = e, this.isPlaying === true && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(e) {
      return this.setFilters(e ? [
        e
      ] : []);
    }
    setPlaybackRate(e) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.playbackRate = e, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(e) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.loop = e, this.isPlaying === true && (this.source.loop = this.loop), this;
    }
    setLoopStart(e) {
      return this.loopStart = e, this;
    }
    setLoopEnd(e) {
      return this.loopEnd = e, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
    }
  }
  const as = new P(), Ef = new en(), zS = new P(), ls = new P();
  class FS extends zg {
    constructor(e) {
      super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
    }
    connect() {
      super.connect(), this.panner.connect(this.gain);
    }
    disconnect() {
      super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(e) {
      return this.panner.refDistance = e, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(e) {
      return this.panner.rolloffFactor = e, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(e) {
      return this.panner.distanceModel = e, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(e) {
      return this.panner.maxDistance = e, this;
    }
    setDirectionalCone(e, t, n) {
      return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
    }
    updateMatrixWorld(e) {
      if (super.updateMatrixWorld(e), this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(as, Ef, zS), ls.set(0, 0, 1).applyQuaternion(Ef);
      const t = this.panner;
      if (t.positionX) {
        const n = this.context.currentTime + this.listener.timeDelta;
        t.positionX.linearRampToValueAtTime(as.x, n), t.positionY.linearRampToValueAtTime(as.y, n), t.positionZ.linearRampToValueAtTime(as.z, n), t.orientationX.linearRampToValueAtTime(ls.x, n), t.orientationY.linearRampToValueAtTime(ls.y, n), t.orientationZ.linearRampToValueAtTime(ls.z, n);
      } else t.setPosition(as.x, as.y, as.z), t.setOrientation(ls.x, ls.y, ls.z);
    }
  }
  class BS {
    constructor(e, t = 2048) {
      this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let e = 0;
      const t = this.getFrequencyData();
      for (let n = 0; n < t.length; n++) e += t[n];
      return e / t.length;
    }
  }
  class Fg {
    constructor(e, t, n) {
      this.binding = e, this.valueSize = n;
      let i, r, o;
      switch (t) {
        case "quaternion":
          i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
          break;
        default:
          i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
      }
      this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(e, t) {
      const n = this.buffer, i = this.valueSize, r = e * i + i;
      let o = this.cumulativeWeight;
      if (o === 0) {
        for (let a = 0; a !== i; ++a) n[r + a] = n[a];
        o = t;
      } else {
        o += t;
        const a = t / o;
        this._mixBufferRegion(n, r, 0, a, i);
      }
      this.cumulativeWeight = o;
    }
    accumulateAdditive(e) {
      const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
    }
    apply(e) {
      const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
        const l = t * this._origIndex;
        this._mixBufferRegion(n, i, l, 1 - r, t);
      }
      o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
      for (let l = t, c = t + t; l !== c; ++l) if (n[l] !== n[l + t]) {
        a.setValue(n, i);
        break;
      }
    }
    saveOriginalState() {
      const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
      e.getValue(t, i);
      for (let r = n, o = i; r !== o; ++r) t[r] = t[i + r % n];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const e = this.valueSize * 3;
      this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
      const e = this._addIndex * this.valueSize, t = e + this.valueSize;
      for (let n = e; n < t; n++) this.buffer[n] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
      for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
    }
    _select(e, t, n, i, r) {
      if (i >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
    }
    _slerp(e, t, n, i) {
      en.slerpFlat(e, t, e, t, e, n, i);
    }
    _slerpAdditive(e, t, n, i, r) {
      const o = this._workIndex * r;
      en.multiplyQuaternionsFlat(e, o, e, t, e, n), en.slerpFlat(e, t, e, t, e, o, i);
    }
    _lerp(e, t, n, i, r) {
      const o = 1 - i;
      for (let a = 0; a !== r; ++a) {
        const l = t + a;
        e[l] = e[l] * o + e[n + a] * i;
      }
    }
    _lerpAdditive(e, t, n, i, r) {
      for (let o = 0; o !== r; ++o) {
        const a = t + o;
        e[a] = e[a] + e[n + o] * i;
      }
    }
  }
  const Uu = "\\[\\]\\.:\\/", kS = new RegExp("[" + Uu + "]", "g"), Ou = "[^" + Uu + "]", VS = "[^" + Uu.replace("\\.", "") + "]", HS = /((?:WC+[\/:])*)/.source.replace("WC", Ou), GS = /(WCOD+)?/.source.replace("WCOD", VS), WS = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ou), XS = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ou), YS = new RegExp("^" + HS + GS + WS + XS + "$"), qS = [
    "material",
    "materials",
    "bones",
    "map"
  ];
  class $S {
    constructor(e, t, n) {
      const i = n || Ke.parseTrackName(t);
      this._targetGroup = e, this._bindings = e.subscribe_(t, i);
    }
    getValue(e, t) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
      i !== void 0 && i.getValue(e, t);
    }
    setValue(e, t) {
      const n = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t);
    }
    bind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
    }
    unbind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
    }
  }
  class Ke {
    constructor(e, t, n) {
      this.path = t, this.parsedPath = n || Ke.parseTrackName(t), this.node = Ke.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e, t, n) {
      return e && e.isAnimationObjectGroup ? new Ke.Composite(e, t, n) : new Ke(e, t, n);
    }
    static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(kS, "");
    }
    static parseTrackName(e) {
      const t = YS.exec(e);
      if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6]
      }, i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (i !== void 0 && i !== -1) {
        const r = n.nodeName.substring(i + 1);
        qS.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
      }
      if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
      return n;
    }
    static findNode(e, t) {
      if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
      if (e.skeleton) {
        const n = e.skeleton.getBoneByName(t);
        if (n !== void 0) return n;
      }
      if (e.children) {
        const n = function(r) {
          for (let o = 0; o < r.length; o++) {
            const a = r[o];
            if (a.name === t || a.uuid === t) return a;
            const l = n(a.children);
            if (l) return l;
          }
          return null;
        }, i = n(e.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
    }
    _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t);
    }
    bind() {
      let e = this.node;
      const t = this.parsedPath, n = t.objectName, i = t.propertyName;
      let r = t.propertyIndex;
      if (e || (e = Ke.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
        console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
        return;
      }
      if (n) {
        let c = t.objectIndex;
        switch (n) {
          case "materials":
            if (!e.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!e.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            e = e.material.materials;
            break;
          case "bones":
            if (!e.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            e = e.skeleton.bones;
            for (let u = 0; u < e.length; u++) if (e[u].name === c) {
              c = u;
              break;
            }
            break;
          case "map":
            if ("map" in e) {
              e = e.map;
              break;
            }
            if (!e.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!e.material.map) {
              console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
              return;
            }
            e = e.material.map;
            break;
          default:
            if (e[n] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            e = e[n];
        }
        if (c !== void 0) {
          if (e[c] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
            return;
          }
          e = e[c];
        }
      }
      const o = e[i];
      if (o === void 0) {
        const c = t.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
        return;
      }
      let a = this.Versioning.None;
      this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
      let l = this.BindingType.Direct;
      if (r !== void 0) {
        if (i === "morphTargetInfluences") {
          if (!e.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
        }
        l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
      } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
      this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  Ke.Composite = $S;
  Ke.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  Ke.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  Ke.prototype.GetterByBindingType = [
    Ke.prototype._getValue_direct,
    Ke.prototype._getValue_array,
    Ke.prototype._getValue_arrayElement,
    Ke.prototype._getValue_toArray
  ];
  Ke.prototype.SetterByBindingTypeAndVersioning = [
    [
      Ke.prototype._setValue_direct,
      Ke.prototype._setValue_direct_setNeedsUpdate,
      Ke.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      Ke.prototype._setValue_array,
      Ke.prototype._setValue_array_setNeedsUpdate,
      Ke.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      Ke.prototype._setValue_arrayElement,
      Ke.prototype._setValue_arrayElement_setNeedsUpdate,
      Ke.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      Ke.prototype._setValue_fromArray,
      Ke.prototype._setValue_fromArray_setNeedsUpdate,
      Ke.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  class ZS {
    constructor() {
      this.isAnimationObjectGroup = true, this.uuid = fn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      const e = {};
      this._indicesByUUID = e;
      for (let n = 0, i = arguments.length; n !== i; ++n) e[arguments[n].uuid] = n;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      const t = this;
      this.stats = {
        objects: {
          get total() {
            return t._objects.length;
          },
          get inUse() {
            return this.total - t.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return t._bindings.length;
        }
      };
    }
    add() {
      const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length;
      let a, l = e.length, c = this.nCachedObjects_;
      for (let u = 0, d = arguments.length; u !== d; ++u) {
        const h = arguments[u], f = h.uuid;
        let m = t[f];
        if (m === void 0) {
          m = l++, t[f] = m, e.push(h);
          for (let v = 0, g = o; v !== g; ++v) r[v].push(new Ke(h, n[v], i[v]));
        } else if (m < c) {
          a = e[m];
          const v = --c, g = e[v];
          t[g.uuid] = m, e[m] = g, t[f] = v, e[v] = h;
          for (let p = 0, _ = o; p !== _; ++p) {
            const x = r[p], b = x[v];
            let E = x[m];
            x[m] = b, E === void 0 && (E = new Ke(h, n[p], i[p])), x[v] = E;
          }
        } else e[m] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = c;
    }
    remove() {
      const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
      let r = this.nCachedObjects_;
      for (let o = 0, a = arguments.length; o !== a; ++o) {
        const l = arguments[o], c = l.uuid, u = t[c];
        if (u !== void 0 && u >= r) {
          const d = r++, h = e[d];
          t[h.uuid] = u, e[u] = h, t[c] = d, e[d] = l;
          for (let f = 0, m = i; f !== m; ++f) {
            const v = n[f], g = v[d], p = v[u];
            v[u] = g, v[d] = p;
          }
        }
      }
      this.nCachedObjects_ = r;
    }
    uncache() {
      const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
      let r = this.nCachedObjects_, o = e.length;
      for (let a = 0, l = arguments.length; a !== l; ++a) {
        const c = arguments[a], u = c.uuid, d = t[u];
        if (d !== void 0) if (delete t[u], d < r) {
          const h = --r, f = e[h], m = --o, v = e[m];
          t[f.uuid] = d, e[d] = f, t[v.uuid] = h, e[h] = v, e.pop();
          for (let g = 0, p = i; g !== p; ++g) {
            const _ = n[g], x = _[h], b = _[m];
            _[d] = x, _[h] = b, _.pop();
          }
        } else {
          const h = --o, f = e[h];
          h > 0 && (t[f.uuid] = d), e[d] = f, e.pop();
          for (let m = 0, v = i; m !== v; ++m) {
            const g = n[m];
            g[d] = g[h], g.pop();
          }
        }
      }
      this.nCachedObjects_ = r;
    }
    subscribe_(e, t) {
      const n = this._bindingsIndicesByPath;
      let i = n[e];
      const r = this._bindings;
      if (i !== void 0) return r[i];
      const o = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, u = this.nCachedObjects_, d = new Array(c);
      i = r.length, n[e] = i, o.push(e), a.push(t), r.push(d);
      for (let h = u, f = l.length; h !== f; ++h) {
        const m = l[h];
        d[h] = new Ke(m, e, t);
      }
      return d;
    }
    unsubscribe_(e) {
      const t = this._bindingsIndicesByPath, n = t[e];
      if (n !== void 0) {
        const i = this._paths, r = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], c = e[a];
        t[c] = n, o[n] = l, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop();
      }
    }
  }
  class Bg {
    constructor(e, t, n = null, i = t.blendMode) {
      this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
      const r = t.tracks, o = r.length, a = new Array(o), l = {
        endingStart: gs,
        endingEnd: gs
      };
      for (let c = 0; c !== o; ++c) {
        const u = r[c].createInterpolant(null);
        a[c] = u, u.settings = l;
      }
      this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = vm, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e) {
      return this._startTime = e, this;
    }
    setLoop(e, t) {
      return this.loop = e, this.repetitions = t, this;
    }
    setEffectiveWeight(e) {
      return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e) {
      return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
      return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, n) {
      if (e.fadeOut(t), this.fadeIn(t), n) {
        const i = this._clip.duration, r = e._clip.duration, o = r / i, a = i / r;
        e.warp(1, o, t), this.warp(a, 1, t);
      }
      return this;
    }
    crossFadeTo(e, t, n) {
      return e.crossFadeFrom(this, t, n);
    }
    stopFading() {
      const e = this._weightInterpolant;
      return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
    }
    setEffectiveTimeScale(e) {
      return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e) {
      return this.timeScale = this._clip.duration / e, this.stopWarping();
    }
    syncWith(e) {
      return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
    }
    halt(e) {
      return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, n) {
      const i = this._mixer, r = i.time, o = this.timeScale;
      let a = this._timeScaleInterpolant;
      a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
      const l = a.parameterPositions, c = a.sampleValues;
      return l[0] = r, l[1] = r + n, c[0] = e / o, c[1] = t / o, this;
    }
    stopWarping() {
      const e = this._timeScaleInterpolant;
      return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e, t, n, i) {
      if (!this.enabled) {
        this._updateWeight(e);
        return;
      }
      const r = this._startTime;
      if (r !== null) {
        const l = (e - r) * n;
        l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
      }
      t *= this._updateTimeScale(e);
      const o = this._updateTime(t), a = this._updateWeight(e);
      if (a > 0) {
        const l = this._interpolants, c = this._propertyBindings;
        switch (this.blendMode) {
          case lu:
            for (let u = 0, d = l.length; u !== d; ++u) l[u].evaluate(o), c[u].accumulateAdditive(a);
            break;
          case yl:
          default:
            for (let u = 0, d = l.length; u !== d; ++u) l[u].evaluate(o), c[u].accumulate(i, a);
        }
      }
    }
    _updateWeight(e) {
      let t = 0;
      if (this.enabled) {
        t = this.weight;
        const n = this._weightInterpolant;
        if (n !== null) {
          const i = n.evaluate(e)[0];
          t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = t, t;
    }
    _updateTimeScale(e) {
      let t = 0;
      if (!this.paused) {
        t = this.timeScale;
        const n = this._timeScaleInterpolant;
        if (n !== null) {
          const i = n.evaluate(e)[0];
          t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = true : this.timeScale = t);
        }
      }
      return this._effectiveTimeScale = t, t;
    }
    _updateTime(e) {
      const t = this._clip.duration, n = this.loop;
      let i = this.time + e, r = this._loopCount;
      const o = n === xm;
      if (e === 0) return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
      if (n === gm) {
        r === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        e: {
          if (i >= t) i = t;
          else if (i < 0) i = 0;
          else {
            this.time = i;
            break e;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1
          });
        }
      } else {
        if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(true, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, true, o)), i >= t || i < 0) {
          const a = Math.floor(i / t);
          i -= t * a, r += Math.abs(a);
          const l = this.repetitions - r;
          if (l <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
          else {
            if (l === 1) {
              const c = e < 0;
              this._setEndings(c, !c, o);
            } else this._setEndings(false, false, o);
            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a
            });
          }
        } else this.time = i;
        if (o && (r & 1) === 1) return t - i;
      }
      return i;
    }
    _setEndings(e, t, n) {
      const i = this._interpolantSettings;
      n ? (i.endingStart = vs, i.endingEnd = vs) : (e ? i.endingStart = this.zeroSlopeAtStart ? vs : gs : i.endingStart = lo, t ? i.endingEnd = this.zeroSlopeAtEnd ? vs : gs : i.endingEnd = lo);
    }
    _scheduleFading(e, t, n) {
      const i = this._mixer, r = i.time;
      let o = this._weightInterpolant;
      o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
      const a = o.parameterPositions, l = o.sampleValues;
      return a[0] = r, l[0] = t, a[1] = r + e, l[1] = n, this;
    }
  }
  const JS = new Float32Array(1);
  class KS extends Mi {
    constructor(e) {
      super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(e, t) {
      const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, o = e._propertyBindings, a = e._interpolants, l = n.uuid, c = this._bindingsByRootAndName;
      let u = c[l];
      u === void 0 && (u = {}, c[l] = u);
      for (let d = 0; d !== r; ++d) {
        const h = i[d], f = h.name;
        let m = u[f];
        if (m !== void 0) ++m.referenceCount, o[d] = m;
        else {
          if (m = o[d], m !== void 0) {
            m._cacheIndex === null && (++m.referenceCount, this._addInactiveBinding(m, l, f));
            continue;
          }
          const v = t && t._propertyBindings[d].binding.parsedPath;
          m = new Fg(Ke.create(n, f, v), h.ValueTypeName, h.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, l, f), o[d] = m;
        }
        a[d].resultBuffer = m.buffer;
      }
    }
    _activateAction(e) {
      if (!this._isActiveAction(e)) {
        if (e._cacheIndex === null) {
          const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i];
          this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, n);
        }
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
          const r = t[n];
          r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
        }
        this._lendAction(e);
      }
    }
    _deactivateAction(e) {
      if (this._isActiveAction(e)) {
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
          const r = t[n];
          --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
        }
        this._takeBackAction(e);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const e = this;
      this.stats = {
        actions: {
          get total() {
            return e._actions.length;
          },
          get inUse() {
            return e._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return e._bindings.length;
          },
          get inUse() {
            return e._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return e._controlInterpolants.length;
          },
          get inUse() {
            return e._nActiveControlInterpolants;
          }
        }
      };
    }
    _isActiveAction(e) {
      const t = e._cacheIndex;
      return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, n) {
      const i = this._actions, r = this._actionsByClip;
      let o = r[t];
      if (o === void 0) o = {
        knownActions: [
          e
        ],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = o;
      else {
        const a = o.knownActions;
        e._byClipCacheIndex = a.length, a.push(e);
      }
      e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e;
    }
    _removeInactiveAction(e) {
      const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
      n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
      const r = e._clip.uuid, o = this._actionsByClip, a = o[r], l = a.knownActions, c = l[l.length - 1], u = e._byClipCacheIndex;
      c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
      const d = a.actionByRoot, h = (e._localRoot || this._root).uuid;
      delete d[h], l.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        --r.referenceCount === 0 && this._removeInactiveBinding(r);
      }
    }
    _lendAction(e) {
      const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
      e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
    }
    _takeBackAction(e) {
      const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
      e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
    }
    _addInactiveBinding(e, t, n) {
      const i = this._bindingsByRootAndName, r = this._bindings;
      let o = i[t];
      o === void 0 && (o = {}, i[t] = o), o[n] = e, e._cacheIndex = r.length, r.push(e);
    }
    _removeInactiveBinding(e) {
      const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, a = o[i], l = t[t.length - 1], c = e._cacheIndex;
      l._cacheIndex = c, t[c] = l, t.pop(), delete a[r], Object.keys(a).length === 0 && delete o[i];
    }
    _lendBinding(e) {
      const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
      e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
    }
    _takeBackBinding(e) {
      const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
      e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
    }
    _lendControlInterpolant() {
      const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
      let n = e[t];
      return n === void 0 && (n = new Ru(new Float32Array(2), new Float32Array(2), 1, JS), n.__cacheIndex = t, e[t] = n), n;
    }
    _takeBackControlInterpolant(e) {
      const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
      e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r;
    }
    clipAction(e, t, n) {
      const i = t || this._root, r = i.uuid;
      let o = typeof e == "string" ? Mo.findByName(i, e) : e;
      const a = o !== null ? o.uuid : e, l = this._actionsByClip[a];
      let c = null;
      if (n === void 0 && (o !== null ? n = o.blendMode : n = yl), l !== void 0) {
        const d = l.actionByRoot[r];
        if (d !== void 0 && d.blendMode === n) return d;
        c = l.knownActions[0], o === null && (o = c._clip);
      }
      if (o === null) return null;
      const u = new Bg(this, o, t, n);
      return this._bindAction(u, c), this._addInactiveAction(u, a, r), u;
    }
    existingAction(e, t) {
      const n = t || this._root, i = n.uuid, r = typeof e == "string" ? Mo.findByName(n, e) : e, o = r ? r.uuid : e, a = this._actionsByClip[o];
      return a !== void 0 && a.actionByRoot[i] || null;
    }
    stopAllAction() {
      const e = this._actions, t = this._nActiveActions;
      for (let n = t - 1; n >= 0; --n) e[n].stop();
      return this;
    }
    update(e) {
      e *= this.timeScale;
      const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1;
      for (let c = 0; c !== n; ++c) t[c]._update(i, e, r, o);
      const a = this._bindings, l = this._nActiveBindings;
      for (let c = 0; c !== l; ++c) a[c].apply(o);
      return this;
    }
    setTime(e) {
      this.time = 0;
      for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
      return this.update(e);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e) {
      const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
      if (r !== void 0) {
        const o = r.knownActions;
        for (let a = 0, l = o.length; a !== l; ++a) {
          const c = o[a];
          this._deactivateAction(c);
          const u = c._cacheIndex, d = t[t.length - 1];
          c._cacheIndex = null, c._byClipCacheIndex = null, d._cacheIndex = u, t[u] = d, t.pop(), this._removeInactiveBindingsForAction(c);
        }
        delete i[n];
      }
    }
    uncacheRoot(e) {
      const t = e.uuid, n = this._actionsByClip;
      for (const o in n) {
        const a = n[o].actionByRoot, l = a[t];
        l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
      }
      const i = this._bindingsByRootAndName, r = i[t];
      if (r !== void 0) for (const o in r) {
        const a = r[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
    }
    uncacheAction(e, t) {
      const n = this.existingAction(e, t);
      n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
    }
  }
  class zu {
    constructor(e) {
      this.value = e;
    }
    clone() {
      return new zu(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  }
  let jS = 0;
  class QS extends Mi {
    constructor() {
      super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", {
        value: jS++
      }), this.name = "", this.usage = fo, this.uniforms = [];
    }
    add(e) {
      return this.uniforms.push(e), this;
    }
    remove(e) {
      const t = this.uniforms.indexOf(e);
      return t !== -1 && this.uniforms.splice(t, 1), this;
    }
    setName(e) {
      return this.name = e, this;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    dispose() {
      return this.dispatchEvent({
        type: "dispose"
      }), this;
    }
    copy(e) {
      this.name = e.name, this.usage = e.usage;
      const t = e.uniforms;
      this.uniforms.length = 0;
      for (let n = 0, i = t.length; n < i; n++) {
        const r = Array.isArray(t[n]) ? t[n] : [
          t[n]
        ];
        for (let o = 0; o < r.length; o++) this.uniforms.push(r[o].clone());
      }
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class ew extends Rl {
    constructor(e, t, n = 1) {
      super(e, t), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = n;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    clone(e) {
      const t = super.clone(e);
      return t.meshPerAttribute = this.meshPerAttribute, t;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.isInstancedInterleavedBuffer = true, t.meshPerAttribute = this.meshPerAttribute, t;
    }
  }
  class tw {
    constructor(e, t, n, i, r) {
      this.isGLBufferAttribute = true, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    setBuffer(e) {
      return this.buffer = e, this;
    }
    setType(e, t) {
      return this.type = e, this.elementSize = t, this;
    }
    setItemSize(e) {
      return this.itemSize = e, this;
    }
    setCount(e) {
      return this.count = e, this;
    }
  }
  const Af = new De();
  class kg {
    constructor(e, t, n = 0, i = 1 / 0) {
      this.ray = new yr(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Sl(), this.params = {
        Mesh: {},
        Line: {
          threshold: 1
        },
        LOD: {},
        Points: {
          threshold: 1
        },
        Sprite: {}
      };
    }
    set(e, t) {
      this.ray.set(e, t);
    }
    setFromCamera(e, t) {
      t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    setFromXRController(e) {
      return Af.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Af), this;
    }
    intersectObject(e, t = true, n = []) {
      return zh(e, this, n, t), n.sort(Cf), n;
    }
    intersectObjects(e, t = true, n = []) {
      for (let i = 0, r = e.length; i < r; i++) zh(e[i], this, n, t);
      return n.sort(Cf), n;
    }
  }
  function Cf(s, e) {
    return s.distance - e.distance;
  }
  function zh(s, e, t, n) {
    if (s.layers.test(e.layers) && s.raycast(e, t), n === true) {
      const i = s.children;
      for (let r = 0, o = i.length; r < o; r++) zh(i[r], e, t, true);
    }
  }
  class nw {
    constructor(e = 1, t = 0, n = 0) {
      return this.radius = e, this.phi = t, this.theta = n, this;
    }
    set(e, t, n) {
      return this.radius = e, this.phi = t, this.theta = n, this;
    }
    copy(e) {
      return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
    }
    makeSafe() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
      return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(mt(t / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class iw {
    constructor(e = 1, t = 0, n = 0) {
      return this.radius = e, this.theta = t, this.y = n, this;
    }
    set(e, t, n) {
      return this.radius = e, this.theta = t, this.y = n, this;
    }
    copy(e) {
      return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
      return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Rf = new ee();
  class sw {
    constructor(e = new ee(1 / 0, 1 / 0), t = new ee(-1 / 0, -1 / 0)) {
      this.isBox2 = true, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const n = Rf.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
      return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
      return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
    }
    getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(e) {
      return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return this.clampPoint(e, Rf).distanceTo(e);
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  const Pf = new P(), Da = new P();
  class rw {
    constructor(e = new P(), t = new P()) {
      this.start = e, this.end = t;
    }
    set(e, t) {
      return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
      return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
      return e.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e) {
      return e.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(e, t) {
      return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
      Pf.subVectors(e, this.start), Da.subVectors(this.end, this.start);
      const n = Da.dot(Da);
      let r = Da.dot(Pf) / n;
      return t && (r = mt(r, 0, 1)), r;
    }
    closestPointToPoint(e, t, n) {
      const i = this.closestPointToPointParameter(e, t);
      return this.delta(n).multiplyScalar(i).add(this.start);
    }
    applyMatrix4(e) {
      return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
      return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const If = new P();
  class ow extends Qe {
    constructor(e, t) {
      super(), this.light = e, this.matrixAutoUpdate = false, this.color = t, this.type = "SpotLightHelper";
      const n = new We(), i = [
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        -1,
        1
      ];
      for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
        const c = o / l * Math.PI * 2, u = a / l * Math.PI * 2;
        i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
      }
      n.setAttribute("position", new Ee(i, 3));
      const r = new Jt({
        fog: false,
        toneMapped: false
      });
      this.cone = new Kn(n, r), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), this.parent ? (this.parent.updateWorldMatrix(true), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
      const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
      this.cone.scale.set(t, t, e), If.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(If), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  }
  const Ii = new P(), Na = new De(), Fc = new De();
  class aw extends Kn {
    constructor(e) {
      const t = Vg(e), n = new We(), i = [], r = [], o = new ye(0, 0, 1), a = new ye(0, 1, 0);
      for (let c = 0; c < t.length; c++) {
        const u = t[c];
        u.parent && u.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b));
      }
      n.setAttribute("position", new Ee(i, 3)), n.setAttribute("color", new Ee(r, 3));
      const l = new Jt({
        vertexColors: true,
        depthTest: false,
        depthWrite: false,
        toneMapped: false,
        transparent: true
      });
      super(n, l), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(e) {
      const t = this.bones, n = this.geometry, i = n.getAttribute("position");
      Fc.copy(this.root.matrixWorld).invert();
      for (let r = 0, o = 0; r < t.length; r++) {
        const a = t[r];
        a.parent && a.parent.isBone && (Na.multiplyMatrices(Fc, a.matrixWorld), Ii.setFromMatrixPosition(Na), i.setXYZ(o, Ii.x, Ii.y, Ii.z), Na.multiplyMatrices(Fc, a.parent.matrixWorld), Ii.setFromMatrixPosition(Na), i.setXYZ(o + 1, Ii.x, Ii.y, Ii.z), o += 2);
      }
      n.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function Vg(s) {
    const e = [];
    s.isBone === true && e.push(s);
    for (let t = 0; t < s.children.length; t++) e.push.apply(e, Vg(s.children[t]));
    return e;
  }
  class lw extends ht {
    constructor(e, t, n) {
      const i = new ko(t, 4, 2), r = new Xi({
        wireframe: true,
        fog: false,
        toneMapped: false
      });
      super(i, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  }
  const cw = new P(), Lf = new ye(), Df = new ye();
  class hw extends Qe {
    constructor(e, t, n) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n, this.type = "HemisphereLightHelper";
      const i = new Fo(t);
      i.rotateY(Math.PI * 0.5), this.material = new Xi({
        wireframe: true,
        fog: false,
        toneMapped: false
      }), this.color === void 0 && (this.material.vertexColors = true);
      const r = i.getAttribute("position"), o = new Float32Array(r.count * 3);
      i.setAttribute("color", new at(o, 3)), this.add(new ht(i, this.material)), this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      const e = this.children[0];
      if (this.color !== void 0) this.material.color.set(this.color);
      else {
        const t = e.geometry.getAttribute("color");
        Lf.copy(this.light.color), Df.copy(this.light.groundColor);
        for (let n = 0, i = t.count; n < i; n++) {
          const r = n < i / 2 ? Lf : Df;
          t.setXYZ(n, r.r, r.g, r.b);
        }
        t.needsUpdate = true;
      }
      this.light.updateWorldMatrix(true, false), e.lookAt(cw.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }
  class Hg extends Kn {
    constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
      n = new ye(n), i = new ye(i);
      const r = t / 2, o = e / t, a = e / 2, l = [], c = [];
      for (let h = 0, f = 0, m = -a; h <= t; h++, m += o) {
        l.push(-a, 0, m, a, 0, m), l.push(m, 0, -a, m, 0, a);
        const v = h === r ? n : i;
        v.toArray(c, f), f += 3, v.toArray(c, f), f += 3, v.toArray(c, f), f += 3, v.toArray(c, f), f += 3;
      }
      const u = new We();
      u.setAttribute("position", new Ee(l, 3)), u.setAttribute("color", new Ee(c, 3));
      const d = new Jt({
        vertexColors: true,
        toneMapped: false
      });
      super(u, d), this.type = "GridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class uw extends Kn {
    constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, o = 8947848) {
      r = new ye(r), o = new ye(o);
      const a = [], l = [];
      if (t > 1) for (let d = 0; d < t; d++) {
        const h = d / t * (Math.PI * 2), f = Math.sin(h) * e, m = Math.cos(h) * e;
        a.push(0, 0, 0), a.push(f, 0, m);
        const v = d & 1 ? r : o;
        l.push(v.r, v.g, v.b), l.push(v.r, v.g, v.b);
      }
      for (let d = 0; d < n; d++) {
        const h = d & 1 ? r : o, f = e - e / n * d;
        for (let m = 0; m < i; m++) {
          let v = m / i * (Math.PI * 2), g = Math.sin(v) * f, p = Math.cos(v) * f;
          a.push(g, 0, p), l.push(h.r, h.g, h.b), v = (m + 1) / i * (Math.PI * 2), g = Math.sin(v) * f, p = Math.cos(v) * f, a.push(g, 0, p), l.push(h.r, h.g, h.b);
        }
      }
      const c = new We();
      c.setAttribute("position", new Ee(a, 3)), c.setAttribute("color", new Ee(l, 3));
      const u = new Jt({
        vertexColors: true,
        toneMapped: false
      });
      super(c, u), this.type = "PolarGridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  const Nf = new P(), Ua = new P(), Uf = new P();
  class dw extends Qe {
    constructor(e, t, n) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
      let i = new We();
      i.setAttribute("position", new Ee([
        -t,
        t,
        0,
        t,
        t,
        0,
        t,
        -t,
        0,
        -t,
        -t,
        0,
        -t,
        t,
        0
      ], 3));
      const r = new Jt({
        fog: false,
        toneMapped: false
      });
      this.lightPlane = new ki(i, r), this.add(this.lightPlane), i = new We(), i.setAttribute("position", new Ee([
        0,
        0,
        0,
        0,
        0,
        1
      ], 3)), this.targetLine = new ki(i, r), this.add(this.targetLine), this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), Nf.setFromMatrixPosition(this.light.matrixWorld), Ua.setFromMatrixPosition(this.light.target.matrixWorld), Uf.subVectors(Ua, Nf), this.lightPlane.lookAt(Ua), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ua), this.targetLine.scale.z = Uf.length();
    }
  }
  const Oa = new P(), pt = new wl();
  class fw extends Kn {
    constructor(e) {
      const t = new We(), n = new Jt({
        color: 16777215,
        vertexColors: true,
        toneMapped: false
      }), i = [], r = [], o = {};
      a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
      function a(m, v) {
        l(m), l(v);
      }
      function l(m) {
        i.push(0, 0, 0), r.push(0, 0, 0), o[m] === void 0 && (o[m] = []), o[m].push(i.length / 3 - 1);
      }
      t.setAttribute("position", new Ee(i, 3)), t.setAttribute("color", new Ee(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = o, this.update();
      const c = new ye(16755200), u = new ye(16711680), d = new ye(43775), h = new ye(16777215), f = new ye(3355443);
      this.setColors(c, u, d, h, f);
    }
    setColors(e, t, n, i, r) {
      const a = this.geometry.getAttribute("color");
      a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, r.r, r.g, r.b), a.setXYZ(41, r.r, r.g, r.b), a.setXYZ(42, r.r, r.g, r.b), a.setXYZ(43, r.r, r.g, r.b), a.setXYZ(44, r.r, r.g, r.b), a.setXYZ(45, r.r, r.g, r.b), a.setXYZ(46, r.r, r.g, r.b), a.setXYZ(47, r.r, r.g, r.b), a.setXYZ(48, r.r, r.g, r.b), a.setXYZ(49, r.r, r.g, r.b), a.needsUpdate = true;
    }
    update() {
      const e = this.geometry, t = this.pointMap, n = 1, i = 1;
      pt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), xt("c", t, e, pt, 0, 0, -1), xt("t", t, e, pt, 0, 0, 1), xt("n1", t, e, pt, -n, -i, -1), xt("n2", t, e, pt, n, -i, -1), xt("n3", t, e, pt, -n, i, -1), xt("n4", t, e, pt, n, i, -1), xt("f1", t, e, pt, -n, -i, 1), xt("f2", t, e, pt, n, -i, 1), xt("f3", t, e, pt, -n, i, 1), xt("f4", t, e, pt, n, i, 1), xt("u1", t, e, pt, n * 0.7, i * 1.1, -1), xt("u2", t, e, pt, -n * 0.7, i * 1.1, -1), xt("u3", t, e, pt, 0, i * 2, -1), xt("cf1", t, e, pt, -n, 0, 1), xt("cf2", t, e, pt, n, 0, 1), xt("cf3", t, e, pt, 0, -i, 1), xt("cf4", t, e, pt, 0, i, 1), xt("cn1", t, e, pt, -n, 0, -1), xt("cn2", t, e, pt, n, 0, -1), xt("cn3", t, e, pt, 0, -i, -1), xt("cn4", t, e, pt, 0, i, -1), e.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function xt(s, e, t, n, i, r, o) {
    Oa.set(i, r, o).unproject(n);
    const a = e[s];
    if (a !== void 0) {
      const l = t.getAttribute("position");
      for (let c = 0, u = a.length; c < u; c++) l.setXYZ(a[c], Oa.x, Oa.y, Oa.z);
    }
  }
  const za = new Bt();
  class pw extends Kn {
    constructor(e, t = 16776960) {
      const n = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
      ]), i = new Float32Array(8 * 3), r = new We();
      r.setIndex(new at(n, 1)), r.setAttribute("position", new at(i, 3)), super(r, new Jt({
        color: t,
        toneMapped: false
      })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
    }
    update(e) {
      if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && za.setFromObject(this.object), za.isEmpty()) return;
      const t = za.min, n = za.max, i = this.geometry.attributes.position, r = i.array;
      r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = true, this.geometry.computeBoundingSphere();
    }
    setFromObject(e) {
      return this.object = e, this.update(), this;
    }
    copy(e, t) {
      return super.copy(e, t), this.object = e.object, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class mw extends Kn {
    constructor(e, t = 16776960) {
      const n = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
      ]), i = [
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1
      ], r = new We();
      r.setIndex(new at(n, 1)), r.setAttribute("position", new Ee(i, 3)), super(r, new Jt({
        color: t,
        toneMapped: false
      })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
      const t = this.box;
      t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class gw extends ki {
    constructor(e, t = 1, n = 16776960) {
      const i = n, r = [
        1,
        -1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        -1,
        0,
        1,
        1,
        0
      ], o = new We();
      o.setAttribute("position", new Ee(r, 3)), o.computeBoundingSphere(), super(o, new Jt({
        color: i,
        toneMapped: false
      })), this.type = "PlaneHelper", this.plane = e, this.size = t;
      const a = [
        1,
        1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        -1,
        0
      ], l = new We();
      l.setAttribute("position", new Ee(a, 3)), l.computeBoundingSphere(), this.add(new ht(l, new Xi({
        color: i,
        opacity: 0.2,
        transparent: true,
        depthWrite: false,
        toneMapped: false
      })));
    }
    updateMatrixWorld(e) {
      this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
  }
  const Of = new P();
  let Fa, Bc;
  class vw extends Qe {
    constructor(e = new P(0, 0, 1), t = new P(0, 0, 0), n = 1, i = 16776960, r = n * 0.2, o = r * 0.2) {
      super(), this.type = "ArrowHelper", Fa === void 0 && (Fa = new We(), Fa.setAttribute("position", new Ee([
        0,
        0,
        0,
        0,
        1,
        0
      ], 3)), Bc = new Sr(0, 0.5, 1, 5, 1), Bc.translate(0, -0.5, 0)), this.position.copy(t), this.line = new ki(Fa, new Jt({
        color: i,
        toneMapped: false
      })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new ht(Bc, new Xi({
        color: i,
        toneMapped: false
      })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o);
    }
    setDirection(e) {
      if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
      else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
      else {
        Of.set(e.z, 0, -e.x).normalize();
        const t = Math.acos(e.y);
        this.quaternion.setFromAxisAngle(Of, t);
      }
    }
    setLength(e, t = e * 0.2, n = t * 0.2) {
      this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
    }
    setColor(e) {
      this.line.material.color.set(e), this.cone.material.color.set(e);
    }
    copy(e) {
      return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this;
    }
    dispose() {
      this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
    }
  }
  class xw extends Kn {
    constructor(e = 1) {
      const t = [
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        0,
        e
      ], n = [
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
      ], i = new We();
      i.setAttribute("position", new Ee(t, 3)), i.setAttribute("color", new Ee(n, 3));
      const r = new Jt({
        vertexColors: true,
        toneMapped: false
      });
      super(i, r), this.type = "AxesHelper";
    }
    setColors(e, t, n) {
      const i = new ye(), r = this.geometry.attributes.color.array;
      return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class _w {
    constructor() {
      this.type = "ShapePath", this.color = new ye(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(e, t) {
      return this.currentPath = new As(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
    }
    lineTo(e, t) {
      return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, n, i) {
      return this.currentPath.quadraticCurveTo(e, t, n, i), this;
    }
    bezierCurveTo(e, t, n, i, r, o) {
      return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
    }
    splineThru(e) {
      return this.currentPath.splineThru(e), this;
    }
    toShapes(e) {
      function t(p) {
        const _ = [];
        for (let x = 0, b = p.length; x < b; x++) {
          const E = p[x], S = new Pt();
          S.curves = E.curves, _.push(S);
        }
        return _;
      }
      function n(p, _) {
        const x = _.length;
        let b = false;
        for (let E = x - 1, S = 0; S < x; E = S++) {
          let w = _[E], A = _[S], M = A.x - w.x, y = A.y - w.y;
          if (Math.abs(y) > Number.EPSILON) {
            if (y < 0 && (w = _[S], M = -M, A = _[E], y = -y), p.y < w.y || p.y > A.y) continue;
            if (p.y === w.y) {
              if (p.x === w.x) return true;
            } else {
              const C = y * (p.x - w.x) - M * (p.y - w.y);
              if (C === 0) return true;
              if (C < 0) continue;
              b = !b;
            }
          } else {
            if (p.y !== w.y) continue;
            if (A.x <= p.x && p.x <= w.x || w.x <= p.x && p.x <= A.x) return true;
          }
        }
        return b;
      }
      const i = qn.isClockWise, r = this.subPaths;
      if (r.length === 0) return [];
      let o, a, l;
      const c = [];
      if (r.length === 1) return a = r[0], l = new Pt(), l.curves = a.curves, c.push(l), c;
      let u = !i(r[0].getPoints());
      u = e ? !u : u;
      const d = [], h = [];
      let f = [], m = 0, v;
      h[m] = void 0, f[m] = [];
      for (let p = 0, _ = r.length; p < _; p++) a = r[p], v = a.getPoints(), o = i(v), o = e ? !o : o, o ? (!u && h[m] && m++, h[m] = {
        s: new Pt(),
        p: v
      }, h[m].s.curves = a.curves, u && m++, f[m] = []) : f[m].push({
        h: a,
        p: v[0]
      });
      if (!h[0]) return t(r);
      if (h.length > 1) {
        let p = false, _ = 0;
        for (let x = 0, b = h.length; x < b; x++) d[x] = [];
        for (let x = 0, b = h.length; x < b; x++) {
          const E = f[x];
          for (let S = 0; S < E.length; S++) {
            const w = E[S];
            let A = true;
            for (let M = 0; M < h.length; M++) n(w.p, h[M].p) && (x !== M && _++, A ? (A = false, d[M].push(w)) : p = true);
            A && d[x].push(w);
          }
        }
        _ > 0 && p === false && (f = d);
      }
      let g;
      for (let p = 0, _ = h.length; p < _; p++) {
        l = h[p].s, c.push(l), g = f[p];
        for (let x = 0, b = g.length; x < b; x++) l.holes.push(g[x].h);
      }
      return c;
    }
  }
  class yw extends zn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
      console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, {
        ...i,
        count: n
      }), this.isWebGLMultipleRenderTargets = true;
    }
    get texture() {
      return this.textures;
    }
  }
  typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
      revision: vl
    }
  }));
  typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = vl);
  const Mw = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: nm,
    AddEquation: Di,
    AddOperation: jp,
    AdditiveAnimationBlendMode: lu,
    AdditiveBlending: jc,
    AgXToneMapping: sm,
    AlphaFormat: hm,
    AlwaysCompare: Cm,
    AlwaysDepth: Xp,
    AlwaysStencilFunc: Ch,
    AmbientLight: Du,
    AnimationAction: Bg,
    AnimationClip: Mo,
    AnimationLoader: bS,
    AnimationMixer: KS,
    AnimationObjectGroup: ZS,
    AnimationUtils: xS,
    ArcCurve: ig,
    ArrayCamera: Ym,
    ArrowHelper: vw,
    AttachedBindMode: th,
    Audio: zg,
    AudioAnalyser: BS,
    AudioContext: Nu,
    AudioListener: OS,
    AudioLoader: DS,
    AxesHelper: xw,
    BackSide: Zt,
    BasicDepthPacking: _m,
    BasicShadowMap: P0,
    BatchedMesh: Qm,
    Bone: yu,
    BooleanKeyframeTrack: Rs,
    Box2: sw,
    Box3: Bt,
    Box3Helper: mw,
    BoxGeometry: bi,
    BoxHelper: pw,
    BufferAttribute: at,
    BufferGeometry: We,
    BufferGeometryLoader: Ug,
    ByteType: am,
    Cache: hi,
    Camera: wl,
    CameraHelper: fw,
    CanvasTexture: ng,
    CapsuleGeometry: Dl,
    CatmullRomCurve3: sg,
    CineonToneMapping: tm,
    CircleGeometry: Nl,
    ClampToEdgeWrapping: wn,
    Clock: Og,
    Color: ye,
    ColorKeyframeTrack: Pu,
    ColorManagement: st,
    CompressedArrayTexture: Vb,
    CompressedCubeTexture: Hb,
    CompressedTexture: Il,
    CompressedTextureLoader: SS,
    ConeGeometry: Ul,
    ConstantAlphaFactor: Hp,
    ConstantColorFactor: kp,
    CubeCamera: zm,
    CubeReflectionMapping: gi,
    CubeRefractionMapping: Bi,
    CubeTexture: Uo,
    CubeTextureLoader: wS,
    CubeUVReflectionMapping: xr,
    CubicBezierCurve: Su,
    CubicBezierCurve3: rg,
    CubicInterpolant: wg,
    CullFaceBack: Kc,
    CullFaceFront: Tp,
    CullFaceFrontBack: R0,
    CullFaceNone: wp,
    Curve: kn,
    CurvePath: ag,
    CustomBlending: Ep,
    CustomToneMapping: im,
    CylinderGeometry: Sr,
    Cylindrical: iw,
    Data3DTexture: uu,
    DataArrayTexture: bl,
    DataTexture: Oi,
    DataTextureLoader: TS,
    DataUtils: Bv,
    DecrementStencilOp: V0,
    DecrementWrapStencilOp: G0,
    DefaultLoadingManager: Ag,
    DepthFormat: Ss,
    DepthStencilFormat: hr,
    DepthTexture: mu,
    DetachedBindMode: om,
    DirectionalLight: ja,
    DirectionalLightHelper: dw,
    DiscreteInterpolant: Tg,
    DisplayP3ColorSpace: Ml,
    DodecahedronGeometry: Ol,
    DoubleSide: Qt,
    DstAlphaFactor: Up,
    DstColorFactor: zp,
    DynamicCopyUsage: sv,
    DynamicDrawUsage: j0,
    DynamicReadUsage: tv,
    EdgesGeometry: lg,
    EllipseCurve: Ll,
    EqualCompare: wm,
    EqualDepth: qp,
    EqualStencilFunc: q0,
    EquirectangularReflectionMapping: cr,
    EquirectangularRefractionMapping: io,
    Euler: mn,
    EventDispatcher: Mi,
    ExtrudeGeometry: ln,
    FileLoader: xi,
    Float16BufferAttribute: Xv,
    Float32BufferAttribute: Ee,
    FloatType: Tn,
    Fog: Cl,
    FogExp2: Al,
    FramebufferTexture: kb,
    FrontSide: mi,
    Frustum: Oo,
    GLBufferAttribute: tw,
    GLSL1: ov,
    GLSL3: Rh,
    GreaterCompare: Tm,
    GreaterDepth: Zp,
    GreaterEqualCompare: Am,
    GreaterEqualDepth: $p,
    GreaterEqualStencilFunc: K0,
    GreaterStencilFunc: Z0,
    GridHelper: Hg,
    Group: Ln,
    HalfFloatType: Do,
    HemisphereLight: Cg,
    HemisphereLightHelper: hw,
    IcosahedronGeometry: Fl,
    ImageBitmapLoader: LS,
    ImageLoader: bo,
    ImageUtils: Lm,
    IncrementStencilOp: k0,
    IncrementWrapStencilOp: H0,
    InstancedBufferAttribute: fr,
    InstancedBufferGeometry: Ng,
    InstancedInterleavedBuffer: ew,
    InstancedMesh: jm,
    Int16BufferAttribute: Gv,
    Int32BufferAttribute: Wv,
    Int8BufferAttribute: kv,
    IntType: tu,
    InterleavedBuffer: Rl,
    InterleavedBufferAttribute: Es,
    Interpolant: Vo,
    InterpolateDiscrete: oo,
    InterpolateLinear: ao,
    InterpolateSmooth: Xa,
    InvertStencilOp: W0,
    KeepStencilOp: fs,
    KeyframeTrack: Vn,
    LOD: Jm,
    LatheGeometry: zo,
    Layers: Sl,
    LessCompare: Sm,
    LessDepth: Yp,
    LessEqualCompare: cu,
    LessEqualDepth: no,
    LessEqualStencilFunc: $0,
    LessStencilFunc: Y0,
    Light: qi,
    LightProbe: Dg,
    Line: ki,
    Line3: rw,
    LineBasicMaterial: Jt,
    LineCurve: wu,
    LineCurve3: og,
    LineDashedMaterial: Mg,
    LineLoop: eg,
    LineSegments: Kn,
    LinearDisplayP3ColorSpace: No,
    LinearFilter: Mt,
    LinearInterpolant: Ru,
    LinearMipMapLinearFilter: N0,
    LinearMipMapNearestFilter: D0,
    LinearMipmapLinearFilter: Xn,
    LinearMipmapNearestFilter: $r,
    LinearSRGBColorSpace: yi,
    LinearToneMapping: Qp,
    LinearTransfer: co,
    Loader: sn,
    LoaderUtils: Oh,
    LoadingManager: Iu,
    LoopOnce: gm,
    LoopPingPong: xm,
    LoopRepeat: vm,
    LuminanceAlphaFormat: fm,
    LuminanceFormat: dm,
    MOUSE: A0,
    Material: Ht,
    MaterialLoader: Wl,
    MathUtils: Sv,
    Matrix3: Fe,
    Matrix4: De,
    MaxEquation: Pp,
    Mesh: ht,
    MeshBasicMaterial: Xi,
    MeshDepthMaterial: gu,
    MeshDistanceMaterial: vu,
    MeshLambertMaterial: _g,
    MeshMatcapMaterial: yg,
    MeshNormalMaterial: xg,
    MeshPhongMaterial: gg,
    MeshPhysicalMaterial: mg,
    MeshStandardMaterial: qt,
    MeshToonMaterial: vg,
    MinEquation: Rp,
    MirroredRepeatWrapping: ro,
    MixOperation: Kp,
    MultiplyBlending: eh,
    MultiplyOperation: Lo,
    NearestFilter: At,
    NearestMipMapLinearFilter: L0,
    NearestMipMapNearestFilter: I0,
    NearestMipmapLinearFilter: Qs,
    NearestMipmapNearestFilter: Qh,
    NeutralToneMapping: rm,
    NeverCompare: bm,
    NeverDepth: Wp,
    NeverStencilFunc: X0,
    NoBlending: di,
    NoColorSpace: ai,
    NoToneMapping: fi,
    NormalAnimationBlendMode: yl,
    NormalBlending: bs,
    NotEqualCompare: Em,
    NotEqualDepth: Jp,
    NotEqualStencilFunc: J0,
    NumberKeyframeTrack: _o,
    Object3D: Qe,
    ObjectLoader: PS,
    ObjectSpaceNormalMap: Mm,
    OctahedronGeometry: Fo,
    OneFactor: Lp,
    OneMinusConstantAlphaFactor: Gp,
    OneMinusConstantColorFactor: Vp,
    OneMinusDstAlphaFactor: Op,
    OneMinusDstColorFactor: Fp,
    OneMinusSrcAlphaFactor: $a,
    OneMinusSrcColorFactor: Np,
    OrthographicCamera: Tl,
    P3Primaries: uo,
    PCFShadowMap: Io,
    PCFSoftShadowMap: xl,
    PMREMGenerator: Ph,
    Path: As,
    PerspectiveCamera: Et,
    Plane: Li,
    PlaneGeometry: Mr,
    PlaneHelper: gw,
    PointLight: Pg,
    PointLightHelper: lw,
    Points: tg,
    PointsMaterial: Mu,
    PolarGridHelper: uw,
    PolyhedronGeometry: Yi,
    PositionalAudio: FS,
    PropertyBinding: Ke,
    PropertyMixer: Fg,
    QuadraticBezierCurve: Tu,
    QuadraticBezierCurve3: Eu,
    Quaternion: en,
    QuaternionKeyframeTrack: wr,
    QuaternionLinearInterpolant: Eg,
    RED_GREEN_RGTC2_Format: Eh,
    RED_RGTC1_Format: mm,
    REVISION: vl,
    RGBADepthPacking: ym,
    RGBAFormat: dn,
    RGBAIntegerFormat: au,
    RGBA_ASTC_10x10_Format: yh,
    RGBA_ASTC_10x5_Format: vh,
    RGBA_ASTC_10x6_Format: xh,
    RGBA_ASTC_10x8_Format: _h,
    RGBA_ASTC_12x10_Format: Mh,
    RGBA_ASTC_12x12_Format: bh,
    RGBA_ASTC_4x4_Format: ch,
    RGBA_ASTC_5x4_Format: hh,
    RGBA_ASTC_5x5_Format: uh,
    RGBA_ASTC_6x5_Format: dh,
    RGBA_ASTC_6x6_Format: fh,
    RGBA_ASTC_8x5_Format: ph,
    RGBA_ASTC_8x6_Format: mh,
    RGBA_ASTC_8x8_Format: gh,
    RGBA_BPTC_Format: Wa,
    RGBA_ETC2_EAC_Format: lh,
    RGBA_PVRTC_2BPPV1_Format: rh,
    RGBA_PVRTC_4BPPV1_Format: sh,
    RGBA_S3TC_DXT1_Format: Va,
    RGBA_S3TC_DXT3_Format: Ha,
    RGBA_S3TC_DXT5_Format: Ga,
    RGBFormat: um,
    RGB_BPTC_SIGNED_Format: Sh,
    RGB_BPTC_UNSIGNED_Format: wh,
    RGB_ETC1_Format: oh,
    RGB_ETC2_Format: ah,
    RGB_PVRTC_2BPPV1_Format: ih,
    RGB_PVRTC_4BPPV1_Format: nh,
    RGB_S3TC_DXT1_Format: ka,
    RGFormat: pm,
    RGIntegerFormat: ou,
    RawShaderMaterial: pg,
    Ray: yr,
    Raycaster: kg,
    Rec709Primaries: ho,
    RectAreaLight: Ig,
    RedFormat: su,
    RedIntegerFormat: ru,
    ReinhardToneMapping: em,
    RenderTarget: Dm,
    RepeatWrapping: so,
    ReplaceStencilOp: B0,
    ReverseSubtractEquation: Cp,
    RingGeometry: Bl,
    SIGNED_RED_GREEN_RGTC2_Format: Ah,
    SIGNED_RED_RGTC1_Format: Th,
    SRGBColorSpace: Mn,
    SRGBTransfer: lt,
    Scene: xu,
    ShaderChunk: Ve,
    ShaderLib: In,
    ShaderMaterial: Fn,
    ShadowMaterial: fg,
    Shape: Pt,
    ShapeGeometry: Bo,
    ShapePath: _w,
    ShapeUtils: qn,
    ShortType: lm,
    Skeleton: Pl,
    SkeletonHelper: aw,
    SkinnedMesh: Km,
    Source: xs,
    Sphere: kt,
    SphereGeometry: ko,
    Spherical: nw,
    SphericalHarmonics3: Lg,
    SplineCurve: Au,
    SpotLight: Rg,
    SpotLightHelper: ow,
    Sprite: Zm,
    SpriteMaterial: _u,
    SrcAlphaFactor: qa,
    SrcAlphaSaturateFactor: Bp,
    SrcColorFactor: Dp,
    StaticCopyUsage: iv,
    StaticDrawUsage: fo,
    StaticReadUsage: ev,
    StereoCamera: NS,
    StreamCopyUsage: rv,
    StreamDrawUsage: Q0,
    StreamReadUsage: nv,
    StringKeyframeTrack: Ps,
    SubtractEquation: Ap,
    SubtractiveBlending: Qc,
    TOUCH: C0,
    TangentSpaceNormalMap: Wi,
    TetrahedronGeometry: kl,
    Texture: gt,
    TextureLoader: ES,
    TorusGeometry: Vl,
    TorusKnotGeometry: Hl,
    Triangle: un,
    TriangleFanDrawMode: z0,
    TriangleStripDrawMode: O0,
    TrianglesDrawMode: U0,
    TubeGeometry: Gl,
    UVMapping: _l,
    Uint16BufferAttribute: du,
    Uint32BufferAttribute: fu,
    Uint8BufferAttribute: Vv,
    Uint8ClampedBufferAttribute: Hv,
    Uniform: zu,
    UniformsGroup: QS,
    UniformsLib: pe,
    UniformsUtils: Om,
    UnsignedByteType: vi,
    UnsignedInt248Type: _r,
    UnsignedInt5999Type: cm,
    UnsignedIntType: Ts,
    UnsignedShort4444Type: nu,
    UnsignedShort5551Type: iu,
    UnsignedShortType: eu,
    VSMShadowMap: Gn,
    Vector2: ee,
    Vector3: P,
    Vector4: rt,
    VectorKeyframeTrack: yo,
    VideoTexture: Bb,
    WebGL3DRenderTarget: Rv,
    WebGLArrayRenderTarget: Cv,
    WebGLCoordinateSystem: Yn,
    WebGLCubeRenderTarget: Fm,
    WebGLMultipleRenderTargets: yw,
    WebGLRenderTarget: zn,
    WebGLRenderer: qm,
    WebGLUtils: Xm,
    WebGPUCoordinateSystem: po,
    WireframeGeometry: dg,
    WrapAroundEnding: lo,
    ZeroCurvatureEnding: gs,
    ZeroFactor: Ip,
    ZeroSlopeEnding: vs,
    ZeroStencilOp: F0,
    createCanvasElement: Pm
  }, Symbol.toStringTag, {
    value: "Module"
  })), Vr = new P();
  function xn(s, e, t, n, i, r) {
    const o = 2 * Math.PI * i / 4, a = Math.max(r - 2 * i, 0), l = Math.PI / 4;
    Vr.copy(e), Vr[n] = 0, Vr.normalize();
    const c = 0.5 * o / (o + a), u = 1 - Vr.angleTo(s) / l;
    return Math.sign(Vr[t]) === 1 ? u * c : a / (o + a) + c + c * (1 - u);
  }
  class bw extends bi {
    constructor(e = 1, t = 1, n = 1, i = 2, r = 0.1) {
      if (i = i * 2 + 1, r = Math.min(e / 2, t / 2, n / 2, r), super(1, 1, 1, i, i, i), i === 1) return;
      const o = this.toNonIndexed();
      this.index = null, this.attributes.position = o.attributes.position, this.attributes.normal = o.attributes.normal, this.attributes.uv = o.attributes.uv;
      const a = new P(), l = new P(), c = new P(e, t, n).divideScalar(2).subScalar(r), u = this.attributes.position.array, d = this.attributes.normal.array, h = this.attributes.uv.array, f = u.length / 6, m = new P(), v = 0.5 / i;
      for (let g = 0, p = 0; g < u.length; g += 3, p += 2) switch (a.fromArray(u, g), l.copy(a), l.x -= Math.sign(l.x) * v, l.y -= Math.sign(l.y) * v, l.z -= Math.sign(l.z) * v, l.normalize(), u[g + 0] = c.x * Math.sign(a.x) + l.x * r, u[g + 1] = c.y * Math.sign(a.y) + l.y * r, u[g + 2] = c.z * Math.sign(a.z) + l.z * r, d[g + 0] = l.x, d[g + 1] = l.y, d[g + 2] = l.z, Math.floor(g / f)) {
        case 0:
          m.set(1, 0, 0), h[p + 0] = xn(m, l, "z", "y", r, n), h[p + 1] = 1 - xn(m, l, "y", "z", r, t);
          break;
        case 1:
          m.set(-1, 0, 0), h[p + 0] = 1 - xn(m, l, "z", "y", r, n), h[p + 1] = 1 - xn(m, l, "y", "z", r, t);
          break;
        case 2:
          m.set(0, 1, 0), h[p + 0] = 1 - xn(m, l, "x", "z", r, e), h[p + 1] = xn(m, l, "z", "x", r, n);
          break;
        case 3:
          m.set(0, -1, 0), h[p + 0] = 1 - xn(m, l, "x", "z", r, e), h[p + 1] = 1 - xn(m, l, "z", "x", r, n);
          break;
        case 4:
          m.set(0, 0, 1), h[p + 0] = 1 - xn(m, l, "x", "y", r, e), h[p + 1] = 1 - xn(m, l, "y", "x", r, t);
          break;
        case 5:
          m.set(0, 0, -1), h[p + 0] = xn(m, l, "x", "y", r, e), h[p + 1] = 1 - xn(m, l, "y", "x", r, t);
          break;
      }
    }
  }
  function zf(s) {
    const e = Math.round(s);
    return Math.abs(s - e) < 0.01 ? e : s;
  }
  function cs(s, e, t, n, i, r) {
    const a = n - t, l = r - i, c = zf(t), u = zf(i), d = c + a, h = u + l;
    return d - u > 1e-3 && h - c > 1e-3;
  }
  class _n {
    constructor(e, t, n, i, r, o, a, l, c, u, d = 0, h = 1) {
      this.length = e, this.gridX = t, this.gridZ = n, this.direction = i, this.isVertical = r, this.isAnimating = false, this.isFalling = false, this.needsTransitionToFalling = false, this.needsStop = false, this.wasCatapulted = false, this._catapultShadowSuppressed = false, this._catapultRestStartMs = 0, this.scene = a, this.physics = l, this.gridSize = c, this.cubeSize = u, this.yOffset = d, this.level = h, this.arrowStyle = o, this.group = new Ln();
      const f = 0.08, m = 4;
      let v, g, p;
      const _ = Math.abs(i.x) > 0;
      this.isVertical ? (v = u, g = e * u, p = u) : _ ? (v = e * u, g = u, p = u) : (v = u, g = u, p = e * u);
      const x = new bw(v, g, p, m, f), b = [
        16739179,
        5164484,
        16770669
      ], w = (typeof window < "u" && window.useColoredBlocksDefault !== void 0 ? window.useColoredBlocksDefault : false) ? b[e - 1] : 16777215, A = b[e - 1], M = new qt({
        color: w,
        roughness: 0.1,
        metalness: 0
      }), y = new ht(x, M);
      y.castShadow = true, y.receiveShadow = true, y.position.set(0, g / 2, 0), this.cubes = [
        y
      ], this.group.add(y), this.originalMaterial = M, this.isHighlighted = false, this.createArrow(o, A), this.createDirectionIndicators(A, o), this.updateWorldPosition(), this.physicsBody = null, this.physicsCollider = null, a.add(this.group);
    }
    createPhysicsBody() {
      let e, t, n;
      this.isVertical ? (e = this.cubeSize, t = this.length * this.cubeSize, n = this.cubeSize) : Math.abs(this.direction.x) > 0 ? (e = this.length * this.cubeSize, t = this.cubeSize, n = this.cubeSize) : (e = this.cubeSize, t = this.cubeSize, n = this.length * this.cubeSize);
      const i = new P();
      this.group.getWorldPosition(i);
      const r = _0(this.physics, {
        x: i.x,
        y: i.y + t / 2,
        z: i.z
      }, {
        x: e,
        y: t,
        z: n
      }, true, true);
      this.physicsBody = r.body, this.physicsCollider = r.collider;
    }
    createArrow(e = 1, t = 16777215) {
      const n = new Ln(), i = (d) => {
        let h, f, m, v;
        if (d === 1) {
          h = new Pt();
          const g = 0.25, p = 0.35, _ = 0.06;
          h.moveTo(0, p), h.lineTo(g, p - g), h.lineTo(g - _, p - g), h.lineTo(0, p - _), h.lineTo(-g + _, p - g), h.lineTo(-g, p - g), h.lineTo(0, p), h.moveTo(_ / 2, p - g), h.lineTo(_ / 2, -p * 0.3), h.lineTo(-_ / 2, -p * 0.3), h.lineTo(-_ / 2, p - g), f = {
            depth: 0.06,
            bevelEnabled: true,
            bevelThickness: 0.02,
            bevelSize: 0.02,
            bevelSegments: 2
          }, m = new ln(h, f), v = new qt({
            color: t,
            emissive: t,
            emissiveIntensity: 0.3,
            roughness: 0.3,
            metalness: 0.6,
            side: Qt
          });
        } else if (d === 2) h = new Pt(), h.moveTo(0, 0.35), h.lineTo(-0.2, 0), h.lineTo(-0.06, 0), h.lineTo(-0.06, -0.25), h.lineTo(0.06, -0.25), h.lineTo(0.06, 0), h.lineTo(0.2, 0), h.lineTo(0, 0.35), f = {
          depth: 0.05,
          bevelEnabled: true,
          bevelThickness: 0.02,
          bevelSize: 0.02,
          bevelSegments: 3
        }, m = new ln(h, f), v = new qt({
          color: t,
          roughness: 0.4,
          metalness: 0.3
        });
        else if (d === 3) {
          h = new Pt();
          const g = 0.05;
          h.moveTo(-g / 2, -0.2), h.lineTo(g / 2, -0.2), h.lineTo(g / 2, 0.1), h.lineTo(-g / 2, 0.1), h.moveTo(0, 0.35), h.lineTo(-0.15, 0.05), h.lineTo(-0.08, 0.05), h.lineTo(0, 0.2), h.lineTo(0.08, 0.05), h.lineTo(0.15, 0.05), h.lineTo(0, 0.35), m = new Bo(h), v = new qt({
            color: t,
            side: Qt
          });
        } else if (d === 4) {
          h = new Pt();
          const g = 0.3, p = 0.22, _ = 0.06;
          h.moveTo(0, g), h.lineTo(-g, -0.05), h.lineTo(-_, -0.05), h.lineTo(-_, -0.25), h.lineTo(_, -0.25), h.lineTo(_, -0.05), h.lineTo(g, -0.05), h.lineTo(0, g);
          const x = new As();
          x.moveTo(0, p), x.lineTo(-p + 0.05, 0.02), x.lineTo(0, 0.12), x.lineTo(p - 0.05, 0.02), x.lineTo(0, p), h.holes.push(x), f = {
            depth: 0.06,
            bevelEnabled: false
          }, m = new ln(h, f), v = new qt({
            color: t
          });
        } else d === 5 ? (h = new Pt(), h.moveTo(0, 0.35), h.lineTo(-0.18, 0.05), h.quadraticCurveTo(-0.18, 0, -0.12, 0), h.lineTo(-0.07, 0), h.lineTo(-0.07, -0.2), h.quadraticCurveTo(-0.07, -0.25, 0, -0.25), h.quadraticCurveTo(0.07, -0.25, 0.07, -0.2), h.lineTo(0.07, 0), h.lineTo(0.12, 0), h.quadraticCurveTo(0.18, 0, 0.18, 0.05), h.lineTo(0, 0.35), f = {
          depth: 0.08,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.03,
          bevelSegments: 5
        }, m = new ln(h, f), v = new qt({
          color: t
        })) : d === 6 ? (h = new Pt(), h.moveTo(0, 0.38), h.lineTo(-0.2, 0.05), h.quadraticCurveTo(-0.2, -0.02, -0.1, -0.02), h.lineTo(-0.09, -0.02), h.lineTo(-0.09, -0.22), h.quadraticCurveTo(-0.09, -0.28, 0, -0.28), h.quadraticCurveTo(0.09, -0.28, 0.09, -0.22), h.lineTo(0.09, -0.02), h.lineTo(0.1, -0.02), h.quadraticCurveTo(0.2, -0.02, 0.2, 0.05), h.lineTo(0, 0.38), f = {
          depth: 0.09,
          bevelEnabled: true,
          bevelThickness: 0.035,
          bevelSize: 0.035,
          bevelSegments: 4
        }, m = new ln(h, f), v = new qt({
          color: t
        })) : d === 7 ? (h = new Pt(), h.moveTo(0, 0.36), h.lineTo(-0.22, -0.02), h.lineTo(-0.11, -0.02), h.lineTo(-0.11, -0.06), h.lineTo(-0.08, -0.06), h.lineTo(-0.08, -0.24), h.quadraticCurveTo(-0.08, -0.27, 0, -0.27), h.quadraticCurveTo(0.08, -0.27, 0.08, -0.24), h.lineTo(0.08, -0.06), h.lineTo(0.11, -0.06), h.lineTo(0.11, -0.02), h.lineTo(0.22, -0.02), h.lineTo(0, 0.36), f = {
          depth: 0.08,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.03,
          bevelSegments: 3
        }, m = new ln(h, f), v = new qt({
          color: t
        })) : d === 8 && (h = new Pt(), h.moveTo(0, 0.4), h.lineTo(-0.24, 0.02), h.lineTo(-0.1, 0.02), h.lineTo(-0.1, -0.24), h.lineTo(0.1, -0.24), h.lineTo(0.1, 0.02), h.lineTo(0.24, 0.02), h.lineTo(0, 0.4), f = {
          depth: 0.08,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.03,
          bevelSegments: 2
        }, m = new ln(h, f), v = new qt({
          color: t
        }));
        return {
          geometry: m,
          material: v
        };
      }, r = Math.abs(this.direction.x) > 0, o = (this.length - 1) * this.cubeSize / 2;
      let a = 0;
      e === 1 ? a = 0.1225 : e === 2 ? a = 0.05 : e === 3 ? a = 0.075 : e === 4 ? a = 0.025 : e === 5 || e === 6 ? a = 0.05 : e === 7 ? a = 0.045 : e === 8 && (a = 0.08);
      const l = new Ln(), c = i(e), u = new ht(c.geometry, c.material);
      u.material.emissive && (u.material._originalEmissiveIntensity = u.material.emissiveIntensity !== void 0 ? u.material.emissiveIntensity : 0), u.castShadow = false, u.receiveShadow = true, e === 1 ? u.position.z = -0.015 : e === 2 ? u.position.z = -0.0125 : e === 4 ? u.position.z = -0.015 : e === 5 ? u.position.z = -0.025 : e === 6 ? u.position.z = -0.03 : e === 7 ? u.position.z = -0.025 : e === 8 && (u.position.z = -0.0275), u.position.y = -a, l.add(u), this.isVertical ? l.position.set(0, this.length * this.cubeSize + 0.02, 0) : r ? l.position.set(o, this.cubeSize + 0.02, 0) : l.position.set(0, this.cubeSize + 0.02, o), l.rotation.x = -Math.PI / 2, l.rotation.z = Math.atan2(this.direction.x, this.direction.z) + Math.PI, n.add(l), this.group.add(n), this.arrow = n;
    }
    createDirectionIndicators(e, t = 2) {
      const n = new Ln();
      let i, r, o;
      const a = Math.abs(this.direction.x) > 0;
      this.isVertical ? (i = this.cubeSize, r = this.length * this.cubeSize, o = this.cubeSize) : a ? (i = this.length * this.cubeSize, r = this.cubeSize, o = this.cubeSize) : (i = this.cubeSize, r = this.cubeSize, o = this.length * this.cubeSize);
      const l = 0.03, c = e, u = 0.2, d = new Pt();
      d.arc(0, 0, u, 0, Math.PI * 2, false);
      let h;
      t === 1 ? h = {
        depth: 0.06,
        bevelEnabled: true,
        bevelThickness: 0.02,
        bevelSize: 0.02,
        bevelSegments: 2
      } : t === 2 ? h = {
        depth: 0.05,
        bevelEnabled: true,
        bevelThickness: 0.02,
        bevelSize: 0.02,
        bevelSegments: 3
      } : t === 3 ? h = {
        depth: 0.05,
        bevelEnabled: false
      } : t === 4 ? h = {
        depth: 0.06,
        bevelEnabled: false
      } : t === 5 ? h = {
        depth: 0.08,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.03,
        bevelSegments: 5
      } : t === 6 ? h = {
        depth: 0.09,
        bevelEnabled: true,
        bevelThickness: 0.035,
        bevelSize: 0.035,
        bevelSegments: 4
      } : t === 7 ? h = {
        depth: 0.08,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.03,
        bevelSegments: 3
      } : t === 8 ? h = {
        depth: 0.08,
        bevelEnabled: true,
        bevelThickness: 0.03,
        bevelSize: 0.03,
        bevelSegments: 2
      } : h = {
        depth: 0.05,
        bevelEnabled: true,
        bevelThickness: 0.02,
        bevelSize: 0.02,
        bevelSegments: 3
      };
      const f = new ln(d, h), m = new qt({
        color: c,
        side: Qt
      }), v = new ht(f, m);
      v.castShadow = false, v.receiveShadow = true;
      const g = 0.01, p = 0.25, _ = new Pt();
      _.arc(0, 0, p, 0, Math.PI * 2, false);
      const x = new As();
      x.arc(0, 0, p - 0.06, 0, Math.PI * 2, true), _.holes.push(x);
      const E = h, S = new ln(_, E), w = new qt({
        color: c,
        side: Qt
      }), A = new ht(S, w);
      A.castShadow = false, A.receiveShadow = true, A.position.z = g, this.isVertical ? (this.direction.x > 0 ? (v.position.set(i / 2 + l, r / 2, 0), v.rotation.set(0, -Math.PI / 2, 0)) : this.direction.x < 0 ? (v.position.set(-i / 2 - l, r / 2, 0), v.rotation.set(0, Math.PI / 2, 0)) : this.direction.z > 0 ? (v.position.set(0, r / 2, o / 2 + l), v.rotation.set(0, Math.PI, 0)) : this.direction.z < 0 && (v.position.set(0, r / 2, -o / 2 - l), v.rotation.set(0, 0, 0)), this.direction.x > 0 ? (A.position.set(-i / 2 - l, r / 2, 0), A.rotation.set(0, Math.PI / 2, 0)) : this.direction.x < 0 ? (A.position.set(i / 2 + l, r / 2, 0), A.rotation.set(0, -Math.PI / 2, 0)) : this.direction.z > 0 ? (A.position.set(0, r / 2, -o / 2 - l), A.rotation.set(0, 0, 0)) : this.direction.z < 0 && (A.position.set(0, r / 2, o / 2 + l), A.rotation.set(0, Math.PI, 0))) : a ? this.direction.x > 0 ? (v.position.set(i / 2 + l, r / 2, 0), v.rotation.set(0, -Math.PI / 2, 0), A.position.set(-i / 2 - l, r / 2, 0), A.rotation.set(0, Math.PI / 2, 0)) : (v.position.set(-i / 2 - l, r / 2, 0), v.rotation.set(0, Math.PI / 2, 0), A.position.set(i / 2 + l, r / 2, 0), A.rotation.set(0, -Math.PI / 2, 0)) : this.direction.z > 0 ? (v.position.set(0, r / 2, o / 2 + l), v.rotation.set(0, Math.PI, 0), A.position.set(0, r / 2, -o / 2 - l), A.rotation.set(0, 0, 0)) : (v.position.set(0, r / 2, -o / 2 - l), v.rotation.set(0, 0, 0), A.position.set(0, r / 2, o / 2 + l), A.rotation.set(0, Math.PI, 0)), n.add(v), n.add(A), this.group.add(n), this.directionIndicators = n, typeof window < "u" && window.location.hostname !== "localhost" && console.log("Direction indicators created:", {
        dotMesh: !!v,
        circleMesh: !!A,
        indicatorsGroup: n.children.length
      });
    }
    updateBlockColor(e, t = null) {
      this.originalMaterial && (this.originalMaterial.color.setHex(e), this.originalMaterial.roughness = 0.1, this.originalMaterial.metalness = 0);
      const n = [
        16739179,
        5164484,
        16770669
      ], i = n[this.length - 1] || n[0];
      if (this.arrow && this.arrow.children.length > 0) {
        const o = this.arrow.children[0];
        if (o && o.children && o.children.length > 0) {
          const a = o.children[0];
          a && a.material && a.material.color.setHex(i);
        }
      }
      const r = i;
      if (this.directionIndicators && this.directionIndicators.children.length >= 2) {
        const o = this.directionIndicators.children[0], a = this.directionIndicators.children[1];
        o && o.material && o.material.color.setHex(r), a && a.material && a.material.color.setHex(r);
      }
    }
    rotateDirectionClockwise() {
      const e = -this.direction.z, t = this.direction.x;
      this.direction = {
        x: e,
        z: t
      }, this.updateArrowRotation();
    }
    animateRotationClockwise(e = 400, t = null) {
      if (!this.arrow || !this.arrow.children.length > 0) {
        this.rotateDirectionClockwise(), t && t();
        return;
      }
      const n = this.arrow.children[0];
      if (!n) {
        this.rotateDirectionClockwise(), t && t();
        return;
      }
      const i = Math.atan2(this.direction.x, this.direction.z) + Math.PI, r = -this.direction.z, o = this.direction.x, a = Math.atan2(r, o) + Math.PI;
      this.direction = {
        x: r,
        z: o
      };
      const l = performance.now(), c = () => {
        const u = performance.now() - l, d = Math.min(u / e, 1), h = d < 0.5 ? 2 * d * d : 1 - Math.pow(-2 * d + 2, 2) / 2, f = i + (a - i) * h;
        n.rotation.z = f, d < 1 ? requestAnimationFrame(c) : (n.rotation.z = a, t && t());
      };
      c();
    }
    updateArrowRotation() {
      if (this.arrow && this.arrow.children.length > 0) {
        const e = this.arrow.children[0];
        e && (e.rotation.z = Math.atan2(this.direction.x, this.direction.z) + Math.PI);
      }
      if (this.directionIndicators) {
        this.group.remove(this.directionIndicators);
        const e = [
          16739179,
          5164484,
          16770669
        ], t = e[this.length - 1] || e[0];
        this.createDirectionIndicators(t, this.arrowStyle);
      }
    }
    animateRandomSpin(e = 1800, t = null) {
      const n = !this.isVertical && this.length > 1;
      if (!this.isVertical && this.length !== 1 && !n) {
        t && t();
        return;
      }
      if (!this.arrow || !this.arrow.children.length > 0) {
        let _;
        if (n) _ = {
          x: -this.direction.x,
          z: -this.direction.z
        };
        else {
          const x = [
            {
              x: 1,
              z: 0
            },
            {
              x: -1,
              z: 0
            },
            {
              x: 0,
              z: 1
            },
            {
              x: 0,
              z: -1
            }
          ];
          _ = x[Math.floor(Math.random() * x.length)];
        }
        this.direction = _, this.updateArrowRotation(), t && t();
        return;
      }
      const i = this.arrow.children[0];
      if (!i) {
        let _;
        if (n) _ = {
          x: -this.direction.x,
          z: -this.direction.z
        };
        else {
          const x = [
            {
              x: 1,
              z: 0
            },
            {
              x: -1,
              z: 0
            },
            {
              x: 0,
              z: 1
            },
            {
              x: 0,
              z: -1
            }
          ];
          _ = x[Math.floor(Math.random() * x.length)];
        }
        this.direction = _, this.updateArrowRotation(), t && t();
        return;
      }
      let r;
      if (n) r = {
        x: -this.direction.x,
        z: -this.direction.z
      };
      else {
        const _ = [
          {
            x: 1,
            z: 0
          },
          {
            x: -1,
            z: 0
          },
          {
            x: 0,
            z: 1
          },
          {
            x: 0,
            z: -1
          }
        ];
        r = _[Math.floor(Math.random() * _.length)];
      }
      const o = Math.atan2(this.direction.x, this.direction.z) + Math.PI, a = Math.atan2(r.x, r.z) + Math.PI, c = (2 + Math.random() * 2) * Math.PI * 2;
      let u = a - o;
      for (; u > Math.PI; ) u -= Math.PI * 2;
      for (; u < -Math.PI; ) u += Math.PI * 2;
      n && (u = Math.PI);
      const d = u >= 0 ? 1 : -1, h = o + d * c + u, f = a + Math.round((h - a) / (Math.PI * 2)) * Math.PI * 2;
      this.direction = {
        x: r.x,
        z: r.z
      };
      const m = performance.now(), v = e * 0.7, g = e * 0.3, p = () => {
        const _ = performance.now() - m, x = Math.min(_ / v, 1);
        if (x < 1) {
          const b = 1 - Math.pow(1 - x, 3), E = o + (f - o) * b;
          i.rotation.z = E, requestAnimationFrame(p);
        } else {
          i.rotation.z = f;
          const b = performance.now(), E = Math.PI / 10, S = 3, w = () => {
            const A = performance.now() - b, M = Math.min(A / g, 1);
            if (M < 1) {
              const C = 1 - (1 - Math.pow(1 - M, 3)), N = 0.5 + M * 0.5, I = Math.sin(M * Math.PI * S * 2 * N) * E * C;
              i.rotation.z = f + I, requestAnimationFrame(w);
            } else i.rotation.z = a, this.updateArrowRotation(), t && t();
          };
          w();
        }
      };
      p();
    }
    canRotateSafelyAtWithDirection(e, t, n, i, r, o, a = null) {
      const l = e + i.x, c = t + i.z;
      if (this.isVertical) {
        if (l < 0 || l >= o || c < 0 || c >= o) return true;
        for (const u of r) {
          if (u === this || u === a || u.isFalling || u.isRemoved || u.removalStartTime) continue;
          const d = this.isVertical ? this.length * this.cubeSize : this.cubeSize, h = this.yOffset, f = this.yOffset + d, m = u.isVertical ? u.length * u.cubeSize : u.cubeSize, v = u.yOffset, g = u.yOffset + m;
          if (cs(this, u, h, f, v, g)) if (u.isVertical) {
            if (l === u.gridX && c === u.gridZ) return false;
          } else {
            const _ = Math.abs(u.direction.x) > 0;
            for (let x = 0; x < u.length; x++) {
              const b = u.gridX + (_ ? x : 0), E = u.gridZ + (_ ? 0 : x);
              if (l === b && c === E) return false;
            }
          }
        }
        return true;
      } else {
        const u = Math.abs(i.x) > 0;
        for (let d = 0; d < this.length; d++) {
          const h = l + (u ? d : 0), f = c + (u ? 0 : d);
          if (h < 0 || h >= o || f < 0 || f >= o) return true;
          for (const m of r) {
            if (m === this || m === a || m.isFalling || m.isRemoved || m.removalStartTime) continue;
            const v = this.isVertical ? this.length * this.cubeSize : this.cubeSize, g = this.yOffset, p = this.yOffset + v, _ = m.isVertical ? m.length * m.cubeSize : m.cubeSize, x = m.yOffset, b = m.yOffset + _;
            if (cs(this, m, g, p, x, b)) if (m.isVertical) {
              if (h === m.gridX && f === m.gridZ) return false;
            } else {
              const S = Math.abs(m.direction.x) > 0;
              for (let w = 0; w < m.length; w++) {
                const A = m.gridX + (S ? w : 0), M = m.gridZ + (S ? 0 : w);
                if (h === A && f === M) return false;
              }
            }
          }
        }
        return true;
      }
    }
    canRotateSafelyAt(e, t, n, i, r = null) {
      const o = {
        x: -this.direction.z,
        z: this.direction.x
      };
      if (this.isVertical) {
        const a = e + o.x, l = t + o.z;
        if (a < 0 || a >= i || l < 0 || l >= i) return true;
        for (const c of n) {
          if (c === this || c === r || c.isFalling || c.isRemoved || c.removalStartTime) continue;
          const u = this.isVertical ? this.length * this.cubeSize : this.cubeSize, d = this.yOffset, h = this.yOffset + u, f = c.isVertical ? c.length * c.cubeSize : c.cubeSize, m = c.yOffset, v = c.yOffset + f;
          if (cs(this, c, d, h, m, v)) if (c.isVertical) {
            if (a === c.gridX && l === c.gridZ) return false;
          } else {
            const p = Math.abs(c.direction.x) > 0;
            for (let _ = 0; _ < c.length; _++) {
              const x = c.gridX + (p ? _ : 0), b = c.gridZ + (p ? 0 : _);
              if (a === x && l === b) return false;
            }
          }
        }
        return true;
      } else {
        const a = e + o.x, l = t + o.z, c = Math.abs(o.x) > 0;
        for (let u = 0; u < this.length; u++) {
          const d = a + (c ? u : 0), h = l + (c ? 0 : u);
          if (d < 0 || d >= i || h < 0 || h >= i) return true;
          for (const f of n) {
            if (f === this || f === r || f.isFalling || f.isRemoved || f.removalStartTime) continue;
            const m = this.isVertical ? this.length * this.cubeSize : this.cubeSize, v = this.yOffset, g = this.yOffset + m, p = f.isVertical ? f.length * f.cubeSize : f.cubeSize, _ = f.yOffset, x = f.yOffset + p;
            if (cs(this, f, v, g, _, x)) if (f.isVertical) {
              if (d === f.gridX && h === f.gridZ) return false;
            } else {
              const E = Math.abs(f.direction.x) > 0;
              for (let S = 0; S < f.length; S++) {
                const w = f.gridX + (E ? S : 0), A = f.gridZ + (E ? 0 : S);
                if (d === w && h === A) return false;
              }
            }
          }
        }
        return true;
      }
    }
    updateWorldPosition() {
      let e, t;
      if (this.isVertical) e = this.gridX * this.cubeSize + this.cubeSize / 2, t = this.gridZ * this.cubeSize + this.cubeSize / 2;
      else if (Math.abs(this.direction.x) > 0) {
        const r = this.gridX * this.cubeSize + this.cubeSize / 2, o = (this.gridX + this.length - 1) * this.cubeSize + this.cubeSize / 2;
        e = (r + o) / 2, t = this.gridZ * this.cubeSize + this.cubeSize / 2;
      } else {
        e = this.gridX * this.cubeSize + this.cubeSize / 2;
        const r = this.gridZ * this.cubeSize + this.cubeSize / 2, o = (this.gridZ + this.length - 1) * this.cubeSize + this.cubeSize / 2;
        t = (r + o) / 2;
      }
      const n = this.gridSize * this.cubeSize / 2;
      this.group.position.set(e - n, this.yOffset, t - n);
    }
    updateFromPhysics() {
      if (this.isFalling && !this.isRemoved) {
        if (this.needsPhysicsBody && !this.physicsBody) {
          b0(() => {
            if (this.createPhysicsBody(), this.needsPhysicsBody = false, this.physicsBody && this.pendingAngularVel) {
              const e = this.physics.RAPIER;
              this.physicsBody.setAngvel(new e.Vector3(this.pendingAngularVel.x, this.pendingAngularVel.y, this.pendingAngularVel.z), true), this.physicsBody.setEnabledRotations(true, true, true, true), this.pendingLinearVel && this.physicsBody.setLinvel(new e.Vector3(this.pendingLinearVel.x, this.pendingLinearVel.y, this.pendingLinearVel.z), true), this.pendingAngularVel = null, this.pendingLinearVel = null;
            }
          });
          return;
        }
        if (this.physicsBody && !ds()) try {
          if (!this.physicsBody || ds()) return;
          let e, t, n, i, r, o, a, l = 0, c = 0, u = 0, d = 0, h = 0, f = 0, m = false;
          try {
            if (ds()) return;
            const E = this.physicsBody.translation();
            if (!E) return;
            e = E.x, t = E.y, n = E.z, m = true;
          } catch {
            return;
          }
          try {
            if (ds()) return;
            const E = this.physicsBody.rotation();
            if (!E) return;
            i = E.x, r = E.y, o = E.z, a = E.w;
          } catch {
            i = 0, r = 0, o = 0, a = 1;
          }
          try {
            if (!ds()) {
              const E = this.physicsBody.linvel();
              E && (l = E.x, c = E.y, u = E.z);
            }
          } catch {
          }
          try {
            if (!ds()) {
              const E = this.physicsBody.angvel();
              E && (d = E.x, h = E.y, f = E.z);
            }
          } catch {
          }
          if (!m) return;
          const v = this.isVertical ? this.length * this.cubeSize : this.cubeSize, g = this.gridSize * this.cubeSize / 2;
          this.group.position.set(e - g, t - v / 2, n - g), this.group.quaternion.set(i, r, o, a);
          try {
            if (this.wasCatapulted && this.cubes && this.cubes[0]) {
              const E = Math.sqrt(l * l + c * c + u * u), S = Math.sqrt(d * d + h * h + f * f), w = E > 0.06 || S > 0.06, A = performance.now();
              w ? (this._catapultRestStartMs = 0, this._catapultShadowSuppressed || (this.cubes[0].castShadow = false, this.cubes[0].receiveShadow = false, this._catapultShadowSuppressed = true)) : (this._catapultRestStartMs || (this._catapultRestStartMs = A), this._catapultShadowSuppressed && A - this._catapultRestStartMs > 250 && (this.cubes[0].castShadow = true, this.cubes[0].receiveShadow = true, this._catapultShadowSuppressed = false));
            }
          } catch {
          }
          const p = this.gridSize * this.cubeSize / 2, _ = this.gridSize * this.cubeSize * 1.5, x = Math.sqrt(Math.pow(e - p, 2) + Math.pow(n - p, 2));
          (t < -2 || x > _ || Date.now() - this.fallingStartTime > 5e3) && !this.isRemoved && (console.log(`Removing block: y=${t.toFixed(2)}, distance=${x.toFixed(2)}, maxDist=${_.toFixed(2)}, time=${Date.now() - this.fallingStartTime}ms`), this.remove()), this.needsTransitionToFalling && this.physicsBody && (this.needsTransitionToFalling = false, y0(() => {
            if (this.physicsBody) {
              this.physicsBody.setEnabledRotations(true, true, true, true);
              const E = Math.abs(this.direction.x) > 0, S = E ? this.direction.x : this.direction.z;
              let w = 0, A = 0, M = 0;
              this.isVertical ? (E ? (M = S * 3.5, w = (Math.random() - 0.5) * 2.5) : (w = -S * 3.5, M = (Math.random() - 0.5) * 2.5), A = (Math.random() - 0.5) * 1.5) : E ? (M = S * 4.5, A = (Math.random() - 0.5) * 2, w = (Math.random() - 0.5) * 1.5) : (w = -S * 4.5, A = (Math.random() - 0.5) * 2, M = (Math.random() - 0.5) * 1.5), this.physicsBody.setAngvel(new this.physics.RAPIER.Vector3(w, A, M), true);
            }
          }));
        } catch (e) {
          console.warn("Failed to update physics:", e);
        }
      }
    }
    canMove(e) {
      const t = this.gridX + this.direction.x, n = this.gridZ + this.direction.z;
      if (window.debugMoveMode && (window.debugMoveInfo = {
        block: {
          gridX: this.gridX,
          gridZ: this.gridZ,
          yOffset: this.yOffset,
          isVertical: this.isVertical,
          length: this.length,
          direction: {
            ...this.direction
          }
        },
        targetPos: {
          x: t,
          z: n
        },
        blockers: [],
        yRangeChecks: []
      }), this.isVertical) {
        if (t < 0 || t >= this.gridSize || n < 0 || n >= this.gridSize) return window.debugMoveMode && (window.debugMoveInfo.result = "fall", window.debugMoveInfo.reason = `Out of bounds: (${t}, ${n})`), "fall";
        const r = this.isVertical ? this.length * this.cubeSize : this.cubeSize, o = this.yOffset, a = this.yOffset + r;
        for (const l of e) {
          if (l === this || l.isFalling || l.isRemoved || l.removalStartTime) continue;
          const c = l.isVertical ? l.length * l.cubeSize : l.cubeSize, u = l.yOffset, d = l.yOffset + c, h = cs(this, l, o, a, u, d);
          if (window.debugMoveMode) {
            const f = t === l.gridX && n === l.gridZ;
            (f || h) && window.debugMoveInfo.yRangeChecks.push({
              other: {
                gridX: l.gridX,
                gridZ: l.gridZ,
                yOffset: l.yOffset,
                isVertical: l.isVertical,
                length: l.length
              },
              thisYRange: {
                bottom: o,
                top: a,
                height: r
              },
              otherYRange: {
                bottom: u,
                top: d,
                height: c
              },
              overlaps: h,
              atTargetPosition: f
            });
          }
          if (h) if (l.isVertical) {
            if (t === l.gridX && n === l.gridZ) {
              const f = this.length === 1 || this.isVertical, m = !this.isVertical && this.length > 1;
              if ((f || m) && this.direction.x === -l.direction.x && this.direction.z === -l.direction.z) {
                window.debugMoveMode && window.debugMoveInfo.blockers.push({
                  block: {
                    gridX: l.gridX,
                    gridZ: l.gridZ,
                    yOffset: l.yOffset
                  },
                  reason: "Head-on collision (allowed)",
                  isHeadOn: true
                });
                continue;
              }
              return window.debugMoveMode && (window.debugMoveInfo.result = "blocked", window.debugMoveInfo.blockers.push({
                block: {
                  gridX: l.gridX,
                  gridZ: l.gridZ,
                  yOffset: l.yOffset,
                  isVertical: l.isVertical,
                  length: l.length,
                  direction: {
                    ...l.direction
                  }
                },
                reason: "Vertical block at same position",
                isHeadOn: false
              })), "blocked";
            }
          } else {
            const f = Math.abs(l.direction.x) > 0;
            for (let m = 0; m < l.length; m++) {
              let v = l.gridX, g = l.gridZ;
              if (f ? v += m : g += m, t === v && n === g) {
                if ((this.length === 1 || this.isVertical) && this.direction.x === -l.direction.x && this.direction.z === -l.direction.z) {
                  window.debugMoveMode && window.debugMoveInfo.blockers.push({
                    block: {
                      gridX: l.gridX,
                      gridZ: l.gridZ,
                      yOffset: l.yOffset,
                      length: l.length,
                      direction: {
                        ...l.direction
                      }
                    },
                    reason: "Head-on collision (allowed)",
                    isHeadOn: true
                  });
                  continue;
                }
                return window.debugMoveMode && (window.debugMoveInfo.result = "blocked", window.debugMoveInfo.blockers.push({
                  block: {
                    gridX: l.gridX,
                    gridZ: l.gridZ,
                    yOffset: l.yOffset,
                    isVertical: l.isVertical,
                    length: l.length,
                    direction: {
                      ...l.direction
                    }
                  },
                  cell: {
                    x: v,
                    z: g
                  },
                  reason: "Horizontal block occupies target cell",
                  isHeadOn: false
                })), "blocked";
              }
            }
          }
        }
        return window.debugMoveMode && (window.debugMoveInfo.result = "ok"), "ok";
      }
      const i = Math.abs(this.direction.x) > 0;
      for (let r = 0; r < this.length; r++) {
        let o = t, a = n;
        if (i ? o += r : a += r, o < 0 || o >= this.gridSize || a < 0 || a >= this.gridSize) return window.debugMoveMode && (window.debugMoveInfo.result = "fall", window.debugMoveInfo.reason = `Out of bounds: cell ${r} at (${o}, ${a})`), "fall";
        const l = this.isVertical ? this.length * this.cubeSize : this.cubeSize, c = this.yOffset, u = this.yOffset + l;
        for (const d of e) {
          if (d === this || d.isFalling || d.isRemoved || d.removalStartTime) continue;
          const h = d.isVertical ? d.length * d.cubeSize : d.cubeSize, f = d.yOffset, m = d.yOffset + h, v = cs(this, d, c, u, f, m);
          if (window.debugMoveMode && r === 0 && window.debugMoveInfo.yRangeChecks.push({
            other: {
              gridX: d.gridX,
              gridZ: d.gridZ,
              yOffset: d.yOffset,
              isVertical: d.isVertical,
              length: d.length
            },
            thisYRange: {
              bottom: c,
              top: u,
              height: l
            },
            otherYRange: {
              bottom: f,
              top: m,
              height: h
            },
            overlaps: v,
            cellIndex: r,
            checkCell: {
              x: o,
              z: a
            }
          }), !!v) if (d.isVertical) {
            if (o === d.gridX && a === d.gridZ) {
              const g = this.length === 1 || this.isVertical, p = !this.isVertical && this.length > 1;
              if ((g || p) && this.direction.x === -d.direction.x && this.direction.z === -d.direction.z) {
                window.debugMoveMode && window.debugMoveInfo.blockers.push({
                  block: {
                    gridX: d.gridX,
                    gridZ: d.gridZ,
                    yOffset: d.yOffset
                  },
                  cell: {
                    x: o,
                    z: a,
                    index: r
                  },
                  reason: "Head-on collision (allowed)",
                  isHeadOn: true
                });
                continue;
              }
              return window.debugMoveMode && (window.debugMoveInfo.result = "blocked", window.debugMoveInfo.blockers.push({
                block: {
                  gridX: d.gridX,
                  gridZ: d.gridZ,
                  yOffset: d.yOffset,
                  isVertical: d.isVertical,
                  length: d.length,
                  direction: {
                    ...d.direction
                  }
                },
                cell: {
                  x: o,
                  z: a,
                  index: r
                },
                reason: "Vertical block at cell position",
                isHeadOn: false
              })), "blocked";
            }
          } else {
            const g = Math.abs(d.direction.x) > 0;
            for (let p = 0; p < d.length; p++) {
              let _ = d.gridX, x = d.gridZ;
              if (g ? _ += p : x += p, o === _ && a === x) {
                const b = this.length === 1 || this.isVertical, E = !this.isVertical && this.length > 1;
                if ((b || E) && this.direction.x === -d.direction.x && this.direction.z === -d.direction.z) {
                  window.debugMoveMode && window.debugMoveInfo.blockers.push({
                    block: {
                      gridX: d.gridX,
                      gridZ: d.gridZ,
                      yOffset: d.yOffset,
                      length: d.length,
                      direction: {
                        ...d.direction
                      }
                    },
                    cell: {
                      x: o,
                      z: a,
                      index: r
                    },
                    reason: "Head-on collision (allowed)",
                    isHeadOn: true
                  });
                  continue;
                }
                return window.debugMoveMode && (window.debugMoveInfo.result = "blocked", window.debugMoveInfo.blockers.push({
                  block: {
                    gridX: d.gridX,
                    gridZ: d.gridZ,
                    yOffset: d.yOffset,
                    isVertical: d.isVertical,
                    length: d.length,
                    direction: {
                      ...d.direction
                    }
                  },
                  cell: {
                    x: o,
                    z: a,
                    index: r
                  },
                  reason: "Horizontal block occupies cell",
                  isHeadOn: false
                })), "blocked";
              }
            }
          }
        }
      }
      return window.debugMoveMode && (window.debugMoveInfo.result = "ok"), "ok";
    }
    move(e, t) {
      if (this.isAnimating || this.isFalling) return;
      const n = {
        gridX: this.gridX,
        gridZ: this.gridZ,
        yOffset: this.yOffset,
        direction: {
          ...this.direction
        },
        isVertical: this.isVertical
      };
      let i = 0, r = this.gridX, o = this.gridZ, a = false, l = false, c = null, u = null, d = 0;
      const h = 10;
      for (; ; ) {
        const z = r + this.direction.x, B = o + this.direction.z;
        let U = false;
        if (this.isVertical) (z < 0 || z >= t || B < 0 || B >= t) && (U = true);
        else {
          const V = Math.abs(this.direction.x) > 0;
          for (let K = 0; K < this.length; K++) {
            const ce = z + (V ? K : 0), Te = B + (V ? 0 : K);
            if (ce < 0 || ce >= t || Te < 0 || Te >= t) {
              U = true;
              break;
            }
          }
        }
        if (U) {
          l = true, r = z, o = B, i++;
          break;
        }
        let G = false;
        for (const V of e) {
          if (V === this || V.isFalling || V.isRemoved || V.removalStartTime) continue;
          const K = this.isVertical ? this.length * this.cubeSize : this.cubeSize, ce = this.yOffset, Te = this.yOffset + K, q = V.isVertical ? V.length * V.cubeSize : V.cubeSize, te = V.yOffset, de = V.yOffset + q;
          if (cs(this, V, ce, Te, te, de)) {
            if (this.isVertical) if (V.isVertical) z === V.gridX && B === V.gridZ && (G = true, c = V);
            else {
              const fe = Math.abs(V.direction.x) > 0;
              for (let be = 0; be < V.length; be++) {
                const F = V.gridX + (fe ? be : 0), Le = V.gridZ + (fe ? 0 : be);
                if (z === F && B === Le) {
                  G = true, c = V;
                  break;
                }
              }
            }
            else {
              const fe = Math.abs(this.direction.x) > 0;
              for (let be = 0; be < this.length; be++) {
                const F = z + (fe ? be : 0), Le = B + (fe ? 0 : be);
                if (V.isVertical) {
                  if (F === V.gridX && Le === V.gridZ) {
                    G = true, c = V;
                    break;
                  }
                } else {
                  const J = Math.abs(V.direction.x) > 0;
                  for (let ie = 0; ie < V.length; ie++) {
                    const Z = V.gridX + (J ? ie : 0), le = V.gridZ + (J ? 0 : ie);
                    if (F === Z && Le === le) {
                      G = true, c = V;
                      break;
                    }
                  }
                }
                if (G) break;
              }
            }
            if (G) break;
          }
        }
        if (G) {
          const V = this.length === 1 || this.isVertical, K = !this.isVertical && this.length > 1;
          if ((V || K) && c && this.direction.x === -c.direction.x && this.direction.z === -c.direction.z) {
            if (d++, d > h) {
              console.warn(`Block at (${this.gridX}, ${this.gridZ}) hit maximum head-on collisions (${h}), stopping movement`), a = true;
              break;
            }
            u = {
              block: c,
              gridX: r,
              gridZ: o,
              originalDirection: {
                x: this.direction.x,
                z: this.direction.z
              },
              stepsToCollision: i,
              originalYOffset: this.yOffset
            }, this.gridX = r, this.gridZ = o, K ? (this.direction = {
              x: -this.direction.x,
              z: -this.direction.z
            }, this.updateArrowRotation()) : this.rotateDirectionClockwise();
            const Te = Math.max(0, this.yOffset - this.cubeSize), q = this.isVertical ? this.length * this.cubeSize : this.cubeSize, te = Te, de = Te + q;
            let oe = false;
            for (const fe of e) {
              if (fe === this || fe === c || fe.isFalling || fe.isRemoved || fe.removalStartTime) continue;
              if (fe.isVertical ? fe.gridX === r && fe.gridZ === o : (() => {
                const F = Math.abs(fe.direction.x) > 0;
                for (let Le = 0; Le < fe.length; Le++) {
                  const J = fe.gridX + (F ? Le : 0), ie = fe.gridZ + (F ? 0 : Le);
                  if (J === r && ie === o) return true;
                }
                return false;
              })()) {
                const F = fe.isVertical ? fe.length * fe.cubeSize : fe.cubeSize, Le = fe.yOffset, J = fe.yOffset + F;
                if (de > Le && te < J) {
                  oe = true;
                  break;
                }
              }
            }
            if (!oe) this.yOffset = Te;
            else {
              let fe = this.yOffset;
              for (let be = 1; be <= 5; be++) {
                const F = Math.max(0, this.yOffset - be * this.cubeSize), Le = F, J = F + q;
                let ie = false;
                for (const Z of e) {
                  if (Z === this || Z === c || Z.isFalling || Z.isRemoved || Z.removalStartTime) continue;
                  if (Z.isVertical ? Z.gridX === r && Z.gridZ === o : (() => {
                    const se = Math.abs(Z.direction.x) > 0;
                    for (let ve = 0; ve < Z.length; ve++) {
                      const Ce = Z.gridX + (se ? ve : 0), L = Z.gridZ + (se ? 0 : ve);
                      if (Ce === r && L === o) return true;
                    }
                    return false;
                  })()) {
                    const se = Z.isVertical ? Z.length * Z.cubeSize : Z.cubeSize, ve = Z.yOffset, Ce = Z.yOffset + se;
                    if (J > ve && Le < Ce) {
                      ie = true;
                      break;
                    }
                  }
                }
                if (!ie) {
                  fe = F;
                  break;
                }
              }
              this.yOffset = fe;
            }
            continue;
          } else {
            a = true;
            break;
          }
        }
        i++, r = z, o = B;
      }
      if (i === 0 && a) {
        this.addBounceEffect(e);
        return;
      }
      if (i === 0 && !l) return;
      typeof window < "u" && typeof window.recordMoveState == "function" && window.recordMoveState(this, n), this.isAnimating = true;
      let f = r, m = o;
      const v = this.group.position.x, g = this.group.position.z, p = this.gridSize * this.cubeSize / 2;
      let _, x;
      if (this.isVertical) _ = f * this.cubeSize + this.cubeSize / 2 - p, x = m * this.cubeSize + this.cubeSize / 2 - p;
      else if (Math.abs(this.direction.x) > 0) {
        const B = f * this.cubeSize + this.cubeSize / 2, U = (f + this.length - 1) * this.cubeSize + this.cubeSize / 2;
        _ = (B + U) / 2 - p, x = m * this.cubeSize + this.cubeSize / 2 - p;
      } else {
        _ = f * this.cubeSize + this.cubeSize / 2 - p;
        const B = m * this.cubeSize + this.cubeSize / 2, U = (m + this.length - 1) * this.cubeSize + this.cubeSize / 2;
        x = (B + U) / 2 - p;
      }
      if (l) {
        let z = _ - v, B = x - g, U = Math.sqrt(z * z + B * B);
        if (U === 0 || i === 0) {
          const V = this.direction.x, K = this.direction.z;
          U = Math.sqrt(V * V + K * K), U > 0 ? (z = V / U, B = K / U) : (z = 1, B = 0, U = 1);
        } else z = z / U, B = B / U;
        const G = Math.max(t * this.cubeSize * 2, this.length * this.cubeSize * 3);
        _ = _ + z * G, x = x + B * G;
      }
      const b = Math.sqrt((_ - v) ** 2 + (x - g) ** 2), E = l;
      if (E) {
        this.wasCatapulted = true, this._catapultRestStartMs = 0;
        try {
          this.cubes && this.cubes[0] && (this.cubes[0].castShadow = false, this.cubes[0].receiveShadow = false, this._catapultShadowSuppressed = true);
        } catch {
        }
      }
      const S = 0.05;
      let w, A, M = 200;
      const y = u !== null;
      if (y) {
        const z = u.gridX, B = u.gridZ;
        if (this.isVertical) w = z * this.cubeSize + this.cubeSize / 2 - p, A = B * this.cubeSize + this.cubeSize / 2 - p;
        else {
          const U = u.originalDirection;
          if (Math.abs(U.x) > 0) {
            const V = z * this.cubeSize + this.cubeSize / 2, K = (z + this.length - 1) * this.cubeSize + this.cubeSize / 2;
            w = (V + K) / 2 - p, A = B * this.cubeSize + this.cubeSize / 2 - p;
          } else {
            w = z * this.cubeSize + this.cubeSize / 2 - p;
            const V = B * this.cubeSize + this.cubeSize / 2, K = (B + this.length - 1) * this.cubeSize + this.cubeSize / 2;
            A = (V + K) / 2 - p;
          }
        }
      }
      if (this.gridX = f, this.gridZ = m, y) if (this.isVertical) _ = f * this.cubeSize + this.cubeSize / 2 - p, x = m * this.cubeSize + this.cubeSize / 2 - p;
      else if (Math.abs(this.direction.x) > 0) {
        const B = f * this.cubeSize + this.cubeSize / 2, U = (f + this.length - 1) * this.cubeSize + this.cubeSize / 2;
        _ = (B + U) / 2 - p, x = m * this.cubeSize + this.cubeSize / 2 - p;
      } else {
        _ = f * this.cubeSize + this.cubeSize / 2 - p;
        const B = m * this.cubeSize + this.cubeSize / 2, U = (m + this.length - 1) * this.cubeSize + this.cubeSize / 2;
        x = (B + U) / 2 - p;
      }
      let C, N = 0, I = 0;
      if (y) {
        const z = Math.sqrt((w - v) ** 2 + (A - g) ** 2), B = Math.sqrt((_ - w) ** 2 + (x - A) ** 2);
        N = z / S, I = B / S, C = N + M + I;
      } else C = b / S;
      const D = performance.now(), O = () => {
        if (this.needsStop) {
          this.needsStop = false, this.isAnimating = false, this.group.scale.set(1, 1, 1), this.updateWorldPosition(), typeof window < "u" && typeof window.updateUndoButtonState == "function" && window.updateUndoButtonState();
          return;
        }
        const z = performance.now() - D;
        let B = Math.min(z / C, 1);
        if (y) {
          const U = z, G = N;
          if (U < G) {
            const V = U / G;
            this.group.position.x = v + (w - v) * V, this.group.position.z = g + (A - g) * V;
            const K = u.originalYOffset;
            this.group.position.y = K, this.group.scale.set(1, 1, 1);
          } else {
            const V = U - G;
            if (V < M) {
              this.group.position.x = w, this.group.position.z = A;
              const K = u.originalYOffset;
              this.group.position.y = K;
              const ce = V / M, Te = ce < 0.5 ? 2 * ce * ce : 1 - Math.pow(-2 * ce + 2, 2) / 2, q = u.originalDirection, te = Math.atan2(q.x, q.z) + Math.PI, de = !this.isVertical && this.length > 1;
              let oe;
              de ? oe = te + Math.PI : oe = Math.atan2(this.direction.x, this.direction.z) + Math.PI;
              const fe = te + (oe - te) * Te;
              if (this.arrow && this.arrow.children.length > 0) {
                const F = this.arrow.children[0];
                F && (F.rotation.z = fe);
              }
              const be = Math.sin(ce * Math.PI) * 0.08;
              this.group.scale.set(1 + be, 1 + be, 1 + be);
            } else {
              const K = V - M, ce = I > 0 ? Math.min(K / I, 1) : 1;
              this.group.position.x = w + (_ - w) * ce, this.group.position.z = A + (x - A) * ce;
              const Te = u.originalYOffset, q = this.yOffset, te = Te + (q - Te) * ce;
              this.group.position.y = te, this.group.scale.set(1, 1, 1);
            }
          }
        } else E ? (this.group.position.x = v + (_ - v) * B, this.group.position.z = g + (x - g) * B, this.group.scale.set(1, 1, 1)) : (this.group.position.x = v + (_ - v) * B, this.group.position.z = g + (x - g) * B, this.group.scale.set(1, 1, 1));
        if (B < 1) requestAnimationFrame(O);
        else if (a) this.updateWorldPosition(), this.addBounceEffect(e);
        else if (l) {
          this.isAnimating = false, typeof window < "u" && typeof window.updateUndoButtonState == "function" && window.updateUndoButtonState();
          let U, G, V;
          const K = this.direction.x, ce = this.direction.z;
          E ? (U = K * 8, G = ce * 8, V = Math.sin(0.3) * 8 * 0.6, this.fall(U, G, V)) : (U = K * 3.5, G = ce * 3.5, this.fall(U, G));
        } else this.group.scale.set(1, 1, 1), this.updateWorldPosition(), this.isAnimating = false, typeof window < "u" && typeof window.updateUndoButtonState == "function" && window.updateUndoButtonState();
      };
      O();
    }
    addBounceEffect(e = []) {
      const a = /* @__PURE__ */ new Set();
      if (this.isVertical) a.add(`${this.gridX},${this.gridZ}`);
      else {
        const g = Math.abs(this.direction.x) > 0;
        for (let p = 0; p < this.length; p++) {
          const _ = this.gridX + (g ? p : 0), x = this.gridZ + (g ? 0 : p);
          a.add(`${_},${x}`);
        }
      }
      const l = /* @__PURE__ */ new Set();
      for (const g of a) {
        const [p, _] = g.split(",").map(Number);
        for (let x = -1; x <= 1; x++) for (let b = -1; b <= 1; b++) {
          if (x === 0 && b === 0) continue;
          const E = p + x, S = _ + b, w = `${E},${S}`;
          if (!a.has(w)) for (const A of e) {
            if (A === this || A.isFalling || A.isAnimating || l.has(A)) continue;
            let M = false;
            if (A.isVertical) A.gridX === E && A.gridZ === S && (M = true);
            else {
              const y = Math.abs(A.direction.x) > 0;
              for (let C = 0; C < A.length; C++) {
                const N = A.gridX + (y ? C : 0), I = A.gridZ + (y ? 0 : C);
                if (N === E && I === S) {
                  M = true;
                  break;
                }
              }
            }
            M && l.add(A);
          }
        }
      }
      const c = this.group.position.x, u = this.group.position.z, d = c - this.direction.x * 0.08, h = u - this.direction.z * 0.08, f = /* @__PURE__ */ new Map();
      for (const g of l) f.set(g, {
        x: g.group.position.x,
        z: g.group.position.z
      });
      const m = performance.now(), v = () => {
        if (this.needsStop) {
          this.needsStop = false, this.isAnimating = false, this.group.scale.set(1, 1, 1), this.updateWorldPosition(), typeof window < "u" && typeof window.updateUndoButtonState == "function" && window.updateUndoButtonState();
          return;
        }
        const g = performance.now() - m, p = Math.min(g / 200, 1);
        if (p < 0.5) {
          const _ = p * 2, x = 1 - Math.pow(1 - _, 2);
          this.group.position.x = c + (d - c) * x, this.group.position.z = u + (h - u) * x;
        } else {
          const _ = (p - 0.5) * 2, x = _ * Math.PI * 3, b = 0.08 * (1 - _), E = Math.sin(x) * b, S = Math.cos(x) * b;
          this.group.position.x = c + E, this.group.position.z = u + S;
          const w = 0.6;
          if (p > w) {
            const A = (p - w) / (1 - w), M = A * Math.PI * 3, y = 0.04 * (1 - A);
            for (const C of l) {
              const N = f.get(C);
              if (N) {
                const I = Math.sin(M) * y, D = Math.cos(M) * y;
                C.group.position.x = N.x + I, C.group.position.z = N.z + D;
              }
            }
          }
        }
        if (p < 1) requestAnimationFrame(v);
        else {
          this.updateWorldPosition(), this.isAnimating = false, typeof window < "u" && typeof window.updateUndoButtonState == "function" && window.updateUndoButtonState();
          for (const _ of l) _.updateWorldPosition();
        }
      };
      v();
    }
    fall(e = null, t = null, n = null) {
      if (this.isFalling) return;
      this.isFalling = true, this.fallingStartTime = Date.now();
      const i = n !== null && n > 0;
      this.wasCatapulted = !!i, this._catapultRestStartMs = 0, !i && this._catapultShadowSuppressed && this.cubes && this.cubes[0] && (this.cubes[0].castShadow = true, this.cubes[0].receiveShadow = true, this._catapultShadowSuppressed = false);
      try {
        i && this.cubes && this.cubes[0] && (this.cubes[0].castShadow = false, this.cubes[0].receiveShadow = false, this._catapultShadowSuppressed = true);
      } catch {
      }
      const r = Math.abs(this.direction.x) > 0, o = r ? this.direction.x : this.direction.z;
      let a = 0, l = 0, c = 0;
      const u = i ? 1.8 : 1;
      if (this.isVertical ? (r ? (c = o * 3.5 * u, a = (Math.random() - 0.5) * 2.5 * u) : (a = -o * 3.5 * u, c = (Math.random() - 0.5) * 2.5 * u), l = (Math.random() - 0.5) * 1.5 * u) : r ? (c = o * 4.5 * u, l = (Math.random() - 0.5) * 2 * u, a = (Math.random() - 0.5) * 1.5 * u) : (a = -o * 4.5 * u, l = (Math.random() - 0.5) * 2 * u, c = (Math.random() - 0.5) * 1.5 * u), this.pendingAngularVel = {
        x: a,
        y: l,
        z: c
      }, e !== null && t !== null) {
        const d = n !== null ? n : 0;
        this.pendingLinearVel = {
          x: e,
          y: d,
          z: t
        };
      } else this.pendingLinearVel = {
        x: this.direction.x * 3.5,
        y: 0,
        z: this.direction.z * 3.5
      };
      this.needsPhysicsBody = true;
    }
    setHighlight(e) {
      if (this.isHighlighted === e) return;
      if (this.isHighlighted = e, !this.cubes || !this.cubes[0]) {
        console.warn("Block.setHighlight: No cubes found");
        return;
      }
      const t = this.cubes[0];
      if (!t.material) {
        console.warn("Block.setHighlight: No material found");
        return;
      }
      if (e) {
        const n = this.originalMaterial.clone();
        n.emissive = new ye(16776960), n.emissiveIntensity = 2, n.color = new ye(16776960), n.roughness = 0.1, t.material = n, this.highlightAnimation || (this.highlightAnimation = {
          time: 0
        }), console.log(`Block at (${this.gridX}, ${this.gridZ}) highlighted - material updated`);
      } else t.material = this.originalMaterial, this.highlightAnimation = null;
    }
    updateHighlightAnimation(e) {
      if (this.isHighlighted && this.cubes && this.cubes[0] && this.cubes[0].material) {
        this.highlightAnimation || (this.highlightAnimation = {
          time: 0
        }), this.highlightAnimation.time += e;
        const t = Math.sin(this.highlightAnimation.time * 3) * 0.3 + 0.7;
        this.cubes[0].material.emissiveIntensity = t;
      }
    }
    remove() {
      this.isRemoved = true, this.physicsBody && (M0(this.physics, this.physicsBody, true), this.physicsBody = null, this.physicsCollider = null), this.group.parent ? this.group.parent.remove(this.group) : this.scene.remove(this.group);
    }
  }
  function Gg(s, e, t) {
    const n = document.createElement("canvas");
    n.width = 256, n.height = 256;
    const i = n.getContext("2d"), r = i.createLinearGradient(0, 0, 0, 256), o = e >> 16 & 255, a = e >> 8 & 255, l = e & 255, c = t >> 16 & 255, u = t >> 8 & 255, d = t & 255;
    r.addColorStop(0, `rgb(${o}, ${a}, ${l})`), r.addColorStop(1, `rgb(${c}, ${u}, ${d})`), i.fillStyle = r, i.fillRect(0, 0, 256, 256);
    const h = new ng(n);
    h.mapping = cr, s.background = h;
  }
  function Wg(s, e) {
    s.fog = null;
  }
  function Sw(s) {
    const e = (() => {
      try {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
      } catch {
        return false;
      }
    })(), t = new Du(16777215, 0.1);
    s.add(t);
    const n = new ja(16777215, 1.8);
    n.position.set(10, 20, 10), n.castShadow = true, n.shadow.camera.left = -12, n.shadow.camera.right = 12, n.shadow.camera.top = 14, n.shadow.camera.bottom = -14, n.shadow.camera.near = 1, n.shadow.camera.far = e ? 60 : 50, n.shadow.camera.position.set(0, 25, 0), n.shadow.camera.lookAt(0, 0, 0);
    const i = e ? 1024 : 2048;
    n.shadow.mapSize.width = i, n.shadow.mapSize.height = i, n.shadow.bias = -1e-4, n.shadow.radius = e ? 2 : 3, n.shadow.normalBias = 0.02, s.add(n);
    const r = new ja(16777215, 0.12);
    return r.position.set(-8, 12, -8), s.add(r), {
      ambientLight: t,
      keyLight: n,
      fillLight: r
    };
  }
  function ww(s) {
    const n = new bi(7, 0.2, 7), i = new qt({
      color: 4473924,
      roughness: 0.3,
      metalness: 0.1
    }), r = new ht(n, i);
    r.position.set(7 * 1 / 2, -0.1, 7 * 1 / 2), r.receiveShadow = true, s.add(r);
    const o = new Hg(7 * 1, 7, 8947848, 6710886);
    return o.position.set(7 * 1 / 2, 0.01, 7 * 1 / 2), o.material && (o.material.transparent = true, o.material.opacity = 0.8), s.add(o), {
      base: r,
      gridHelper: o,
      gridSize: 7,
      cubeSize: 1
    };
  }
  function En(s) {
    const e = [];
    if (s.isVertical) e.push({
      x: s.gridX,
      z: s.gridZ
    });
    else {
      const t = Math.abs(s.direction.x) > 0;
      for (let n = 0; n < s.length; n++) {
        const i = s.gridX + (t ? n : 0), r = s.gridZ + (t ? 0 : n);
        e.push({
          x: i,
          z: r
        });
      }
    }
    return e;
  }
  const Tw = 0.01, Ff = 1e-3;
  function Yr(s) {
    const e = Math.round(s);
    return Math.abs(s - e) < Tw ? e : s;
  }
  function Fh(s, e, t, n) {
    return e - t > Ff && n - s > Ff;
  }
  function Bf(s, e, t) {
    const n = s.direction;
    let i = s.gridX, r = s.gridZ, o = 0;
    const a = t * 2;
    for (; o < a; ) {
      o++;
      const l = i + n.x, c = r + n.z;
      if (s.isVertical) {
        if (l < 0 || l >= t || c < 0 || c >= t) return {
          canExit: true,
          stepsToExit: o
        };
        if (e.has(`${l},${c}`)) return {
          canExit: false,
          stepsToExit: o
        };
      } else {
        const u = Math.abs(n.x) > 0;
        let d = true, h = false;
        for (let f = 0; f < s.length; f++) {
          const m = l + (u ? f : 0), v = c + (u ? 0 : f);
          if (m < 0 || m >= t || v < 0 || v >= t) {
            h = true;
            break;
          }
          if (e.has(`${m},${v}`)) {
            d = false;
            break;
          }
        }
        if (h) return {
          canExit: true,
          stepsToExit: o
        };
        if (!d) return {
          canExit: false,
          stepsToExit: o
        };
      }
      i = l, r = c;
    }
    return {
      canExit: false,
      stepsToExit: o
    };
  }
  function Vi(s, e) {
    const t = /* @__PURE__ */ new Map();
    for (const n of s) {
      if (n.isFalling || n.isAnimating || n.isRemoved || n.removalStartTime) continue;
      const i = En(n), r = n.cubeSize || 1, o = n.isVertical ? n.length * r : r, a = Yr(n.yOffset || 0), l = a + o;
      for (const c of i) if (c.x < 0 || c.x >= e || c.z < 0 || c.z >= e) return {
        valid: false,
        reason: `Block out of bounds at (${c.x}, ${c.z})`
      };
      for (const c of i) {
        const u = `${c.x},${c.z}`;
        if (t.has(u)) {
          const d = t.get(u);
          for (const h of d) if (Fh(a, l, h.yBottom, h.yTop)) {
            const f = `block at (${n.gridX}, ${n.gridZ}), yOffset=${a}, height=${o}`, m = `block at (${h.block.gridX}, ${h.block.gridZ}), yOffset=${h.yBottom}, height=${h.yTop - h.yBottom}`;
            return console.warn(`Overlap detected: ${f} overlaps with ${m} at (${c.x}, ${c.z})`), {
              valid: false,
              reason: `Overlap at (${c.x}, ${c.z})`
            };
          }
          d.push({
            block: n,
            yBottom: a,
            yTop: l
          });
        } else t.set(u, [
          {
            block: n,
            yBottom: a,
            yTop: l
          }
        ]);
      }
    }
    return {
      valid: true
    };
  }
  function Qa(s, e) {
    const t = [];
    function n(u, d = null) {
      const h = u.cubeSize || 1, f = u.isVertical ? u.length * h : h, m = Yr(d !== null ? d : u.yOffset || 0);
      return {
        yBottom: m,
        yTop: m + f,
        height: f,
        cubeSize: h
      };
    }
    function i(u) {
      const d = /* @__PURE__ */ new Set();
      for (const h of u) d.add(`${h.x},${h.z}`);
      return d;
    }
    function r(u, d, h) {
      const { yBottom: f, yTop: m } = n(u, d), v = En(u), g = i(v);
      for (const p of h) {
        if (!p || p === u || p.isFalling || p.isAnimating || p.isRemoved || p.removalStartTime) continue;
        const _ = En(p);
        let x = false;
        for (const E of _) if (g.has(`${E.x},${E.z}`)) {
          x = true;
          break;
        }
        if (!x) continue;
        const b = n(p);
        if (Fh(f, m, b.yBottom, b.yTop)) return false;
      }
      return true;
    }
    const o = [], a = /* @__PURE__ */ new Map();
    for (const u of s) {
      if (u.isFalling || u.isAnimating || u.isRemoved || u.removalStartTime) continue;
      const { yBottom: d, yTop: h } = n(u), f = En(u);
      for (const m of f) {
        const v = `${m.x},${m.z}`, g = a.get(v) || [];
        for (const p of g) Fh(d, h, p.yBottom, p.yTop) && o.push({
          block1: u,
          block2: p.block,
          cell: {
            x: m.x,
            z: m.z
          }
        });
        g.push({
          block: u,
          yBottom: d,
          yTop: h
        }), a.set(v, g);
      }
    }
    const l = [];
    for (const u of o) {
      const d = u.block1, h = u.block2;
      if (!d || !h) continue;
      const f = Yr(d.yOffset || 0), m = Yr(h.yOffset || 0);
      let v = d;
      d.isVertical !== h.isVertical ? v = d.isVertical ? h : d : v = f >= m ? d : h;
      const { cubeSize: g } = n(v), p = Yr(v.yOffset || 0), _ = [
        p
      ], x = 20;
      for (let E = 1; E <= x; E++) _.push(Math.max(0, p - E * g)), _.push(p + E * g);
      let b = null;
      for (const E of _) if (r(v, E, s)) {
        b = E;
        break;
      }
      b !== null && Math.abs((v.yOffset || 0) - b) > 1e-9 ? (v.yOffset = b, typeof v.updateWorldPosition == "function" && v.updateWorldPosition(), t.includes(v) || t.push(v)) : b === null && l.push({
        block1: {
          gridX: d.gridX,
          gridZ: d.gridZ,
          yOffset: f,
          isVertical: d.isVertical,
          length: d.length
        },
        block2: {
          gridX: h.gridX,
          gridZ: h.gridZ,
          yOffset: m,
          isVertical: h.isVertical,
          length: h.length
        },
        cell: u.cell,
        attemptedBlock: {
          gridX: v.gridX,
          gridZ: v.gridZ,
          yOffset: p
        }
      });
    }
    const c = Vi(s, e);
    return !c.valid && l.length > 0 && console.warn(`fixOverlappingBlocks: Could not resolve ${l.length} overlap(s):`, l), {
      fixed: c.valid,
      movedBlocks: t,
      failedOverlaps: l
    };
  }
  function Ew(s, e) {
    if (Vi(s, e).valid) return {
      fixed: false,
      message: "No overlaps detected"
    };
    console.warn("Overlaps detected, attempting to fix...");
    const n = Qa(s, e);
    if (n.fixed) {
      const i = Vi(s, e);
      return i.valid ? {
        fixed: true,
        message: `Fixed ${n.movedBlocks.length} overlapping block(s)`,
        movedBlocks: n.movedBlocks
      } : {
        fixed: false,
        message: `Partially fixed, but still have overlaps: ${i.reason}`,
        movedBlocks: n.movedBlocks
      };
    } else return {
      fixed: false,
      message: "Could not fix overlaps automatically",
      movedBlocks: []
    };
  }
  const Aw = "jarrows_stats", Cw = 1, Hi = "pending_submissions", pr = "local_stats_cache";
  let el = null;
  async function Xg() {
    return new Promise((s, e) => {
      const t = indexedDB.open(Aw, Cw);
      t.onerror = () => {
        console.error("Failed to open stats database:", t.error), e(t.error);
      }, t.onsuccess = () => {
        el = t.result, console.log("Stats database opened successfully"), s(el);
      }, t.onupgradeneeded = (n) => {
        const i = n.target.result;
        i.objectStoreNames.contains(Hi) || i.createObjectStore(Hi, {
          keyPath: "id",
          autoIncrement: true
        }).createIndex("timestamp", "timestamp", {
          unique: false
        }), i.objectStoreNames.contains(pr) || i.createObjectStore(pr, {
          keyPath: "level"
        }).createIndex("lastUpdated", "lastUpdated", {
          unique: false
        });
      };
    });
  }
  async function Ho() {
    return el || await Xg(), el;
  }
  async function kf(s) {
    try {
      const n = (await Ho()).transaction([
        Hi
      ], "readwrite").objectStore(Hi), i = {
        ...s,
        timestamp: Date.now(),
        retryCount: 0
      }, r = n.add(i);
      return new Promise((o, a) => {
        r.onsuccess = () => {
          console.log("Stats submission queued:", i), o(r.result);
        }, r.onerror = () => {
          console.error("Failed to queue submission:", r.error), a(r.error);
        };
      });
    } catch (e) {
      console.error("Error queueing submission:", e);
      try {
        const t = JSON.parse(localStorage.getItem("jarrows_stats_queue") || "[]");
        t.push({
          ...s,
          timestamp: Date.now()
        }), localStorage.setItem("jarrows_stats_queue", JSON.stringify(t)), console.log("Stats submission queued in localStorage fallback");
      } catch (t) {
        console.error("Failed to queue in localStorage fallback:", t);
      }
    }
  }
  async function Rw() {
    try {
      const i = (await Ho()).transaction([
        Hi
      ], "readonly").objectStore(Hi).index("timestamp").getAll();
      return new Promise((r, o) => {
        i.onsuccess = () => {
          r(i.result || []);
        }, i.onerror = () => {
          o(i.error);
        };
      });
    } catch (s) {
      console.error("Error getting pending submissions:", s);
      try {
        return JSON.parse(localStorage.getItem("jarrows_stats_queue") || "[]");
      } catch {
        return [];
      }
    }
  }
  async function Pw(s) {
    try {
      const i = (await Ho()).transaction([
        Hi
      ], "readwrite").objectStore(Hi).delete(s);
      return new Promise((r, o) => {
        i.onsuccess = () => {
          r();
        }, i.onerror = () => {
          o(i.error);
        };
      });
    } catch (e) {
      console.error("Error removing submission:", e);
      try {
        const n = JSON.parse(localStorage.getItem("jarrows_stats_queue") || "[]").filter((i, r) => r !== s);
        localStorage.setItem("jarrows_stats_queue", JSON.stringify(n));
      } catch {
      }
    }
  }
  async function Iw(s, e) {
    try {
      const i = (await Ho()).transaction([
        pr
      ], "readwrite").objectStore(pr), r = {
        level: s,
        stats: e,
        lastUpdated: Date.now()
      }, o = i.put(r);
      return new Promise((a, l) => {
        o.onsuccess = () => {
          a();
        }, o.onerror = () => {
          l(o.error);
        };
      });
    } catch (t) {
      console.error("Error caching level stats:", t);
      try {
        const n = JSON.parse(localStorage.getItem("jarrows_stats_cache") || "{}");
        n[s] = {
          stats: e,
          lastUpdated: Date.now()
        }, localStorage.setItem("jarrows_stats_cache", JSON.stringify(n));
      } catch (n) {
        console.error("Failed to cache in localStorage fallback:", n);
      }
    }
  }
  async function Lw(s) {
    try {
      const i = (await Ho()).transaction([
        pr
      ], "readonly").objectStore(pr).get(s);
      return new Promise((r, o) => {
        i.onsuccess = () => {
          const a = i.result;
          a && Date.now() - a.lastUpdated < 36e5 ? r(a.stats) : r(null);
        }, i.onerror = () => {
          o(i.error);
        };
      });
    } catch (e) {
      console.error("Error getting cached stats:", e);
      try {
        const n = JSON.parse(localStorage.getItem("jarrows_stats_cache") || "{}")[s];
        return n && Date.now() - n.lastUpdated < 36e5 ? n.stats : null;
      } catch {
        return null;
      }
    }
  }
  const Yg = "https://api.jarrows.stats/v1", Dw = "local".toLowerCase();
  function $i() {
    return Dw === "local";
  }
  function Tr() {
    return $i() ? false : navigator.onLine;
  }
  async function qg(s) {
    if ($i()) throw new Error("Local-only mode: network submission disabled");
    if (!Tr()) throw new Error("Offline - stats will be queued");
    try {
      const e = await fetch(`${Yg}/submit`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          level: s.level,
          time: s.time,
          moves: s.moves,
          spins: s.spins,
          blocksRemoved: s.blocksRemoved
        })
      });
      if (!e.ok) throw new Error(`API error: ${e.status} ${e.statusText}`);
      return await e.json();
    } catch (e) {
      throw console.error("Failed to submit stats:", e), e;
    }
  }
  async function Nw(s) {
    if ($i()) return null;
    if (!Tr()) throw new Error("Offline - will use cached stats");
    try {
      const e = await fetch(`${Yg}/stats/${s}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!e.ok) {
        if (e.status === 404) return null;
        throw new Error(`API error: ${e.status} ${e.statusText}`);
      }
      return await e.json();
    } catch (e) {
      throw console.error("Failed to fetch level stats:", e), e;
    }
  }
  function Go(s, e, t, n) {
    if (s <= e) return Math.max(0, Math.min(25, s / e * 25));
    if (s <= t) {
      const i = t - e;
      return 25 + (s - e) / i * 25;
    } else if (s <= n) {
      const i = n - t;
      return 50 + (s - t) / i * 25;
    } else {
      const r = n * 2 - n;
      if (r <= 0) return 100;
      const o = (s - n) / r * 25;
      return Math.min(100, 75 + o);
    }
  }
  function Bh(s, e) {
    if (!e || !e.medianTime) return null;
    const t = e.p25Time || e.medianTime * 0.8, n = e.medianTime, i = e.p75Time || e.medianTime * 1.3;
    return 100 - Go(s, t, n, i);
  }
  function kh(s, e) {
    if (!e || !e.medianMoves) return null;
    const t = e.p25Moves || e.medianMoves * 0.85, n = e.medianMoves, i = e.p75Moves || e.medianMoves * 1.2;
    return 100 - Go(s, t, n, i);
  }
  function Vh(s, e) {
    if (!e || e.medianSpins === void 0) return null;
    const t = e.medianSpins;
    if (s < t) return 75 - s / t * 25;
    if (s === t) return 50;
    {
      const n = s - t;
      return Math.max(0, 50 - n * 15);
    }
  }
  function Hh(s, e) {
    if (!e || e.medianMovesPerBlock === void 0) return null;
    const t = e.p25MovesPerBlock ?? e.medianMovesPerBlock * 0.85, n = e.medianMovesPerBlock, i = e.p75MovesPerBlock ?? e.medianMovesPerBlock * 1.2;
    return 100 - Go(s, t, n, i);
  }
  function Gh(s, e) {
    if (!e || e.medianTimePerMove === void 0) return null;
    const t = e.p25TimePerMove ?? e.medianTimePerMove * 0.8, n = e.medianTimePerMove, i = e.p75TimePerMove ?? e.medianTimePerMove * 1.3;
    return 100 - Go(s, t, n, i);
  }
  function Wh(s, e) {
    if (!e || e.medianBlocksPerSpin === void 0) return null;
    const t = e.p25BlocksPerSpin ?? e.medianBlocksPerSpin * 0.8, n = e.medianBlocksPerSpin, i = e.p75BlocksPerSpin ?? e.medianBlocksPerSpin * 1.3;
    return Go(s, t, n, i);
  }
  function Yt(s, e, t = true) {
    if (!e) return {
      better: null,
      percentDiff: null,
      text: "No comparison data",
      badge: null
    };
    const n = s - e, i = Math.abs(n / e * 100), r = t ? n < 0 : n > 0;
    let o, a;
    return Math.abs(n) < 0.01 ? (o = "Same as median", a = "equal") : r ? (o = `${i.toFixed(0)}% better`, a = "better") : (o = `${i.toFixed(0)}% ${t ? "slower" : "worse"}`, a = "worse"), {
      better: r,
      percentDiff: i.toFixed(1),
      text: o,
      badge: a
    };
  }
  function Vf(s, e) {
    if (!e) return {
      rating: "unavailable",
      percentile: null,
      badges: []
    };
    const t = Bh(s.time, e), n = kh(s.moves, e), i = Vh(s.spins, e), r = (t || 50) * 0.4 + (n || 50) * 0.4 + (i || 50) * 0.2;
    let o, a = [];
    return r >= 90 ? (o = "elite", a.push("elite")) : r >= 75 ? (o = "excellent", a.push("excellent")) : r >= 50 ? o = "good" : r >= 25 ? o = "average" : o = "below_average", t && t >= 75 && a.push("speed_demon"), n && n >= 75 && a.push("precision_master"), i && i >= 75 && a.push("efficient"), t >= 75 && n >= 75 && a.push("perfect_run"), {
      rating: o,
      percentile: Math.round(r),
      badges: a
    };
  }
  const Hf = "jarrows_badges_v1", Uw = [
    {
      id: "perfect_run",
      label: "Perfect Run",
      kind: "community",
      description: "Top 25% on time and moves (and solid spins).",
      priority: 100
    },
    {
      id: "speed_demon",
      label: "Speed Demon",
      kind: "community",
      description: "Top 25% time for this level.",
      priority: 80
    },
    {
      id: "precision_master",
      label: "Precision Master",
      kind: "community",
      description: "Top 25% moves for this level.",
      priority: 80
    },
    {
      id: "spin_saver",
      label: "Spin Saver",
      kind: "community",
      description: "Top 25% spins usage for this level.",
      priority: 70
    },
    {
      id: "no_spins",
      label: "No Spins",
      kind: "local",
      description: "Cleared the level without using spins.",
      priority: 60
    },
    {
      id: "no_spills",
      label: "Clean Finish",
      kind: "local",
      description: "Cleared the level with very low move count.",
      priority: 40
    }
  ];
  function kc(s) {
    return typeof s == "number" && Number.isFinite(s) ? s : null;
  }
  function Vc({ userStats: s, comparison: e }) {
    var _a2, _b2, _c2;
    const t = [];
    if (s.spins === 0 && t.push("no_spins"), s.moves <= 3 && t.push("no_spills"), !(e == null ? void 0 : e.available) || (e == null ? void 0 : e.source) !== "community") return {
      earned: t,
      pendingCommunity: true
    };
    const n = kc((_a2 = e == null ? void 0 : e.time) == null ? void 0 : _a2.percentile), i = kc((_b2 = e == null ? void 0 : e.moves) == null ? void 0 : _b2.percentile), r = kc((_c2 = e == null ? void 0 : e.spins) == null ? void 0 : _c2.percentile);
    n !== null && n >= 75 && t.push("speed_demon"), i !== null && i >= 75 && t.push("precision_master"), r !== null && r >= 75 && t.push("spin_saver");
    const o = r === null ? true : r >= 50;
    return n !== null && i !== null && n >= 75 && i >= 75 && o && t.push("perfect_run"), t.sort((a, l) => Gf(l) - Gf(a) || a.localeCompare(l)), {
      earned: t,
      pendingCommunity: false
    };
  }
  function Ow(s) {
    return Uw.find((e) => e.id === s) || null;
  }
  function Gf(s) {
    var _a2;
    return ((_a2 = Ow(s)) == null ? void 0 : _a2.priority) ?? 0;
  }
  function Hc({ level: s, badgeIds: e }) {
    try {
      const t = localStorage.getItem(Hf), n = t ? JSON.parse(t) : {}, i = Date.now(), r = `level_${s}`, o = Array.isArray(n[r]) ? n[r] : [], a = Array.from(/* @__PURE__ */ new Set([
        ...o,
        ...e
      ]));
      n[r] = a, (!n.counts || typeof n.counts != "object") && (n.counts = {});
      for (const l of e) n.counts[l] = (n.counts[l] || 0) + 1;
      n.lastUpdated = i, localStorage.setItem(Hf, JSON.stringify(n));
    } catch {
    }
  }
  const $g = "jarrows_streaks_v1";
  function hs() {
    return {
      lastLevel: null,
      speed: {
        current: 0,
        best: 0
      },
      moves: {
        current: 0,
        best: 0
      },
      perfect: {
        current: 0,
        best: 0
      },
      updatedAt: Date.now()
    };
  }
  function zw() {
    try {
      const s = localStorage.getItem($g);
      if (!s) return hs();
      const e = JSON.parse(s);
      return !e || typeof e != "object" ? hs() : {
        ...hs(),
        ...e,
        speed: {
          ...hs().speed,
          ...e.speed || {}
        },
        moves: {
          ...hs().moves,
          ...e.moves || {}
        },
        perfect: {
          ...hs().perfect,
          ...e.perfect || {}
        }
      };
    } catch {
      return hs();
    }
  }
  function Fw(s) {
    try {
      localStorage.setItem($g, JSON.stringify(s));
    } catch {
    }
  }
  function Gc(s, e, t) {
    t ? s.current = e ? s.current + 1 : 0 : s.current = e ? 1 : 0, s.best = Math.max(s.best, s.current);
  }
  function Bw({ level: s, comparisonAvailable: e, beatMedianTime: t, beatMedianMoves: n, perfectRun: i }) {
    const r = zw();
    if (!Number.isInteger(s) || s < 0 || r.lastLevel !== null && s <= r.lastLevel) return r;
    const o = r.lastLevel === null ? true : s === r.lastLevel + 1;
    return Gc(r.speed, !!t, o), Gc(r.moves, !!n, o), Gc(r.perfect, !!i, o), r.lastLevel = s, r.updatedAt = Date.now(), Fw(r), r;
  }
  let bn = {
    level: 0,
    startTime: null,
    moves: 0,
    spins: 0,
    blocksRemoved: 0,
    initialSpins: 3
  }, Ba = {}, Wc = false;
  const Wf = "jarrows_stats_storage_version", Xf = 1;
  function Zg(s) {
    if (!s || typeof s != "object") return null;
    const e = Number(s.level), t = Number(s.time), n = Number(s.moves), i = Number(s.spins), r = Number(s.blocksRemoved), o = Number(s.timestamp);
    return !Number.isInteger(e) || e < 0 || !Number.isFinite(t) || t < 0 || t > 60 * 60 || !Number.isFinite(n) || n < 0 || n > 1e5 || !Number.isFinite(i) || i < 0 || i > 1e3 || !Number.isFinite(r) || r < 0 || r > 1e5 ? null : {
      level: e,
      time: t,
      moves: Math.trunc(n),
      spins: Math.trunc(i),
      blocksRemoved: Math.trunc(r),
      timestamp: Number.isFinite(o) && o > 0 ? o : Date.now()
    };
  }
  function kw() {
    try {
      if (Number(localStorage.getItem(Wf) || "0") >= Xf) return;
      const e = [];
      for (let t = 0; t < localStorage.length; t++) {
        const n = localStorage.key(t);
        !n || !n.startsWith("jarrows_level_") || !n.endsWith("_stats") || e.push(n);
      }
      for (const t of e) {
        const n = localStorage.getItem(t);
        let i = [];
        try {
          const a = n ? JSON.parse(n) : [];
          Array.isArray(a) && (i = a);
        } catch {
          i = [];
        }
        const r = i.map(Zg).filter(Boolean);
        r.sort((a, l) => (a.timestamp || 0) - (l.timestamp || 0));
        const o = r.slice(Math.max(0, r.length - 10));
        localStorage.setItem(t, JSON.stringify(o));
      }
      localStorage.setItem(Wf, String(Xf));
    } catch {
    }
  }
  async function Vw() {
    if (Wc) {
      console.warn("Stats system already initialized");
      return;
    }
    try {
      kw(), await Xg(), $i() || (window.addEventListener("online", Qw), window.addEventListener("offline", e1), Tr() && await jg()), Wc = true, console.log("Stats system initialized");
    } catch (s) {
      console.error("Failed to initialize stats system:", s), Wc = true;
    }
  }
  function Xl(s) {
    bn = {
      level: s,
      startTime: performance.now() / 1e3,
      moves: 0,
      spins: 3,
      blocksRemoved: 0,
      initialSpins: 3
    }, Jg(s).catch((e) => {
      console.warn("Failed to preload community stats:", e);
    });
  }
  function Hw() {
    bn.moves++;
  }
  function Gw() {
    bn.spins > 0 && bn.spins--;
  }
  function Ww() {
    bn.blocksRemoved++;
  }
  async function Xw(s) {
    const e = {
      level: bn.level,
      time: s || Yw(),
      moves: bn.moves,
      spins: bn.initialSpins - bn.spins,
      blocksRemoved: bn.blocksRemoved,
      timestamp: Date.now()
    };
    if (qw(e), $i()) return e;
    try {
      Tr() ? (await qg(e), console.log("Stats submitted successfully:", e)) : (await kf(e), console.log("Stats queued for later submission:", e));
    } catch (t) {
      await kf(e), console.warn("Failed to submit stats, queued for later:", t);
    }
    return e;
  }
  function Yw() {
    return bn.startTime ? performance.now() / 1e3 - bn.startTime : 0;
  }
  function qw(s) {
    try {
      const e = `jarrows_level_${s.level}_stats`, t = JSON.parse(localStorage.getItem(e) || "[]");
      t.push({
        ...s,
        timestamp: typeof s.timestamp == "number" ? s.timestamp : Date.now()
      }), t.length > 10 && t.shift(), localStorage.setItem(e, JSON.stringify(t));
    } catch (e) {
      console.error("Failed to store local stats:", e);
    }
  }
  function $w(s) {
    try {
      const e = `jarrows_level_${s}_stats`, t = JSON.parse(localStorage.getItem(e) || "[]");
      return Array.isArray(t) ? t.map(Zg).filter(Boolean) : [];
    } catch (e) {
      return console.error("Failed to get local stats:", e), [];
    }
  }
  async function Jg(s) {
    if (Ba[s]) return Ba[s];
    const e = await Lw(s);
    if (e) return Ba[s] = e, e;
    if (Tr()) try {
      const t = await Nw(s);
      return t && typeof t.totalAttempts == "number" && t.totalAttempts > 0 ? (await Iw(s, t), Ba[s] = t, t) : null;
    } catch (t) {
      return console.warn("Failed to fetch community stats:", t), null;
    }
    return null;
  }
  function Pn(s, e) {
    if (!s.length) return null;
    if (s.length === 1) return s[0];
    const t = (s.length - 1) * e, n = Math.floor(t), i = t - n, r = s[n], o = s[Math.min(n + 1, s.length - 1)];
    return r + (o - r) * i;
  }
  function us(s) {
    return Pn(s, 0.5);
  }
  function Kg(s, e) {
    const t = e.map((h) => h.time).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), n = e.map((h) => h.moves).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), i = e.map((h) => h.spins).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), r = e.map((h) => h.blocksRemoved).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), o = e.map((h) => h.blocksRemoved > 0 ? h.moves / h.blocksRemoved : h.moves).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), a = e.map((h) => h.moves > 0 ? h.time / h.moves : h.time).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), l = e.map((h) => h.spins > 0 ? h.blocksRemoved / h.spins : h.blocksRemoved).filter((h) => typeof h == "number" && Number.isFinite(h)).sort((h, f) => h - f), c = o.reduce((h, f) => h + f, 0) / (o.length || 1), u = a.reduce((h, f) => h + f, 0) / (a.length || 1), d = l.reduce((h, f) => h + f, 0) / (l.length || 1);
    return {
      level: s,
      medianTime: us(t),
      medianMoves: us(n),
      medianSpins: us(i),
      medianBlocksRemoved: us(r),
      p25Time: Pn(t, 0.25),
      p75Time: Pn(t, 0.75),
      p25Moves: Pn(n, 0.25),
      p75Moves: Pn(n, 0.75),
      completionRate: 1,
      totalAttempts: e.length,
      lastUpdated: Date.now(),
      avgMovesPerBlock: c,
      avgTimePerMove: u,
      avgBlocksPerSpin: d,
      medianMovesPerBlock: us(o),
      p25MovesPerBlock: Pn(o, 0.25),
      p75MovesPerBlock: Pn(o, 0.75),
      medianTimePerMove: us(a),
      p25TimePerMove: Pn(a, 0.25),
      p75TimePerMove: Pn(a, 0.75),
      medianBlocksPerSpin: us(l),
      p25BlocksPerSpin: Pn(l, 0.25),
      p75BlocksPerSpin: Pn(l, 0.75)
    };
  }
  function Zw() {
    const s = [];
    try {
      for (let e = 0; e < localStorage.length; e++) {
        const t = localStorage.key(e);
        if (!t || !t.startsWith("jarrows_level_") || !t.endsWith("_stats")) continue;
        const n = localStorage.getItem(t), i = n ? JSON.parse(n) : [];
        Array.isArray(i) && s.push(...i);
      }
    } catch {
    }
    return s;
  }
  function Jw(s) {
    const e = Zw(), t = Array.isArray(e) ? e.filter((u) => typeof (u == null ? void 0 : u.timestamp) == "number" ? u.timestamp !== s.timestamp : true) : [];
    if (!t.length) return null;
    const n = Kg(-1, t), i = s.blocksRemoved > 0 ? s.moves / s.blocksRemoved : s.moves, r = s.moves > 0 ? s.time / s.moves : s.time, o = s.spins > 0 ? s.blocksRemoved / s.spins : s.blocksRemoved, a = Yt(i, n.medianMovesPerBlock ?? n.avgMovesPerBlock, true);
    a.percentile = Hh(i, n);
    const l = Yt(r, n.medianTimePerMove ?? n.avgTimePerMove, true);
    l.percentile = Gh(r, n);
    const c = Yt(o, n.medianBlocksPerSpin ?? n.avgBlocksPerSpin, false);
    return c.percentile = Wh(o, n), {
      available: true,
      sampleSize: t.length,
      baselineStats: n,
      efficiency: {
        movesPerBlock: {
          value: i,
          comparison: a
        },
        timePerMove: {
          value: r,
          comparison: l
        },
        blocksPerSpin: {
          value: o,
          comparison: c
        }
      }
    };
  }
  function Kw(s) {
    let e = null, t = null, n = null;
    for (const i of s) {
      const r = Number(i == null ? void 0 : i.time), o = Number(i == null ? void 0 : i.moves), a = Number(i == null ? void 0 : i.spins);
      Number.isFinite(r) && (e = e === null ? r : Math.min(e, r)), Number.isFinite(o) && (t = t === null ? o : Math.min(t, o)), Number.isFinite(a) && (n = n === null ? a : Math.min(n, a));
    }
    return {
      bestTime: e,
      bestMoves: t,
      bestSpins: n
    };
  }
  async function jw(s) {
    const e = await Jg(s.level), t = Jw(s);
    if (!e) {
      const m = $w(s.level), v = Array.isArray(m) ? m.filter((p) => typeof (p == null ? void 0 : p.timestamp) == "number" ? p.timestamp !== s.timestamp : true) : [];
      if (v.length) {
        const p = Kg(s.level, v), _ = Kw(v), x = Yt(s.time, p.medianTime, true);
        x.percentile = Bh(s.time, p);
        const b = Yt(s.moves, p.medianMoves, true);
        b.percentile = kh(s.moves, p);
        const E = Yt(s.spins, p.medianSpins, true);
        E.percentile = Vh(s.spins, p);
        const S = s.blocksRemoved > 0 ? s.moves / s.blocksRemoved : s.moves, w = s.moves > 0 ? s.time / s.moves : s.time, A = s.spins > 0 ? s.blocksRemoved / s.spins : s.blocksRemoved, M = Yt(S, p.medianMovesPerBlock ?? p.avgMovesPerBlock, true);
        M.percentile = Hh(S, p);
        const y = Yt(w, p.medianTimePerMove ?? p.avgTimePerMove, true);
        y.percentile = Gh(w, p);
        const C = Yt(A, p.medianBlocksPerSpin ?? p.avgBlocksPerSpin, false);
        C.percentile = Wh(A, p);
        const N = Vf(s, p), I = Vc({
          userStats: s,
          comparison: {
            available: true,
            source: "personal",
            time: x,
            moves: b,
            spins: E
          }
        });
        return I.earned.length && Hc({
          level: s.level,
          badgeIds: I.earned
        }), {
          available: true,
          source: "personal",
          sampleSize: v.length,
          personalBest: _,
          globalNormalized: t,
          time: x,
          moves: b,
          spins: E,
          efficiency: {
            movesPerBlock: {
              value: S,
              comparison: M
            },
            timePerMove: {
              value: w,
              comparison: y
            },
            blocksPerSpin: {
              value: A,
              comparison: C
            }
          },
          overall: N,
          communityStats: p,
          badges: I.earned,
          badgesPending: true
        };
      }
      const g = Vc({
        userStats: s,
        comparison: {
          available: false,
          source: "none"
        }
      });
      return g.earned.length && Hc({
        level: s.level,
        badgeIds: g.earned
      }), {
        available: false,
        source: "none",
        reason: "no_level_baseline",
        globalNormalized: t,
        time: null,
        moves: null,
        spins: null,
        overall: null,
        badges: g.earned,
        badgesPending: true
      };
    }
    const n = Yt(s.time, e.medianTime, true);
    n.percentile = Bh(s.time, e);
    const i = Yt(s.moves, e.medianMoves, true);
    i.percentile = kh(s.moves, e);
    const r = Yt(s.spins, e.medianSpins, true);
    r.percentile = Vh(s.spins, e);
    const o = s.blocksRemoved > 0 ? s.moves / s.blocksRemoved : s.moves, a = s.moves > 0 ? s.time / s.moves : s.time, l = s.spins > 0 ? s.blocksRemoved / s.spins : s.blocksRemoved, c = Yt(o, e.medianMovesPerBlock ?? e.avgMovesPerBlock, true);
    c.percentile = Hh(o, e);
    const u = Yt(a, e.medianTimePerMove ?? e.avgTimePerMove, true);
    u.percentile = Gh(a, e);
    const d = Yt(l, e.medianBlocksPerSpin ?? e.avgBlocksPerSpin, false);
    d.percentile = Wh(l, e);
    const h = Vf(s, e), f = Vc({
      userStats: s,
      comparison: {
        available: true,
        source: "community",
        time: n,
        moves: i,
        spins: r
      }
    });
    return f.earned.length && Hc({
      level: s.level,
      badgeIds: f.earned
    }), Bw({
      level: s.level,
      comparisonAvailable: true,
      beatMedianTime: !!(n == null ? void 0 : n.better),
      beatMedianMoves: !!(i == null ? void 0 : i.better),
      perfectRun: f.earned.includes("perfect_run") || !!(n == null ? void 0 : n.better) && !!(i == null ? void 0 : i.better)
    }), {
      available: true,
      source: "community",
      globalNormalized: t,
      time: n,
      moves: i,
      spins: r,
      efficiency: {
        movesPerBlock: {
          value: o,
          comparison: c
        },
        timePerMove: {
          value: a,
          comparison: u
        },
        blocksPerSpin: {
          value: l,
          comparison: d
        }
      },
      overall: h,
      communityStats: e,
      badges: f.earned,
      badgesPending: f.pendingCommunity
    };
  }
  async function jg() {
    try {
      const s = await Rw();
      if (s.length === 0) return;
      console.log(`Syncing ${s.length} pending submissions...`);
      const e = [];
      for (const t of s) try {
        const { id: n, retryCount: i, timestamp: r, ...o } = t;
        await qg(o), e.push(t.id || t), console.log("Synced submission:", o);
      } catch (n) {
        console.warn("Failed to sync submission:", n);
      }
      for (const t of e) typeof t == "number" && await Pw(t);
      try {
        localStorage.removeItem("jarrows_stats_queue");
      } catch {
      }
      console.log(`Synced ${e.length} of ${s.length} submissions`);
    } catch (s) {
      console.error("Error syncing pending submissions:", s);
    }
  }
  async function Qw() {
    $i() || (console.log("Online - syncing pending submissions..."), await jg());
  }
  function e1() {
    $i() || console.log("Offline - stats will be queued");
  }
  function Qg() {
    const s = [];
    try {
      for (let e = 0; e < localStorage.length; e++) {
        const t = localStorage.key(e);
        if (!t || !t.startsWith("jarrows_level_") || !t.endsWith("_stats")) continue;
        const n = t.slice(14, -6), i = Number(n);
        if (!Number.isFinite(i)) continue;
        const r = localStorage.getItem(t), o = r ? JSON.parse(r) : [];
        Array.isArray(o) && s.push({
          level: i,
          runs: o
        });
      }
    } catch {
    }
    return s.sort((e, t) => e.level - t.level), s;
  }
  function t1() {
    const s = Qg(), e = [];
    for (const { runs: o } of s) e.push(...o);
    const t = [], n = [], i = [];
    for (const o of e) {
      const a = Number((o == null ? void 0 : o.moves) || 0), l = Number((o == null ? void 0 : o.time) || 0), c = Number((o == null ? void 0 : o.spins) || 0), u = Number((o == null ? void 0 : o.blocksRemoved) || 0);
      t.push(a > 0 ? l / a : l), n.push(u > 0 ? a / u : a), i.push(c > 0 ? u / c : u);
    }
    t.sort((o, a) => o - a), n.sort((o, a) => o - a), i.sort((o, a) => o - a);
    const r = (o) => {
      if (!o.length) return null;
      const a = Math.floor(o.length / 2);
      return o.length % 2 === 1 ? o[a] : (o[a - 1] + o[a]) / 2;
    };
    return {
      tm: r(t),
      mb: r(n),
      bs: r(i),
      count: e.length,
      levels: s.length
    };
  }
  function n1() {
    qr();
    const s = document.createElement("div");
    s.id = "personal-history-modal", s.style.cssText = `
        position: fixed;
        inset: 0;
        z-index: 2600;
        background: rgba(0,0,0,0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        display: flex;
        align-items: stretch;
        justify-content: stretch;
    `;
    const e = document.createElement("div");
    e.style.cssText = `
        width: 100vw;
        height: 100vh;
        box-sizing: border-box;
        padding: calc(18px + env(safe-area-inset-top)) calc(16px + env(safe-area-inset-right)) calc(18px + env(safe-area-inset-bottom)) calc(16px + env(safe-area-inset-left));
        background: rgba(17, 24, 39, 0.55);
        border: 1px solid rgba(255,255,255,0.18);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.12), 0 20px 60px rgba(0,0,0,0.35);
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        color: rgba(255,255,255,0.92);
        font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        position: relative;
    `;
    const t = document.createElement("div");
    t.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 6px;
        background: linear-gradient(90deg, rgba(96, 165, 250, 0.9), rgba(168, 85, 247, 0.9), rgba(236, 72, 153, 0.9));
        opacity: 0.9;
    `, e.appendChild(t);
    const n = document.createElement("div");
    n.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 14px;
        margin-top: 6px;
    `;
    const i = document.createElement("div");
    i.style.cssText = "display: flex; align-items: center; gap: 10px;";
    const r = document.createElement("span");
    r.textContent = "\u{1F464}", r.style.cssText = "font-size: 24px;";
    const o = document.createElement("div");
    o.textContent = "Profile", o.style.cssText = "font-size: 16px; font-weight: 900; letter-spacing: 0.4px;", i.appendChild(r), i.appendChild(o);
    const a = document.createElement("button");
    a.type = "button", a.textContent = "Close", a.style.cssText = `
        border: 1px solid rgba(255,255,255,0.18);
        background: rgba(255,255,255,0.10);
        color: rgba(255,255,255,0.9);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 12px;
        font-weight: 800;
        cursor: pointer;
    `, a.addEventListener("click", () => s.remove()), n.appendChild(i), n.appendChild(a);
    const l = t1(), c = document.createElement("div");
    c.style.cssText = `
        padding: 12px;
        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.06);
        margin-bottom: 12px;
    `;
    const u = document.createElement("div");
    u.textContent = "All-level medians (normalized)", u.style.cssText = "font-weight: 900; font-size: 13px; margin-bottom: 8px;";
    const d = document.createElement("div");
    d.style.cssText = "display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 8px;";
    const h = (m, v) => {
      const g = document.createElement("div");
      g.style.cssText = `
            padding: 10px 10px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.10);
            text-align: center;
        `;
      const p = document.createElement("div");
      p.textContent = m, p.style.cssText = "font-size: 10px; font-weight: 800; letter-spacing: 1px; text-transform: uppercase; color: rgba(255,255,255,0.55); margin-bottom: 6px;";
      const _ = document.createElement("div");
      return _.textContent = v, _.style.cssText = "font-size: 16px; font-weight: 900; color: rgba(255,255,255,0.95);", g.appendChild(p), g.appendChild(_), g;
    };
    d.appendChild(h("T/M", typeof l.tm == "number" ? Yh(l.tm) : "\u2014")), d.appendChild(h("M/B", typeof l.mb == "number" ? jr(l.mb) : "\u2014")), d.appendChild(h("B/S", typeof l.bs == "number" ? jr(l.bs) : "\u2014"));
    const f = document.createElement("div");
    f.textContent = `${l.count || 0} runs \u2022 ${l.levels || 0} levels`, f.style.cssText = "margin-top: 8px; font-size: 11px; color: rgba(255,255,255,0.65);", c.appendChild(u), c.appendChild(d), c.appendChild(f), e.appendChild(n), e.appendChild(c), s.appendChild(e), s.addEventListener("click", (m) => {
      m.target === s && s.remove();
    }), window.addEventListener("keydown", (m) => {
      m.key === "Escape" && s.remove();
    }, {
      once: true
    }), document.body.appendChild(s);
  }
  function qr() {
    const s = document.getElementById("personal-history-modal");
    s && s.remove();
  }
  function e0({ focusLevel: s = null } = {}) {
    qr();
    const e = document.createElement("div");
    e.id = "personal-history-modal", e.style.cssText = `
        position: fixed;
        inset: 0;
        z-index: 2600;
        background: rgba(0,0,0,0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        display: flex;
        align-items: stretch;
        justify-content: stretch;
    `;
    const t = document.createElement("div");
    t.style.cssText = `
        width: 100vw;
        height: 100vh;
        box-sizing: border-box;
        padding: calc(18px + env(safe-area-inset-top)) calc(16px + env(safe-area-inset-right)) calc(18px + env(safe-area-inset-bottom)) calc(16px + env(safe-area-inset-left));
        background: rgba(17, 24, 39, 0.55);
        border: 1px solid rgba(255,255,255,0.18);
        box-shadow: inset 0 1px 0 rgba(255,255,255,0.12), 0 20px 60px rgba(0,0,0,0.35);
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        color: rgba(255,255,255,0.92);
        font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        position: relative;
    `;
    const n = document.createElement("div");
    n.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 6px;
        background: linear-gradient(90deg, rgba(96, 165, 250, 0.9), rgba(168, 85, 247, 0.9), rgba(236, 72, 153, 0.9));
        opacity: 0.9;
    `, t.appendChild(n);
    const i = document.createElement("div");
    i.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 14px;
        margin-top: 6px;
    `;
    const r = document.createElement("div");
    r.style.cssText = "display: flex; align-items: center; gap: 10px;";
    const o = document.createElement("span");
    o.textContent = "\u{1F4CA}", o.style.cssText = "font-size: 24px;";
    const a = document.createElement("div");
    a.textContent = "History", a.style.cssText = `
        font-size: 16px;
        font-weight: 900;
        letter-spacing: 0.4px;
    `, r.appendChild(o), r.appendChild(a);
    const l = document.createElement("div");
    l.style.cssText = `
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: flex-end;
    `;
    function c(w) {
      const A = document.createElement("select");
      A.style.cssText = `
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.92);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 12px;
            font-weight: 800;
            outline: none;
        `;
      for (const { value: M, label: y } of w) {
        const C = document.createElement("option");
        C.value = M, C.textContent = y, A.appendChild(C);
      }
      return A;
    }
    const u = c([
      {
        value: "this",
        label: "This level"
      },
      {
        value: "all",
        label: "All levels"
      }
    ]), d = c([
      {
        value: "newest",
        label: "Newest"
      },
      {
        value: "best_tm",
        label: "Best T/M"
      },
      {
        value: "best_mb",
        label: "Best M/B"
      },
      {
        value: "best_bs",
        label: "Best B/S"
      }
    ]);
    s == null ? u.value = "all" : u.value = "this";
    const h = document.createElement("button");
    h.type = "button", h.textContent = "Clear", h.style.cssText = `
        border: 1px solid rgba(255,255,255,0.18);
        background: rgba(255,255,255,0.08);
        color: rgba(255,255,255,0.9);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        font-weight: 800;
        cursor: pointer;
    `;
    const f = document.createElement("button");
    f.type = "button", f.textContent = "Close", f.style.cssText = `
        border: 1px solid rgba(255,255,255,0.18);
        background: rgba(255,255,255,0.10);
        color: rgba(255,255,255,0.9);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 12px;
        font-weight: 800;
        cursor: pointer;
        flex: 0 0 auto;
    `, f.addEventListener("click", qr), l.appendChild(u), l.appendChild(d), l.appendChild(h), l.appendChild(f), i.appendChild(r), i.appendChild(l);
    const m = document.createElement("div"), v = document.createElement("div");
    v.style.cssText = `
        padding: 12px;
        border-radius: 16px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.06);
        margin-bottom: 12px;
    `, m.appendChild(v);
    const g = document.createElement("div");
    m.appendChild(g);
    function p(w) {
      if (!w.length) return null;
      const A = Math.floor(w.length / 2);
      return w.length % 2 === 1 ? w[A] : (w[A - 1] + w[A]) / 2;
    }
    function _(w, A) {
      return typeof w != "number" || !Number.isFinite(w) ? "\u2014" : A === "seconds" ? Yh(w) : jr(w);
    }
    function x(w) {
      const A = [], M = [], y = [];
      for (const C of w) {
        const N = Number((C == null ? void 0 : C.moves) || 0), I = Number((C == null ? void 0 : C.time) || 0), D = Number((C == null ? void 0 : C.spins) || 0), O = Number((C == null ? void 0 : C.blocksRemoved) || 0);
        A.push(N > 0 ? I / N : I), M.push(O > 0 ? N / O : N), y.push(D > 0 ? O / D : O);
      }
      return A.sort((C, N) => C - N), M.sort((C, N) => C - N), y.sort((C, N) => C - N), {
        tm: p(A),
        mb: p(M),
        bs: p(y),
        count: w.length
      };
    }
    function b() {
      if (window.confirm("Clear all local history? This cannot be undone.")) {
        try {
          const A = [];
          for (let M = 0; M < localStorage.length; M++) {
            const y = localStorage.key(M);
            y && y.startsWith("jarrows_level_") && y.endsWith("_stats") && A.push(y);
          }
          for (const M of A) localStorage.removeItem(M);
        } catch {
        }
        S();
      }
    }
    h.addEventListener("click", b);
    function E(w) {
      const A = [];
      for (const { level: M, runs: y } of w) for (const C of y) A.push({
        level: M,
        ...C
      });
      return A;
    }
    function S() {
      const w = Qg(), A = E(w).filter((B) => typeof (B == null ? void 0 : B.timestamp) == "number"), M = u.value === "this" && Number.isFinite(s) ? A.filter((B) => B.level === s) : A, y = x(M);
      v.innerHTML = "";
      const C = document.createElement("div");
      C.textContent = u.value === "this" && Number.isFinite(s) ? `Level ${s} medians` : "All-level medians (normalized)", C.style.cssText = `
            font-weight: 900;
            font-size: 13px;
            margin-bottom: 8px;
        `;
      const N = document.createElement("div");
      N.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 8px;
        `;
      function I(B, U) {
        const G = document.createElement("div");
        G.style.cssText = `
                padding: 10px 10px;
                border-radius: 14px;
                border: 1px solid rgba(255,255,255,0.12);
                background: rgba(0,0,0,0.10);
                text-align: center;
            `;
        const V = document.createElement("div");
        V.textContent = B, V.style.cssText = `
                font-size: 10px;
                font-weight: 800;
                letter-spacing: 1px;
                text-transform: uppercase;
                color: rgba(255,255,255,0.55);
                margin-bottom: 6px;
            `;
        const K = document.createElement("div");
        return K.textContent = U, K.style.cssText = `
                font-size: 16px;
                font-weight: 900;
                color: rgba(255,255,255,0.95);
            `, G.appendChild(V), G.appendChild(K), G;
      }
      N.appendChild(I("T/M", _(y.tm, "seconds"))), N.appendChild(I("M/B", _(y.mb, "ratio"))), N.appendChild(I("B/S", _(y.bs, "ratio")));
      const D = document.createElement("div");
      if (D.textContent = y.count ? `${y.count} run${y.count === 1 ? "" : "s"}` : "No runs yet", D.style.cssText = `
            margin-top: 8px;
            font-size: 11px;
            color: rgba(255,255,255,0.65);
        `, v.appendChild(C), v.appendChild(N), v.appendChild(D), g.innerHTML = "", !M.length) {
        const B = document.createElement("div");
        B.textContent = u.value === "this" && Number.isFinite(s) ? "No runs yet for this level. Complete it once to populate." : "No local runs yet. Complete a level once to populate this history.", B.style.cssText = `
                padding: 12px;
                border-radius: 12px;
                border: 1px solid rgba(255,255,255,0.12);
                background: rgba(255,255,255,0.05);
                color: rgba(255,255,255,0.78);
                font-size: 12px;
            `, g.appendChild(B);
        return;
      }
      const O = [
        ...M
      ].sort((B, U) => {
        const G = Number(B.moves || 0), V = Number(B.time || 0), K = Number(B.spins || 0), ce = Number(B.blocksRemoved || 0), Te = G > 0 ? V / G : V, q = ce > 0 ? G / ce : G, te = K > 0 ? ce / K : ce, de = Number(U.moves || 0), oe = Number(U.time || 0), fe = Number(U.spins || 0), be = Number(U.blocksRemoved || 0), F = de > 0 ? oe / de : oe, Le = be > 0 ? de / be : de, J = fe > 0 ? be / fe : be;
        switch (d.value) {
          case "best_tm":
            return Te - F;
          case "best_mb":
            return q - Le;
          case "best_bs":
            return J - te;
          default:
            return (U.timestamp || 0) - (B.timestamp || 0);
        }
      }), z = document.createElement("div");
      z.style.cssText = `
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
        `;
      for (const B of O.slice(0, 50)) {
        const U = Number(B.moves || 0), G = Number(B.time || 0), V = Number(B.spins || 0), K = Number(B.blocksRemoved || 0), ce = U > 0 ? G / U : G, Te = K > 0 ? U / K : U, q = V > 0 ? K / V : K, te = document.createElement("div");
        te.style.cssText = `
                display: grid;
                grid-template-columns: 70px 62px 1fr ${u.value === "all" ? "56px" : ""};
                gap: 10px;
                align-items: center;
                padding: 8px 10px;
                border-radius: 12px;
                border: 1px solid rgba(255,255,255,0.10);
                background: rgba(0,0,0,0.12);
                font-size: 12px;
                color: rgba(255,255,255,0.85);
            `;
        const de = document.createElement("div");
        de.textContent = Xh(G), de.style.cssText = "font-weight: 900;";
        const oe = document.createElement("div");
        oe.textContent = `${U} mv`, oe.style.cssText = "opacity: 0.9;";
        const fe = document.createElement("div");
        if (fe.textContent = `T/M ${Yh(ce)}  \u2022  M/B ${jr(Te)}  \u2022  B/S ${jr(q)}`, fe.style.cssText = "opacity: 0.9;", te.appendChild(de), te.appendChild(oe), te.appendChild(fe), u.value === "all") {
          const be = document.createElement("div");
          be.textContent = `L${B.level}`, be.style.cssText = "opacity: 0.75; text-align: right; font-weight: 800;", te.appendChild(be);
        }
        z.appendChild(te);
      }
      g.appendChild(z);
    }
    u.addEventListener("change", S), d.addEventListener("change", S), S(), t.appendChild(i), t.appendChild(m), e.appendChild(t), e.addEventListener("click", (w) => {
      w.target === e && qr();
    }), window.addEventListener("keydown", (w) => {
      w.key === "Escape" && qr();
    }, {
      once: true
    }), document.body.appendChild(e);
  }
  function i1(s, e) {
    let t = document.getElementById("stats-comparison-section");
    if (!t) {
      t = s1();
      const i = document.querySelector(".modal-content"), r = document.querySelector(".modal-stats-grid");
      if (i && r) {
        const o = document.querySelector(".modal-actions");
        o && o.parentElement === i ? i.insertBefore(t, o) : i.appendChild(t);
      }
    }
    r1(t, s);
    const n = document.getElementById("history-button");
    n && !n.dataset.bound && (n.dataset.bound = "1", n.addEventListener("click", () => e0()));
  }
  function s1() {
    const s = document.createElement("div");
    s.id = "stats-comparison-section", s.className = "modal-comparison-section", s.style.cssText = `
        margin: 20px 0;
        padding: 16px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
    `;
    const e = document.createElement("div");
    e.className = "comparison-title", e.textContent = "Community Comparison", e.style.cssText = `
        font-size: 14px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.9);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
    `;
    const t = document.createElement("div");
    return t.className = "comparison-grid", t.style.cssText = `
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    `, s.appendChild(e), s.appendChild(t), s;
  }
  function r1(s, e, t) {
    const n = s.querySelector(".comparison-grid");
    if (!n) return;
    const i = s.querySelector(".comparison-title");
    i && i.remove(), n.innerHTML = "", e.timeCollectedLevel !== void 0 && n.appendChild(Yf("Time Collected (Level)", Xh(e.timeCollectedLevel || 0), "\u23F0")), e.timeCarriedOverLevel !== void 0 && n.appendChild(Yf("Time Carried Over (Level)", Xh(e.timeCarriedOverLevel || 0), "\u27A1\uFE0F"));
  }
  function Yf(s, e, t) {
    const n = document.createElement("div");
    n.style.cssText = `
        padding: 14px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
    `;
    const i = document.createElement("div");
    i.textContent = t, i.style.cssText = "font-size: 20px;";
    const r = document.createElement("div");
    r.textContent = s, r.style.cssText = `
        font-size: 11px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.7);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    `;
    const o = document.createElement("div");
    return o.textContent = e, o.style.cssText = `
        font-size: 18px;
        font-weight: 900;
        color: rgba(255, 255, 255, 0.95);
    `, n.appendChild(i), n.appendChild(r), n.appendChild(o), n;
  }
  function Xh(s) {
    const e = Math.floor(s / 60), t = Math.floor(s % 60);
    return `${String(e).padStart(2, "0")}:${String(t).padStart(2, "0")}`;
  }
  function Yh(s) {
    return typeof s != "number" || !Number.isFinite(s) ? "\u2014" : s < 10 ? `${s.toFixed(1)}s` : `${s.toFixed(0)}s`;
  }
  function jr(s) {
    return typeof s != "number" || !Number.isFinite(s) ? "\u2014" : s < 10 ? s.toFixed(2) : s < 100 ? s.toFixed(1) : s.toFixed(0);
  }
  function qf() {
    let s = document.getElementById("stats-offline-indicator");
    s || (s = document.createElement("div"), s.id = "stats-offline-indicator", s.textContent = "\u{1F4E1} Offline - Stats will sync when online", s.style.cssText = `
            position: fixed;
            top: 60px;
            left: 10px;
            z-index: 999;
            background: rgba(251, 191, 36, 0.9);
            color: rgba(0, 0, 0, 0.9);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        `, document.body.appendChild(s)), s.style.opacity = "1";
  }
  function o1() {
    const s = document.getElementById("stats-offline-indicator");
    s && (s.style.opacity = "0");
  }
  const t0 = "jarrows_audio_enabled";
  let ui = true, cn = null, Fu = {};
  function a1() {
    if (!cn) try {
      cn = new (window.AudioContext || window.webkitAudioContext)(), cn.state === "suspended" && cn.resume().catch((s) => {
        console.warn("Failed to resume audio context:", s);
      });
    } catch (s) {
      return console.warn("AudioContext not supported:", s), false;
    }
    return cn.state === "suspended" && cn.resume().catch((s) => {
      console.warn("Failed to resume audio context:", s);
    }), true;
  }
  async function Xc(s, e) {
    try {
      const n = await (await fetch(e)).arrayBuffer(), i = await cn.decodeAudioData(n);
      return Fu[s] = i, true;
    } catch (t) {
      return console.warn(`Failed to load sound ${s}:`, t), false;
    }
  }
  function Bu(s, e = 0.5) {
    if (!ui || !cn) return;
    const t = Fu[s];
    if (!t) {
      console.warn(`Sound ${s} not loaded`);
      return;
    }
    try {
      cn.state === "suspended" && cn.resume().catch((r) => {
        console.warn("Failed to resume audio context:", r);
      });
      const n = cn.createBufferSource(), i = cn.createGain();
      n.buffer = t, i.gain.value = e, n.connect(i), i.connect(cn.destination), n.start(0);
    } catch (n) {
      console.warn(`Failed to play sound ${s}:`, n);
    }
  }
  async function l1() {
    try {
      const s = localStorage.getItem(t0);
      ui = s !== null ? s === "true" : true;
    } catch {
      ui = true;
    }
    if (!a1()) {
      console.warn("Audio initialization failed");
      return;
    }
    await Promise.all([
      Xc("timeAdded", "/sound/time added.mp3"),
      Xc("timeRemoved", "/sound/time removed.wav"),
      Xc("levelComplete", "/sound/level complete.wav")
    ]), console.log("Audio system initialized", {
      audioEnabled: ui,
      soundsLoaded: Object.keys(Fu).length
    });
  }
  function c1() {
    ui = !ui;
    try {
      localStorage.setItem(t0, ui.toString());
    } catch (s) {
      console.warn("Failed to save audio preference:", s);
    }
    return ui;
  }
  function h1() {
    return ui;
  }
  typeof window < "u" && (window.toggleAudio = c1, window.isAudioEnabled = h1);
  const u1 = "\uFFFD\uFFFD4\0.\x007\0.\x000\0", d1 = "d9b9fd0";
  function f1(s) {
    const t = String(s).replace(/\u0000/g, "").replace(/^\uFEFF/, "").replace(/[^\x20-\x7E]/g, "").trim().match(/[0-9]+(?:\.[0-9]+)*/);
    return t ? t[0] : "";
  }
  function p1(s) {
    const e = String(s).trim().match(/[0-9a-f]+/i);
    return e ? e[0].slice(0, 12) : "";
  }
  const It = (() => {
    try {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    } catch {
      return false;
    }
  })(), $f = (() => {
    try {
      return matchMedia("(pointer: coarse)").matches;
    } catch {
      return false;
    }
  })();
  function m1() {
    try {
      const s = localStorage.getItem("jarrows_quality");
      return s === "battery" || s === "balanced" || s === "performance" ? s : "balanced";
    } catch {
      return "balanced";
    }
  }
  function n0(s) {
    return s === "performance" ? {
      activeFps: 60,
      idleFps: 30,
      dprCap: 2
    } : s === "battery" ? {
      activeFps: 60,
      idleFps: It ? 10 : 30,
      dprCap: It ? 1.45 : 2
    } : {
      activeFps: 60,
      idleFps: It ? 24 : 30,
      dprCap: It ? 1.6 : 2
    };
  }
  let ys = m1(), Ms = n0(ys);
  const qe = new xu();
  Gg(qe, 986895, 328965);
  Wg(qe);
  window.gameScene = qe;
  window.THREE = Mw;
  window.setGradientBackground = Gg;
  window.setupFog = Wg;
  window.jarrowsVersion = f1(u1);
  window.jarrowsGitSha = p1(d1);
  let yn = 2;
  const Nn = new Et(60, window.innerWidth / window.innerHeight, 0.1, 1e3), ot = new qm({
    antialias: !$f,
    powerPreference: It || $f ? "low-power" : "high-performance"
  });
  ot.setSize(window.innerWidth, window.innerHeight);
  ot.setPixelRatio(Math.min(window.devicePixelRatio || 1, Ms.dprCap));
  ot.shadowMap.enabled = true;
  ot.shadowMap.type = It ? Io : xl;
  ot.shadowMap.autoUpdate = false;
  ot.shadowMap.needsUpdate = true;
  document.body.appendChild(ot.domElement);
  let Un = false, zi = false, hn = null;
  const tl = 3;
  let mr = false, nl = 0, ir = 0, So = false;
  ot.domElement.addEventListener("mousedown", (s) => {
    if (s.button === 0) {
      mr = true, nl = s.clientX, ir = s.clientY, hn = {
        x: s.clientX,
        y: s.clientY
      }, performance.now(), Un = false, zi = false, So = false;
      return;
    }
    s.button === 2 && (s.preventDefault(), So = true, nl = s.clientX, ir = s.clientY, mr = false, Un = true, zi = true);
  }, {
    passive: false
  });
  ot.domElement.addEventListener("mousemove", (s) => {
    if (mr) {
      const e = s.clientX - nl, t = s.clientY - ir;
      or += e * Jf, $n -= t * Jf, $n = Math.max(i0, Math.min(s0, $n)), nl = s.clientX, ir = s.clientY, hn && Math.sqrt(e * e + t * t) > tl && (Un = true, zi = true);
    } else if (So) {
      const e = s.clientY - ir;
      ir = s.clientY;
      const t = Gu(Sn + e * o0);
      if (t !== Sn) {
        Sn = t, typeof window < "u" && (window.framingOffsetY = Sn), ql();
        try {
          localStorage.setItem("jarrows_framing", Sn.toString());
        } catch {
        }
      }
    } else if (hn) {
      const e = s.clientX - hn.x, t = s.clientY - hn.y;
      Math.sqrt(e * e + t * t) > tl && (Un = true, zi = true);
    }
  });
  ot.domElement.addEventListener("mouseup", (s) => {
    s.button === 0 && (mr = false), s.button === 2 && (So = false), hn = null, Un = false;
  });
  ot.domElement.addEventListener("mouseleave", () => {
    mr = false, So = false, hn = null, Un = false, zi = false;
  });
  ot.domElement.addEventListener("contextmenu", (s) => {
    s.preventDefault();
  }, {
    passive: false
  });
  ot.domElement.addEventListener("wheel", (s) => {
    s.preventDefault();
    const e = 0.1, t = 1 + (s.deltaY > 0 ? e : -e);
    Dn *= t, Dn = Math.max(Yl, Math.min(Hu, Dn));
  }, {
    passive: false
  });
  const Ct = Sw(qe), { base: ku, gridHelper: Vu } = ww(qe), ue = 7, Rt = 1, qh = new P(3.5, 0, 3.5), pn = new Ln();
  pn.name = "towerGroup";
  qe.add(pn);
  qe.remove(ku);
  qe.remove(Vu);
  ku.position.set(0, -0.1, 0);
  Vu.position.set(0, 0.01, 0);
  pn.add(ku);
  pn.add(Vu);
  let wo = new P(0, 0, 0);
  function g1() {
    if (Se.length === 0) return;
    let s = 1 / 0, e = -1 / 0;
    for (const n of Se) {
      if (n.isRemoved || n.isFalling) continue;
      const i = n.isVertical ? n.length * n.cubeSize : n.cubeSize, r = n.yOffset, o = r + i;
      s = Math.min(s, r), e = Math.max(e, o);
    }
    if (s === 1 / 0 || e === -1 / 0) return;
    const t = (s + e) / 2;
    wo.y = -t, console.log(`Tower vertically centered: minY=${s.toFixed(2)}, maxY=${e.toFixed(2)}, centerY=${t.toFixed(2)}, offsetY=${wo.y.toFixed(2)}`);
  }
  const Yl = 5, Hu = 50, i0 = -Math.PI / 2 + 0.1, s0 = Math.PI / 2 - 0.1, v1 = 2, Zf = 4, x1 = 1.3, _1 = 120, Jf = 25e-4, Kf = 4e-3;
  let Qr = 10, eo = Math.PI / 4, to = Math.PI / 4, Dn = Qr, or = eo, $n = to, Ui = Qr, Ni = eo, ci = to;
  function r0() {
    const s = ue * Rt, e = Math.sqrt(s * s * 2), t = Nn.fov * (Math.PI / 180), n = Nn.aspect, i = (e + v1) / (2 * Math.tan(t / 2) * n);
    Qr = Math.max(Yl, i), to = Math.PI / 4, eo = Math.PI / 4, Dn = Qr, or = eo, $n = to, Ui = Qr, Ni = eo, ci = to;
  }
  const Hr = new P(), jf = new P(), Qf = new P(), Yc = new P(), qc = new Bt(), y1 = new P();
  let ep = 0;
  const tp = 6.5, M1 = 2.5, b1 = 10.5, o0 = 0.02;
  function Gu(s) {
    return Math.max(M1, Math.min(b1, s));
  }
  function S1() {
    try {
      const s = localStorage.getItem("jarrows_framing"), e = s !== null ? parseFloat(s) : NaN;
      return Number.isFinite(e) ? Gu(e) : tp;
    } catch {
      return tp;
    }
  }
  let Sn = S1();
  typeof window < "u" && (window.framingOffsetY = Sn);
  function ql() {
    Hr.copy(qh).add(wo);
    const s = Ui * Math.sin(ci) * Math.cos(Ni), e = Ui * Math.cos(ci), t = Ui * Math.sin(ci) * Math.sin(Ni);
    Nn.position.set(Hr.x + s, Hr.y + e, Hr.z + t), jf.set(0, Sn, 0), Qf.copy(Hr).add(jf), Nn.lookAt(Qf), pn.position.copy(qh.clone().add(wo)), pn.rotation.set(0, 0, 0);
  }
  function w1(s, e, t, n) {
    if (!s) return;
    const i = Math.sin(t) * Math.cos(e), r = Math.cos(t), o = Math.sin(t) * Math.sin(e), a = new P(i, r, o).normalize(), l = Math.PI / 6, c = Math.tan(l), u = 30, d = new P(a.x * 0.3 + Math.sin(e + Math.PI / 4) * 0.2, a.y * 0.5 + 0.3, a.z * 0.3 + Math.cos(e + Math.PI / 4) * 0.2);
    let h = a.clone().multiplyScalar(u).add(d);
    const m = Math.sqrt(h.x * h.x + h.z * h.z) * c;
    h.y < m && (h.y = m), s.keyLight.position.copy(n.clone().add(h)), s.keyLight.shadow && s.keyLight.shadow.camera && (s.keyLight.shadow.camera.position.copy(s.keyLight.position), s.keyLight.shadow.camera.lookAt(n), s.keyLight.shadow.camera.updateMatrixWorld());
    let v = a.clone().multiplyScalar(-25);
    v.y += 6;
    const p = Math.sqrt(v.x * v.x + v.z * v.z) * c;
    v.y < p && (v.y = p), s.fillLight && s.fillLight.position.copy(n.clone().add(v));
  }
  const jt = await S0();
  await Vw();
  await l1();
  $i() || (Tr() || qf(), window.addEventListener("online", () => {
    o1();
  }), window.addEventListener("offline", () => {
    qf();
  }));
  const np = document.getElementById("history-button");
  np && np.addEventListener("click", () => e0({
    focusLevel: tt
  }));
  const ip = document.getElementById("profile-toggle");
  ip && ip.addEventListener("click", () => {
    n1();
    const s = document.getElementById("settings-menu");
    s && (s.style.display = "none");
  });
  const Se = [];
  window.gameBlocks = Se;
  window.fixOverlaps = () => {
    const s = Ew(Se, ue);
    return console.log(s.message), s;
  };
  const Gr = [
    {
      x: 1,
      z: 0
    },
    {
      x: -1,
      z: 0
    },
    {
      x: 0,
      z: 1
    },
    {
      x: 0,
      z: -1
    }
  ];
  let tt = 0, bt = false, il = false, tn = 3;
  const Wu = "jarrows_game_mode", sp = "jarrows_time_rules_seen", To = "free_flow", sl = "time_challenge";
  let ar = To;
  const $h = 30;
  let Vt = $h, Lt = false, rl = 0, Eo = 0, ol = 0, Wo = 0, Xu = 0, Ao = /* @__PURE__ */ new Set(), jn = false;
  const Co = "jarrows_progress", al = "jarrows_progress_time_challenge", Ro = "jarrows_highest_level", ll = "jarrows_storage_version", cl = "jarrows_reset_completed", sr = "2.0";
  function et() {
    return ar === sl;
  }
  function T1() {
    try {
      document.body.classList.toggle("mode-time-challenge", et());
    } catch {
    }
  }
  function E1() {
    try {
      return localStorage.getItem(Wu) === sl ? sl : To;
    } catch {
      return To;
    }
  }
  function A1(s) {
    try {
      localStorage.setItem(Wu, s);
    } catch {
    }
  }
  function nn(s, e) {
    s && (e ? Ao.add(s) : Ao.delete(s));
  }
  function a0() {
    return Ao.size > 0;
  }
  function l0(s) {
    const e = document.getElementById("timer-value"), t = document.getElementById("timer-delta");
    if (!e || !t) return;
    const n = Math.trunc(s);
    if (n === 0) return;
    const i = n > 0, r = i ? "timer-gain" : "timer-loss";
    e.classList.remove("timer-gain", "timer-loss"), e.offsetWidth, e.classList.add(r), t.textContent = (i ? `+${n}` : `${n}`) + "s", t.style.color = i ? "#7CFF9A" : "#FF7C7C", t.classList.remove("show"), t.offsetWidth, t.classList.add("show"), window.setTimeout(() => t.classList.remove("show"), 720);
  }
  function C1() {
    const s = document.getElementById("mode-select-modal"), e = document.getElementById("mode-pick-free"), t = document.getElementById("mode-pick-time");
    return !s || !e || !t ? Promise.resolve(To) : (nn("mode_select", true), s.style.display = "flex", new Promise((n) => {
      const i = (a) => {
        s.style.display = "none", e.removeEventListener("click", r), t.removeEventListener("click", o), nn("mode_select", false), n(a);
      }, r = () => i(To), o = () => i(sl);
      e.addEventListener("click", r), t.addEventListener("click", o);
    }));
  }
  function R1() {
    const s = document.getElementById("time-rules-modal"), e = document.getElementById("time-rules-ok");
    if (!s || !e) return;
    let t = false;
    try {
      t = localStorage.getItem(sp) === "1";
    } catch {
      t = false;
    }
    if (t) return;
    nn("time_rules", true), s.style.display = "flex";
    const n = () => {
      s.style.display = "none", e.removeEventListener("click", n), nn("time_rules", false);
      try {
        localStorage.setItem(sp, "1");
      } catch {
      }
    };
    e.addEventListener("click", n);
  }
  async function Yu({ forcePrompt: s = false } = {}) {
    let e = E1(), t = true;
    try {
      t = localStorage.getItem(Wu) !== null;
    } catch {
      t = true;
    }
    return (s || !t) && (e = await C1(), A1(e)), ar = e, T1(), et() && R1(), typeof window < "u" && (window.jarrowsGameMode = ar), ar;
  }
  function $l() {
    Vt = $h, ol = $h, Wo = 0, Xu = 0, rl = 0, Eo = 0, Lt = true, jn = false, nn("time_up", false);
  }
  function rp(s) {
    if (!et()) return;
    let e = 0;
    for (const n of s) e += c0(n.length);
    Vt = Math.max(30, e) + Eo, ol = Vt, Wo = 0, Eo = 0, Lt = true, jn = false, nn("time_up", false), Bn();
  }
  function c0(s) {
    return s >= 3 ? 3 : s === 2 ? 2 : 1;
  }
  function P1(s) {
    if (!et() || !Lt || jn) return;
    rl += 1;
    const e = c0(s);
    Wo += e, Xu += e, Vt += e, Bu("timeAdded", 0.6), l0(e), Bn();
  }
  function I1() {
    if (!et() || !Lt || jn) return;
    const s = Vt;
    Vt = Vt * (2 / 3);
    const e = Math.max(1, Math.ceil(s / 3));
    Bu("timeRemoved", 0.5), l0(-e), Bn();
  }
  function L1() {
    const s = document.getElementById("pause-modal");
    s && (nn("user_pause", true), s.style.display = "flex", vr = true, Fi !== null && cancelAnimationFrame(Fi), Fi = null, pi !== null && (clearTimeout(pi), pi = null));
  }
  function D1() {
    const s = document.getElementById("pause-modal");
    s && (s.style.display = "none", nn("user_pause", false), vr = false, gr = performance.now(), fl = gr, Kl());
  }
  function N1() {
    const s = document.getElementById("time-up-modal"), e = document.getElementById("time-up-summary");
    if (!s || !e) return;
    nn("time_up", true), jn = true;
    const t = Math.floor(rl / 25);
    e.innerHTML = `You reached <b>Stage ${t}</b> and removed <b>${rl}</b> blocks.`, s.style.display = "flex";
  }
  async function U1() {
    const s = document.getElementById("time-up-modal");
    if (s && (s.style.display = "none"), nn("time_up", false), jn = false, bt) return;
    const e = ol;
    Wo = 0, Zn = [], _i = 0, Xl(tt), await Jn(tt), e > 0 && (Vt = e, ol = e, Bn()), Qn();
  }
  async function O1() {
    const s = document.getElementById("time-up-modal");
    s && (s.style.display = "none"), nn("time_up", false), $l(), await Zl();
  }
  function hl() {
    try {
      localStorage.getItem(ll) !== sr && (localStorage.setItem(ll, sr), localStorage.getItem(cl) !== "true" && localStorage.setItem(cl, "true"));
      const s = et() ? al : Co;
      localStorage.setItem(s, tt.toString()), console.log(`Progress saved: Level ${tt} (${et() ? "Time Challenge" : "Free Flow"})`);
      const e = parseInt(localStorage.getItem(Ro) || "0", 10);
      return tt > e && (localStorage.setItem(Ro, tt.toString()), console.log(`New highest level reached: ${tt}`)), localStorage.getItem(s) !== tt.toString() ? (console.error("Progress save verification failed!"), false) : true;
    } catch (s) {
      return console.error("Failed to save progress:", s), s.name === "QuotaExceededError" ? console.error("localStorage quota exceeded - cannot save progress") : s.name === "SecurityError" && console.error("localStorage access denied - cannot save progress"), false;
    }
  }
  function op() {
    try {
      const s = et() ? al : Co, e = localStorage.getItem(ll), t = localStorage.getItem(cl);
      (e !== sr || e === sr && t !== "true") && (e !== sr && (console.log("Storage version mismatch, clearing all progress"), localStorage.removeItem(Co), localStorage.removeItem(al), localStorage.removeItem(Ro)), localStorage.setItem(ll, sr), localStorage.setItem(cl, "true"));
      const i = localStorage.getItem(s);
      if (i !== null && i !== "") {
        const r = parseInt(i, 10);
        if (!isNaN(r) && r >= 0) return console.log(`Progress loaded: Level ${r} (${et() ? "Time Challenge" : "Free Flow"})`), r;
        console.warn("Invalid saved level, resetting to 0"), localStorage.removeItem(s);
      }
    } catch (s) {
      console.warn("Failed to load progress:", s);
    }
    return console.log(`Starting from level 0 (no saved progress for ${et() ? "Time Challenge" : "Free Flow"})`), 0;
  }
  function z1() {
    try {
      const s = et() ? al : Co;
      return localStorage.removeItem(s), console.log(`Progress cleared - user will start from level 0 on next load (${et() ? "Time Challenge" : "Free Flow"})`), true;
    } catch (s) {
      return console.warn("Failed to clear progress:", s), false;
    }
  }
  function qu(s) {
    return s === 0 ? 3 : 10 + (s - 1) * 10;
  }
  function ap(s = 0, e = null, t = 10, n = 1, i = false) {
    const r = ue * ue, o = /* @__PURE__ */ new Set(), a = [], l = s > 0, c = t <= 50;
    function u(M, y) {
      return o.has(`${M},${y}`);
    }
    function d(M) {
      if (s === 0) return true;
      const y = e instanceof Set ? e : (e == null ? void 0 : e.cells) || null;
      if (M.isVertical) return y && y.has(`${M.gridX},${M.gridZ}`);
      {
        const C = Math.abs(M.direction.x) > 0;
        for (let N = 0; N < M.length; N++) {
          const I = M.gridX + (C ? N : 0), D = M.gridZ + (C ? 0 : N);
          if (y && y.has(`${I},${D}`)) return true;
        }
        return false;
      }
    }
    function h(M, y, C, N) {
      const I = y, D = N - 1 - y, O = M, z = N - 1 - M;
      let B = 1 / 0, U = false;
      return C.z === -1 && I < D && I < O && I < z ? (B = I, U = true) : C.z === 1 && D < I && D < O && D < z ? (B = D, U = true) : C.x === -1 && O < I && O < D && O < z ? (B = O, U = true) : C.x === 1 && z < I && z < D && z < O && (B = z, U = true), {
        canExit: U,
        distanceToEdge: B
      };
    }
    function f(M, y, C) {
      const N = y, I = C - 1 - y, D = M, O = C - 1 - M, z = Math.min(N, I, D, O);
      return z === N ? {
        x: 0,
        z: -1
      } : z === I ? {
        x: 0,
        z: 1
      } : z === D ? {
        x: -1,
        z: 0
      } : {
        x: 1,
        z: 0
      };
    }
    function m(M, y, C, N, I) {
      const D = /* @__PURE__ */ new Set(), O = N ? C * Rt : Rt, z = s, B = s + O;
      if (N) {
        const U = `${M},${y}`;
        if (o.has(U)) return null;
        if (e && typeof e == "object" && e.yRanges) {
          const G = e.yRanges.get(U);
          if (G) {
            for (const V of G) if (!(B <= V.yBottom || z >= V.yTop)) return null;
          }
        }
        D.add(U);
      } else {
        const U = Math.abs(I.x) > 0;
        for (let G = 0; G < C; G++) {
          const V = M + (U ? G : 0), K = y + (U ? 0 : G);
          if (V < 0 || V >= ue || K < 0 || K >= ue) return null;
          const ce = `${V},${K}`;
          if (o.has(ce)) return null;
          if (e && typeof e == "object" && e.yRanges) {
            const Te = e.yRanges.get(ce);
            if (Te) {
              for (const q of Te) if (!(B <= q.yBottom || z >= q.yTop)) return null;
            }
          }
          D.add(ce);
        }
      }
      for (const U of D) o.add(U);
      return {
        cells: D,
        yBottom: z,
        yTop: B
      };
    }
    if (c) {
      const M = l ? t > 100 ? 50 : 40 : t > 100 ? 20 : 10;
      let y = 0;
      for (; a.length < t && y < M; ) {
        y++;
        const C = [];
        for (let D = 0; D < ue; D++) for (let O = 0; O < ue; O++) u(D, O) || C.push({
          x: D,
          z: O
        });
        if (C.length === 0) break;
        const N = n === 0 ? 3 : 1;
        for (let D = 0; D < N; D++) for (let O = C.length - 1; O > 0; O--) {
          const z = Math.floor(Math.random() * (O + 1));
          [C[O], C[z]] = [
            C[z],
            C[O]
          ];
        }
        let I = 0;
        for (const D of C) {
          if (a.length >= t) break;
          const O = t - a.length, z = Math.random();
          let B;
          i ? z < 0.2 ? B = 1 : z < 0.7 ? B = 2 : B = 3 : O <= 5 ? z < 0.8 ? B = 1 : z < 0.95 ? B = 2 : B = 3 : z < 0.4 ? B = 1 : z < 0.8 ? B = 2 : B = 3;
          let U;
          if (Math.random() < 0.7) {
            const Te = f(D.x, D.z, ue);
            U = Math.random() < 0.8 ? Te : Gr[Math.floor(Math.random() * Gr.length)];
          } else U = Gr[Math.floor(Math.random() * Gr.length)];
          const V = Math.random() < 0.5, K = m(D.x, D.z, B, V, U);
          if (!K) continue;
          const ce = new _n(B, D.x, D.z, U, V, yn, qe, jt, ue, Rt, s, n);
          if (qe.remove(ce.group), !d(ce)) {
            for (const Te of K.cells) o.delete(Te);
            continue;
          }
          a.push(ce), I++;
        }
        if (I === 0) break;
      }
      if (a.length > 0) {
        const C = /* @__PURE__ */ new Set();
        a.forEach((N) => {
          En(N).forEach((D) => C.add(`${D.x},${D.z}`));
        }), a.sort((N, I) => {
          const D = Bf(N, C, ue), O = Bf(I, C, ue);
          if (D.canExit && !O.canExit) return -1;
          if (!D.canExit && O.canExit) return 1;
          if (D.canExit && O.canExit) return D.stepsToExit - O.stepsToExit;
          const z = h(N.gridX, N.gridZ, N.direction, ue), B = h(I.gridX, I.gridZ, I.direction, ue);
          return z.canExit && !B.canExit ? -1 : !z.canExit && B.canExit ? 1 : z.canExit && B.canExit ? z.distanceToEdge - B.distanceToEdge : 0;
        });
      }
      return a;
    }
    const v = [];
    for (let M = 0; M < ue && !(a.length >= t); M++) if (!u(M, 0)) {
      const y = Math.random() < 0.9 ? Math.floor(Math.random() * 2) + 2 : 1, C = y > 1 && Math.random() < 0.7, N = {
        x: 0,
        z: -1
      };
      if (C || y === 1) {
        const I = m(M, 0, y, C, N);
        if (I) {
          const D = new _n(y, M, 0, N, C, yn, qe, jt, ue, Rt, s, n);
          if (d(D)) {
            if (qe.remove(D.group), v.push(D), a.push(D), a.length >= t) break;
          } else {
            for (const O of I.cells) o.delete(O);
            qe.remove(D.group);
          }
        }
      }
    }
    for (let M = 0; M < ue && !(a.length >= t); M++) if (!u(M, ue - 1)) {
      const y = Math.random() < 0.9 ? Math.floor(Math.random() * 2) + 2 : 1, C = y > 1 && Math.random() < 0.7, N = {
        x: 0,
        z: 1
      };
      if (C || y === 1) {
        const I = m(M, ue - 1, y, C, N);
        if (I) {
          const D = new _n(y, M, ue - 1, N, C, yn, qe, jt, ue, Rt, s, n);
          if (d(D)) {
            if (qe.remove(D.group), v.push(D), a.push(D), a.length >= t) break;
          } else {
            for (const O of I.cells) o.delete(O);
            qe.remove(D.group);
          }
        }
      }
    }
    for (let M = 0; M < ue && !(a.length >= t); M++) if (!u(0, M)) {
      const y = Math.random() < 0.9 ? Math.floor(Math.random() * 2) + 2 : 1, C = y > 1 && Math.random() < 0.7, N = {
        x: -1,
        z: 0
      };
      if (C || y === 1) {
        const I = m(0, M, y, C, N);
        if (I) {
          const D = new _n(y, 0, M, N, C, yn, qe, jt, ue, Rt, s, n);
          if (d(D)) {
            if (qe.remove(D.group), v.push(D), a.push(D), a.length >= t) break;
          } else {
            for (const O of I.cells) o.delete(O);
            qe.remove(D.group);
          }
        }
      }
    }
    for (let M = 0; M < ue && !(a.length >= t); M++) if (!u(ue - 1, M)) {
      const y = Math.random() < 0.9 ? Math.floor(Math.random() * 2) + 2 : 1, C = y > 1 && Math.random() < 0.7, N = {
        x: 1,
        z: 0
      };
      if (C || y === 1) {
        const I = m(ue - 1, M, y, C, N);
        if (I) {
          const D = new _n(y, ue - 1, M, N, C, yn, qe, jt, ue, Rt, s, n);
          if (d(D)) {
            if (qe.remove(D.group), v.push(D), a.push(D), a.length >= t) break;
          } else {
            for (const O of I.cells) o.delete(O);
            qe.remove(D.group);
          }
        }
      }
    }
    const g = 800;
    let p = 0;
    const _ = l ? 0.98 : t > 100 ? 1 : 0.95;
    for (; p < g && o.size < r * _ && a.length < t && (p++, v.length !== 0); ) {
      const M = v[Math.floor(Math.random() * v.length)];
      if (!M || M.isFalling) continue;
      const y = {
        x: -M.direction.x,
        z: -M.direction.z
      }, C = M.gridX + y.x, N = M.gridZ + y.z;
      let I = true;
      if (M.isVertical) (C < 0 || C >= ue || N < 0 || N >= ue || u(C, N)) && (I = false);
      else {
        const z = Math.abs(M.direction.x) > 0;
        for (let B = 0; B < M.length; B++) {
          const U = C + (z ? B : 0), G = N + (z ? 0 : B);
          if (U < 0 || U >= ue || G < 0 || G >= ue) {
            I = false;
            break;
          }
          if (u(U, G)) {
            I = false;
            break;
          }
        }
      }
      if (!I || !m(C, N, M.length, M.isVertical, M.direction)) continue;
      M.gridX, M.gridZ;
      const O = En(M);
      for (const z of O) o.delete(`${z.x},${z.z}`);
      M.gridX = C, M.gridZ = N, M.updateWorldPosition();
    }
    const x = [];
    for (let M = 0; M < ue; M++) for (let y = 0; y < ue; y++) u(M, y) || x.push({
      x: M,
      z: y
    });
    for (let M = x.length - 1; M > 0; M--) {
      const y = Math.floor(Math.random() * (M + 1));
      [x[M], x[y]] = [
        x[y],
        x[M]
      ];
    }
    for (const M of x) {
      if (a.length >= t) break;
      const y = {
        east: ue - 1 - M.x,
        west: M.x,
        south: ue - 1 - M.z,
        north: M.z
      }, C = Math.min(...Object.values(y)), N = Object.entries(y).filter(([O, z]) => z === C).map(([O, z]) => O);
      let I = Gr[0];
      N.includes("east") ? I = {
        x: 1,
        z: 0
      } : N.includes("west") ? I = {
        x: -1,
        z: 0
      } : N.includes("south") ? I = {
        x: 0,
        z: 1
      } : N.includes("north") && (I = {
        x: 0,
        z: -1
      });
      const D = Math.abs(I.x) > 0;
      for (const O of [
        3,
        2,
        1
      ]) {
        if (O === 1 && Math.random() < 0.85) continue;
        let z = true;
        for (let G = 0; G < O; G++) {
          const V = M.x + (D ? G : 0), K = M.z + (D ? 0 : G);
          if (V < 0 || V >= ue || K < 0 || K >= ue) {
            z = false;
            break;
          }
          if (u(V, K)) {
            z = false;
            break;
          }
        }
        if (!z) continue;
        const B = m(M.x, M.z, O, false, I);
        if (!B) continue;
        const U = new _n(O, M.x, M.z, I, false, yn, qe, jt, ue, Rt, s, n);
        if (!d(U)) {
          for (const G of B.cells) o.delete(G);
          if (qe.remove(U.group), l && a.length < t * 0.5) {
            const G = e instanceof Set ? e : (e == null ? void 0 : e.cells) || null;
            (U.isVertical ? G && G.has(`${U.gridX},${U.gridZ}`) ? 1 : 0 : (() => {
              const K = Math.abs(U.direction.x) > 0;
              let ce = 0;
              for (let Te = 0; Te < U.length; Te++) {
                const q = U.gridX + (K ? Te : 0), te = U.gridZ + (K ? 0 : Te);
                G && G.has(`${q},${te}`) && ce++;
              }
              return ce;
            })()) === 0 && a.length % 10 === 0 && console.log(`  [Debug] Block at (${U.gridX},${U.gridZ}) rejected: no support (layer yOffset=${s})`);
          }
          continue;
        }
        if (qe.remove(U.group), a.push(U), a.length >= t) break;
        break;
      }
    }
    let b = 0;
    const E = l ? t > 100 ? 25 : 15 : t > 100 ? 10 : 3;
    for (; b < E && o.size < r && a.length < t; ) {
      b++;
      const M = o.size, y = [];
      for (let C = 0; C < ue; C++) for (let N = 0; N < ue; N++) u(C, N) || y.push({
        x: C,
        z: N
      });
      for (let C = y.length - 1; C > 0; C--) {
        const N = Math.floor(Math.random() * (C + 1));
        [y[C], y[N]] = [
          y[N],
          y[C]
        ];
      }
      for (const C of y) {
        const N = [
          {
            x: 1,
            z: 0
          },
          {
            x: -1,
            z: 0
          },
          {
            x: 0,
            z: 1
          },
          {
            x: 0,
            z: -1
          }
        ];
        for (let D = N.length - 1; D > 0; D--) {
          const O = Math.floor(Math.random() * (D + 1));
          [N[D], N[O]] = [
            N[O],
            N[D]
          ];
        }
        let I = false;
        for (const D of N) {
          for (const O of [
            2,
            3,
            1
          ]) {
            if (O === 1 && Math.random() < 0.9) continue;
            const z = Math.abs(D.x) > 0;
            let B = true;
            for (let V = 0; V < O; V++) {
              const K = C.x + (z ? V : 0), ce = C.z + (z ? 0 : V);
              if (K < 0 || K >= ue || ce < 0 || ce >= ue) {
                B = false;
                break;
              }
              if (u(K, ce)) {
                B = false;
                break;
              }
            }
            if (!B) continue;
            const U = m(C.x, C.z, O, false, D);
            if (!U) continue;
            const G = new _n(O, C.x, C.z, D, false, yn, qe, jt, ue, Rt, s, n);
            if (!d(G)) {
              for (const V of U.cells) o.delete(V);
              qe.remove(G.group);
              continue;
            }
            if (qe.remove(G.group), a.push(G), I = true, a.length >= t) break;
            break;
          }
          if (I || a.length >= t) break;
        }
      }
      if (o.size === M) break;
    }
    if (a.length < t && o.size < r) {
      t - a.length;
      const M = [];
      for (let y = 0; y < ue; y++) for (let C = 0; C < ue; C++) M.push({
        x: y,
        z: C
      });
      for (let y = M.length - 1; y > 0 && a.length < t; y--) {
        const C = Math.floor(Math.random() * (y + 1));
        [M[y], M[C]] = [
          M[C],
          M[y]
        ];
      }
      for (const y of M) {
        if (a.length >= t) break;
        const C = {
          east: ue - 1 - y.x,
          west: y.x,
          south: ue - 1 - y.z,
          north: y.z
        }, N = Math.min(...Object.values(C)), I = Object.entries(C).filter(([G, V]) => V === N).map(([G, V]) => G), D = I[Math.floor(Math.random() * I.length)];
        let O = {
          x: 0,
          z: 0
        };
        D === "east" ? O = {
          x: 1,
          z: 0
        } : D === "west" ? O = {
          x: -1,
          z: 0
        } : D === "south" ? O = {
          x: 0,
          z: 1
        } : D === "north" && (O = {
          x: 0,
          z: -1
        });
        const z = m(y.x, y.z, 1, false, O);
        if (!z) continue;
        const B = new _n(1, y.x, y.z, O, false, yn, qe, jt, ue, Rt, s, n), U = s === 0 || d(B);
        if (qe.remove(B.group), U) {
          const G = new _n(1, y.x, y.z, O, false, yn, qe, jt, ue, Rt, s, n);
          qe.remove(G.group), a.push(G);
        } else for (const G of z.cells) o.delete(G);
      }
    }
    const S = a.filter((M) => M.length === 1).length, w = a.length, A = (S / w * 100).toFixed(1);
    return console.log(`Generated puzzle with ${a.length} blocks, ${o.size}/${r} cells filled (${(o.size / r * 100).toFixed(1)}%)`), console.log(`  Single blocks: ${S}/${w} (${A}%)`), a;
  }
  function lp(s, e = 10, t = 10) {
    return new Promise((n) => {
      let i = 0;
      const r = () => {
        const o = i * e, a = Math.min(o + e, s.length);
        if (o >= s.length) {
          n();
          return;
        }
        for (let h = o; h < a; h++) {
          const f = s[h];
          if (!f) {
            console.warn(`\u26A0\uFE0F Null block at index ${h} in batch starting at ${o}`);
            continue;
          }
          f.group.scale.set(0, 0, 0), pn.add(f.group), Se.push(f);
        }
        const l = performance.now(), c = 50;
        let u = null;
        const d = () => {
          const h = i * e;
          if (!bt || s.length === 0 || h >= s.length) {
            u !== null && (cancelAnimationFrame(u), u = null);
            return;
          }
          const f = performance.now() - l, m = Math.min(f / c, 1), v = 1 - Math.pow(1 - m, 3);
          for (let g = h; g < a && g < s.length; g++) s[g] && s[g].group && s[g].group.scale.set(v, v, v);
          if (m < 1) u = requestAnimationFrame(d);
          else {
            for (let g = h; g < a && g < s.length; g++) s[g] && s[g].group && s[g].group.scale.set(1, 1, 1);
            u !== null && (cancelAnimationFrame(u), u = null), i++, setTimeout(r, t);
          }
        };
        u = requestAnimationFrame(d);
      };
      r();
    });
  }
  function F1(s = 10) {
    const e = [], t = /* @__PURE__ */ new Set(), n = [
      {
        x1: 1,
        z1: 1,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 3,
        z2: 1,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 1,
        len2: 1,
        vert1: false,
        vert2: false
      },
      {
        x1: 1,
        z1: 3,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 4,
        z2: 3,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 1,
        len2: 1,
        vert1: false,
        vert2: false
      },
      {
        x1: 0,
        z1: 5,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 3,
        z2: 5,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 2,
        len2: 2,
        vert1: false,
        vert2: false
      },
      {
        x1: 2,
        z1: 1,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 2,
        z2: 3,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 1,
        len2: 1,
        vert1: false,
        vert2: false
      },
      {
        x1: 5,
        z1: 2,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 5,
        z2: 5,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 1,
        len2: 1,
        vert1: false,
        vert2: false
      },
      {
        x1: 0,
        z1: 2,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 0,
        z2: 4,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 2,
        len2: 2,
        vert1: false,
        vert2: false
      },
      {
        x1: 3,
        z1: 2,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 5,
        z2: 2,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 2,
        len2: 2,
        vert1: true,
        vert2: true
      },
      {
        x1: 1,
        z1: 4,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 1,
        z2: 6,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 3,
        len2: 2,
        vert1: true,
        vert2: true
      },
      {
        x1: 6,
        z1: 1,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 4,
        z2: 1,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 2,
        len2: 1,
        vert1: true,
        vert2: true
      },
      {
        x1: 6,
        z1: 4,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 6,
        z2: 6,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 2,
        len2: 2,
        vert1: true,
        vert2: true
      },
      {
        x1: 0,
        z1: 0,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 6,
        z2: 0,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 3,
        len2: 2,
        vert1: true,
        vert2: true
      },
      {
        x1: 3,
        z1: 5,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 3,
        z2: 3,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 2,
        len2: 3,
        vert1: true,
        vert2: true
      },
      {
        x1: 2,
        z1: 0,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 5,
        z2: 0,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 3,
        len2: 2,
        vert1: false,
        vert2: false
      },
      {
        x1: 4,
        z1: 0,
        dir1: {
          x: 0,
          z: 1
        },
        x2: 4,
        z2: 2,
        dir2: {
          x: 0,
          z: -1
        },
        len1: 2,
        len2: 1,
        vert1: false,
        vert2: false
      },
      {
        x1: 3,
        z1: 6,
        dir1: {
          x: 1,
          z: 0
        },
        x2: 5,
        z2: 6,
        dir2: {
          x: -1,
          z: 0
        },
        len1: 1,
        len2: 1,
        vert1: false,
        vert2: false
      }
    ];
    function i(o, a) {
      return t.has(`${o},${a}`);
    }
    function r(o, a, l, c) {
      for (let u = 0; u < l; u++) {
        const d = o + (c ? u : 0), h = a + (c ? 0 : u);
        t.add(`${d},${h}`);
      }
    }
    for (const o of n) {
      if (e.length >= s) break;
      const a = Math.abs(o.dir1.x) > 0;
      let l = true;
      if (o.vert1) (o.x1 < 0 || o.x1 >= ue || o.z1 < 0 || o.z1 >= ue || i(o.x1, o.z1)) && (l = false);
      else for (let c = 0; c < o.len1; c++) {
        const u = o.x1 + (a ? c : 0), d = o.z1 + (a ? 0 : c);
        if (u < 0 || u >= ue || d < 0 || d >= ue || i(u, d)) {
          l = false;
          break;
        }
      }
      if (l) {
        o.vert1 ? t.add(`${o.x1},${o.z1}`) : r(o.x1, o.z1, o.len1, a);
        const c = o.vert1 === true;
        console.log(`Creating block1 at (${o.x1}, ${o.z1}), vert1=${o.vert1}, isVertical1=${c}, length=${o.len1}`);
        const u = new _n(o.len1, o.x1, o.z1, o.dir1, c, yn, qe, jt, ue, Rt, 0, 1);
        console.log(`Block1 created, isVertical=${u.isVertical}`), qe.remove(u.group), e.push(u);
      }
      if (e.length < s) {
        const c = Math.abs(o.dir2.x) > 0;
        let u = true;
        if (o.vert2) (o.x2 < 0 || o.x2 >= ue || o.z2 < 0 || o.z2 >= ue || i(o.x2, o.z2)) && (u = false);
        else for (let d = 0; d < o.len2; d++) {
          const h = o.x2 + (c ? d : 0), f = o.z2 + (c ? 0 : d);
          if (h < 0 || h >= ue || f < 0 || f >= ue || i(h, f)) {
            u = false;
            break;
          }
        }
        if (u) {
          o.vert2 ? t.add(`${o.x2},${o.z2}`) : r(o.x2, o.z2, o.len2, c);
          const d = o.vert2 === true;
          console.log(`Creating block2 at (${o.x2}, ${o.z2}), vert2=${o.vert2}, isVertical2=${d}, length=${o.len2}`);
          const h = new _n(o.len2, o.x2, o.z2, o.dir2, d, yn, qe, jt, ue, Rt, 0, 1);
          console.log(`Block2 created, isVertical=${h.isVertical}`), qe.remove(h.group), e.push(h);
        }
      }
    }
    for (; e.length < s; ) {
      const o = Math.floor(Math.random() * ue), a = Math.floor(Math.random() * ue);
      if (!i(o, a)) {
        const l = [
          {
            x: 1,
            z: 0
          },
          {
            x: -1,
            z: 0
          },
          {
            x: 0,
            z: 1
          },
          {
            x: 0,
            z: -1
          }
        ], c = l[Math.floor(Math.random() * l.length)], u = Math.random() < 0.5 ? 1 : Math.random() < 0.5 ? 2 : 3, d = Math.random() < 0.3, h = Math.abs(c.x) > 0;
        let f = true;
        if (d) (o < 0 || o >= ue || a < 0 || a >= ue || i(o, a)) && (f = false);
        else for (let m = 0; m < u; m++) {
          const v = o + (h ? m : 0), g = a + (h ? 0 : m);
          if (v < 0 || v >= ue || g < 0 || g >= ue || i(v, g)) {
            f = false;
            break;
          }
        }
        if (f) {
          d ? t.add(`${o},${a}`) : r(o, a, u, h);
          const m = new _n(u, o, a, c, d, yn, qe, jt, ue, Rt, 0, 1);
          qe.remove(m.group), e.push(m);
        }
      }
    }
    return e;
  }
  async function Jn(s = 1) {
    var _a2, _b2, _c2;
    if (bt) {
      console.warn("Level generation already in progress, skipping...");
      return;
    }
    bt = true, il = false, et() ? tn = Number.POSITIVE_INFINITY : tn = 3, Zi();
    for (const d of Se) d.isAnimating && (d.isAnimating = false), pn.remove(d.group), d.cubes && d.cubes.forEach((h) => {
      h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
    }), d.arrow && d.arrow.traverse((h) => {
      h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
    }), d.directionIndicators && d.directionIndicators.traverse((h) => {
      h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
    });
    Se.length = 0;
    const e = qu(s);
    if (s === 1) {
      const d = F1(e);
      await lp(d), et() && (rp(d), console.log("[Time Challenge] Level started, timeChallengeActive:", Lt, "timeLeftSec:", Vt)), bt = false;
      return;
    }
    const t = ue * ue, n = e > t;
    let i = [];
    if (n) {
      let d = e, h = 0, f = null;
      const m = Math.ceil(e / t) + 2, v = Math.max(10, m);
      for (; d > 0 && h < v; ) {
        const g = h * Rt;
        let p, _ = false;
        if (h === 0) p = Math.min(d, t), _ = true;
        else {
          d = e - i.length;
          const S = ((_a2 = f == null ? void 0 : f.cells) == null ? void 0 : _a2.size) || 0, w = Math.floor(S * 0.95), A = Math.min(t, w);
          p = Math.min(d, A), _ = false, S < 10 && d > 50 && console.warn(`\u26A0\uFE0F Layer ${h}: Only ${S} supported cells, limiting block requests`);
        }
        console.log(`  Layer ${h}: Requesting ${p} blocks (remaining: ${d}, total so far: ${i.length})`);
        const x = ap(g, f, p, s, _);
        console.log(`  Layer ${h}: Generated ${x.length} blocks (requested ${p}, difference: ${p - x.length})`);
        const b = /* @__PURE__ */ new Set(), E = /* @__PURE__ */ new Map();
        for (const S of x) {
          const w = S.cubeSize || Rt, A = S.isVertical ? S.length * w : w, M = S.yOffset || g, y = M + A;
          if (S.isVertical) {
            const C = `${S.gridX},${S.gridZ}`;
            b.add(C), E.has(C) || E.set(C, []), E.get(C).push({
              yBottom: M,
              yTop: y
            });
          } else {
            const C = Math.abs(S.direction.x) > 0;
            for (let N = 0; N < S.length; N++) {
              const I = S.gridX + (C ? N : 0), D = S.gridZ + (C ? 0 : N), O = `${I},${D}`;
              b.add(O), E.has(O) || E.set(O, []), E.get(O).push({
                yBottom: M,
                yTop: y
              });
            }
          }
        }
        if (f) {
          f instanceof Set && (f = {
            cells: f,
            yRanges: /* @__PURE__ */ new Map()
          });
          for (const S of b) f.cells.add(S);
          f.yRanges || (f.yRanges = /* @__PURE__ */ new Map());
          for (const [S, w] of E.entries()) f.yRanges.has(S) || f.yRanges.set(S, []), f.yRanges.get(S).push(...w);
        } else f = {
          cells: b,
          yRanges: E
        };
        if (i = i.concat(x), d = e - i.length, h++, i.length >= e) break;
        x.length === 0 && d > 0 && (console.warn(`\u26A0\uFE0F Layer ${h} generated 0 blocks, but ${d} blocks still needed`), console.warn(`   Lower layer has ${((_b2 = f == null ? void 0 : f.cells) == null ? void 0 : _b2.size) || 0} supported cells`)), x.length < p * 0.8 && d > 0 && (console.warn(`\u26A0\uFE0F Layer ${h} only generated ${x.length}/${p} blocks (${(x.length / p * 100).toFixed(1)}%)`), console.warn(`   Lower layer support: ${((_c2 = f == null ? void 0 : f.cells) == null ? void 0 : _c2.size) || 0} cells`), console.warn(`   Current layer occupied: ${b.size} cells`));
      }
    } else i = ap(0, null, e, s);
    console.log(`  Placing ${i.length} blocks in batches...`), await lp(i, 10, 10), console.log(`  Placement complete. Blocks array now has ${Se.length} blocks`), et() && (rp(i), console.log("[Time Challenge] Level started, timeChallengeActive:", Lt, "timeLeftSec:", Vt));
    const r = Vi(Se, ue);
    if (!r.valid) {
      console.error(`\u2717 Structure validation failed: ${r.reason}`), console.error("  Regenerating puzzle..."), bt = false, await Jn(s);
      return;
    }
    const o = document.getElementById("level-value");
    o && (o.textContent = s), setTimeout(() => {
      bt = false, console.log("  Level generation complete, support checking enabled");
      try {
        gl = performance.now() + 800, pl = 0, ml = 0, ot.shadowMap && (ot.shadowMap.needsUpdate = true);
      } catch {
      }
      g1();
    }, 1500), V1(), B1(), _i = 0, Xl(tt), Qn(), console.log(`\u2713 Generated Level ${s} puzzle using reverse generation`), console.log(`  Target blocks: ${e}, Actual blocks: ${Se.length}`), console.log("  Structure validation: \u2713 PASSED"), Se.length !== e ? console.warn(`\u26A0\uFE0F BLOCK COUNT MISMATCH: Expected ${e}, got ${Se.length} (difference: ${e - Se.length})`) : console.log(`\u2713 Block count verified: ${Se.length} blocks match target ${e}`);
    const a = Se.filter((d) => d.isVertical).length, l = Se.filter((d) => !d.isVertical).length, c = Se.filter((d) => d.length === 1).length, u = Se.filter((d) => d.length > 1).length;
    console.log(`  Block breakdown: ${a} vertical, ${l} horizontal, ${c} single-cell, ${u} multi-cell`);
  }
  let Zn = [], _i = 0, On = null, Er = 0, Gi = false;
  function ul(s) {
    const e = Math.floor(s / 60), t = Math.floor(s % 60);
    return `${String(e).padStart(2, "0")}:${String(t).padStart(2, "0")}`;
  }
  function B1() {
    Gi || (On = performance.now() / 1e3, Er = 0, Gi = true);
  }
  function k1() {
    Gi && (On !== null && (Er += performance.now() / 1e3 - On), On = null, Gi = false);
  }
  function V1() {
    On = null, Er = 0, Gi = false, Bn();
  }
  function Bn() {
    const s = document.getElementById("timer-value"), e = document.getElementById("timer-level");
    if (!s) return;
    if (e && (e.textContent = String(tt)), et() && Lt) {
      const n = Math.max(0, Math.ceil(Vt));
      s.textContent = ul(n);
      return;
    }
    let t = Er;
    Gi && On !== null && (t += performance.now() / 1e3 - On), s.textContent = ul(t);
  }
  function H1(s, e) {
    Zn.push({
      block: s,
      gridX: e.gridX,
      gridZ: e.gridZ,
      yOffset: e.yOffset,
      direction: {
        ...e.direction
      },
      isVertical: e.isVertical,
      timestamp: performance.now()
    }), _i++, Zn.length > 50 && Zn.shift(), Hw(), Qn();
  }
  typeof window < "u" && (window.recordMoveState = H1);
  function G1() {
    if (Zn.length === 0) return false;
    const s = Zn.pop(), e = s.block;
    if (!e || e.isFalling && !e.isRemoved) return false;
    if (e.isRemoved || !Se.includes(e)) {
      Se.includes(e) || Se.push(e);
      try {
        e.group && !e.group.parent && typeof pn < "u" && pn && pn.add(e.group);
      } catch {
      }
      e.isRemoved = false, e.isFalling = false, e.isAnimating = false, e.needsStop = true, e.removalStartTime = null, e.updateMeltAnimation = null;
      try {
        e.cubes && e.cubes[0] && (e.cubes[0].castShadow = true, e.cubes[0].receiveShadow = true);
      } catch {
      }
      try {
        e.wasCatapulted = false, e._catapultShadowSuppressed = false, e._catapultRestStartMs = 0;
      } catch {
      }
      e.physicsBody = null, e.physicsCollider = null, e.needsPhysicsBody = false, e.pendingAngularVel = null, e.pendingLinearVel = null, e.group && (e.group.scale.set(1, 1, 1), e.group.rotation.set(0, 0, 0), e.group.quaternion.set(0, 0, 0, 1));
    }
    return e.needsStop = true, e.isAnimating = false, e.gridX = s.gridX, e.gridZ = s.gridZ, e.yOffset = s.yOffset ?? e.yOffset, e.direction = s.direction, e.isVertical = s.isVertical, e.group.scale.set(1, 1, 1), e.updateWorldPosition(), typeof e.updateArrowRotation == "function" && e.updateArrowRotation(), _i = Math.max(0, _i - 1), true;
  }
  async function W1() {
    if (et()) {
      await Zl();
      return;
    }
    tn = 3, Zi(), !bt && (Zn = [], _i = 0, Xl(tt), await Jn(tt));
  }
  async function Zl() {
    bt || (tt = 0, il = false, Zn = [], _i = 0, tn = et() ? Number.POSITIVE_INFINITY : 3, Zi(), z1(), h0(), Xl(tt), await Jn(tt));
  }
  function X1(s) {
    const e = document.getElementById("level-complete-modal"), t = document.getElementById("level-complete-message"), n = document.getElementById("level-complete-level"), i = document.getElementById("level-complete-time"), r = document.getElementById("level-complete-moves"), o = document.getElementById("level-complete-blocks");
    if (e) {
      t && (t.textContent = ""), n && (n.textContent = String(s)), et() && Lt && nn("level_complete", true);
      let a = "00:00";
      if (et() && Lt) a = ul(Math.max(0, Math.ceil(Vt)));
      else {
        let c = Er;
        Gi && On !== null && (c += performance.now() / 1e3 - On), a = ul(c);
      }
      i && (i.textContent = a), r && (r.textContent = String(_i));
      const l = qu(s);
      o && (o.textContent = String(l)), et() && Lt && (Eo = Math.max(0, Vt)), Bu("levelComplete", 0.7), e.style.display = "flex";
    }
  }
  function h0() {
    const s = document.getElementById("level-complete-modal");
    s && (s.style.display = "none"), et() && Lt && nn("level_complete", false);
  }
  const cp = document.getElementById("next-level-button");
  cp && cp.addEventListener("click", async () => {
    h0(), tt++, Zn = [], _i = 0, hl(), await Jn(tt);
  });
  typeof window < "u" && (window.debugMoveMode = !!window.debugMoveMode, window.debugNonMovingReports = Array.isArray(window.debugNonMovingReports) ? window.debugNonMovingReports : []);
  function Y1(s) {
    try {
      if (typeof structuredClone == "function") return structuredClone(s);
    } catch {
    }
    try {
      return JSON.parse(JSON.stringify(s));
    } catch {
      return s;
    }
  }
  function q1(s, e) {
    try {
      const t = new Blob([
        JSON.stringify(s, null, 2)
      ], {
        type: "application/json"
      }), n = URL.createObjectURL(t), i = document.createElement("a");
      i.href = n, i.download = e, document.body.appendChild(i), i.click(), i.remove(), URL.revokeObjectURL(n);
    } catch (t) {
      console.warn("Failed to download debug JSON:", t);
    }
  }
  function hp(s, e, t) {
    if (s.isVertical) return [
      {
        x: e,
        z: t
      }
    ];
    const n = Math.abs(s.direction.x) > 0, i = [];
    for (let r = 0; r < s.length; r++) i.push({
      x: e + (n ? r : 0),
      z: t + (n ? 0 : r)
    });
    return i;
  }
  function $1(s, e, t) {
    const n = (t == null ? void 0 : t.gridX) ?? s.gridX, i = (t == null ? void 0 : t.gridZ) ?? s.gridZ, r = n + s.direction.x, o = i + s.direction.z, a = hp(s, r, o), l = s.isVertical ? s.length * s.cubeSize : s.cubeSize, c = (t == null ? void 0 : t.yOffset) ?? s.yOffset, u = c + l, d = [];
    for (const h of e) {
      if (!h || h === s || h.isFalling || h.isRemoved || h.removalStartTime) continue;
      const f = h.isVertical ? h.length * h.cubeSize : h.cubeSize, m = h.yOffset, v = m + f, g = u > m && c < v;
      if (!g) continue;
      const p = hp(h, h.gridX, h.gridZ);
      let _ = null;
      for (const E of a) if (p.some((S) => S.x === E.x && S.z === E.z)) {
        _ = E;
        break;
      }
      if (!_) continue;
      const x = s.direction.x === -h.direction.x && s.direction.z === -h.direction.z, b = x;
      d.push({
        other: {
          gridX: h.gridX,
          gridZ: h.gridZ,
          yOffset: h.yOffset,
          isVertical: h.isVertical,
          length: h.length,
          direction: h.direction ? {
            ...h.direction
          } : null
        },
        overlappingCell: _,
        yRangesOverlap_move: g,
        thisYRange: {
          bottom: c,
          top: u,
          height: l
        },
        otherYRange: {
          bottom: m,
          top: v,
          height: f
        },
        directionsOpposed: x,
        headOnAllowed: b
      });
    }
    return {
      nextBase: {
        x: r,
        z: o
      },
      nextCells: a,
      blockers: d
    };
  }
  function Z1(s) {
    var _a2, _b2, _c2;
    const e = s == null ? void 0 : s.physicsBody;
    if (!e) return null;
    try {
      const t = (_a2 = e.translation) == null ? void 0 : _a2.call(e), n = (_b2 = e.linvel) == null ? void 0 : _b2.call(e), i = (_c2 = e.angvel) == null ? void 0 : _c2.call(e), r = typeof e.isSleeping == "function" ? e.isSleeping() : void 0;
      return {
        translation: t ? {
          x: t.x,
          y: t.y,
          z: t.z
        } : null,
        linvel: n ? {
          x: n.x,
          y: n.y,
          z: n.z
        } : null,
        angvel: i ? {
          x: i.x,
          y: i.y,
          z: i.z
        } : null,
        isSleeping: r
      };
    } catch (t) {
      return {
        error: String((t == null ? void 0 : t.message) || t)
      };
    }
  }
  function J1(s) {
    var _a2, _b2, _c2, _d2, _e;
    if (typeof window > "u") return;
    window.debugNonMovingReports.push(s), console.groupCollapsed(`[DEBUG] Non-moving block click @ (${(_a2 = s.block) == null ? void 0 : _a2.gridX},${(_b2 = s.block) == null ? void 0 : _b2.gridZ}) y=${(_c2 = s.block) == null ? void 0 : _c2.yOffset} len=${(_d2 = s.block) == null ? void 0 : _d2.length} vertical=${(_e = s.block) == null ? void 0 : _e.isVertical} result=${s.canMoveResult}`), console.log(s), console.groupEnd();
    const e = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    q1(s, `jarrows_non_moving_${e}.json`);
  }
  const up = document.getElementById("restart-level-button");
  up && up.addEventListener("click", async () => {
    await W1(), Qn();
  });
  const dp = document.getElementById("new-game-button");
  dp && dp.addEventListener("click", async () => {
    await Yu({
      forcePrompt: true
    }), et() ? ($l(), tn = Number.POSITIVE_INFINITY) : (Lt = false, Ao = /* @__PURE__ */ new Set(), jn = false, tn = 3), Zi(), Bn(), await Zl(), Qn();
  });
  const fp = document.getElementById("undo-button");
  fp && fp.addEventListener("click", (s) => {
    s.preventDefault(), s.stopPropagation(), G1() && Qn();
  });
  function Zi() {
    const s = document.getElementById("spin-counter");
    s && (et() ? s.textContent = "\u221E" : s.textContent = tn.toString());
    const e = document.getElementById("dice-button");
    e && (!et() && tn === 0 ? (e.disabled = true, e.style.opacity = "0.5", e.style.cursor = "not-allowed") : (e.disabled = false, e.style.opacity = "1", e.style.cursor = "pointer"));
  }
  function K1() {
    if (et() && a0()) return;
    if (!et() && tn <= 0) {
      console.log("No spins remaining");
      return;
    }
    console.log("spinRandomBlocks called, total blocks:", Se.length);
    const s = Se.filter((e) => (e.isVertical || e.length === 1 || !e.isVertical && e.length > 1) && !e.isFalling && !e.isRemoved && !e.removalStartTime && !e.isAnimating);
    if (console.log("Eligible blocks found:", s.length), s.length === 0) {
      console.log("No eligible blocks to spin");
      return;
    }
    et() && Lt && !jn ? I1() : (tn--, Zi()), Gw(), s.forEach((e, t) => {
      const r = 1800 + (Math.random() * 2 - 1) * 200, o = t * 20;
      setTimeout(() => {
        try {
          console.log("Spinning block:", {
            isVertical: e.isVertical,
            length: e.length
          }), typeof e.animateRandomSpin == "function" ? e.animateRandomSpin(r) : console.error("Block does not have animateRandomSpin method!", e);
        } catch (a) {
          console.error("Error spinning block:", a);
        }
      }, o);
    });
  }
  const pp = document.getElementById("pause-button");
  pp && pp.addEventListener("click", (s) => {
    s.preventDefault(), s.stopPropagation(), L1();
  });
  const mp = document.getElementById("pause-resume");
  mp && mp.addEventListener("click", (s) => {
    s.preventDefault(), s.stopPropagation(), D1();
  });
  const gp = document.getElementById("mode-toggle");
  gp && gp.addEventListener("click", async (s) => {
    s.preventDefault(), s.stopPropagation();
    const e = ar;
    await Yu({
      forcePrompt: true
    }), ar !== e && (et() ? ($l(), tn = Number.POSITIVE_INFINITY) : (Lt = false, Ao = /* @__PURE__ */ new Set(), jn = false, tn = 3), Zi(), Bn(), await Zl());
  });
  const vp = document.getElementById("time-up-restart-level");
  vp && vp.addEventListener("click", async (s) => {
    s.preventDefault(), s.stopPropagation(), await U1();
  });
  const xp = document.getElementById("time-up-new-game");
  xp && xp.addEventListener("click", async (s) => {
    s.preventDefault(), s.stopPropagation(), await O1();
  });
  function Zh() {
    const s = document.getElementById("dice-button");
    s ? (console.log("Dice button found, attaching handler"), Zi(), s.addEventListener("click", (e) => {
      e.preventDefault(), e.stopPropagation(), console.log("Dice button clicked!"), K1();
    })) : (console.error("Dice button not found! Retrying..."), setTimeout(Zh, 100));
  }
  document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", Zh) : Zh();
  function Qn() {
    const s = document.getElementById("undo-button");
    if (!s) return;
    const t = Array.isArray(Se) && Se.length > 0 ? Se.some((i) => i && (i.isFalling || i.isAnimating || i.removalStartTime)) : false, n = Zn.length > 0 && !bt && !t;
    s.disabled = !n, s.style.opacity = n ? "1" : "0.5", s.style.cursor = n ? "pointer" : "not-allowed";
  }
  typeof window < "u" && (window.updateUndoButtonState = Qn);
  r0();
  ql();
  (async function() {
    await Yu({
      forcePrompt: false
    }), et() ? (tt = op(), $l(), tn = Number.POSITIVE_INFINITY) : (tt = op(), Lt = false, tn = 3), Zi(), Bn(), await Jn(tt);
  })();
  Qn();
  Bn();
  window.puzzleSolution = null;
  window.solutionStep = 0;
  function Jl() {
    for (const e of Se) e.setHighlight && e.setHighlight(false);
    if (!window.puzzleSolution || window.solutionStep >= window.puzzleSolution.length) {
      console.log("\u2713 Solution complete! All blocks cleared.");
      return;
    }
    const s = window.puzzleSolution[window.solutionStep];
    Se.includes(s) && !s.isFalling && !s.isRemoved ? (console.log(`\u2192 Step ${window.solutionStep + 1}/${window.puzzleSolution.length}: Highlighting block at (${s.gridX}, ${s.gridZ})`), s.setHighlight(true), console.log("  \u2713 Block highlighted! Look for the bright YELLOW block"), console.log(`  Block properties: length=${s.length}, vertical=${s.isVertical}, dir=(${s.direction.x}, ${s.direction.z})`)) : (console.warn("Block from solution already moved, advancing to next step"), window.solutionStep++, Jl());
  }
  const dl = new kg(), lr = new ee();
  function j1(s) {
    if (s.button !== 0) return;
    if (zi || Un) {
      zi = false, Un = false, hn = null;
      return;
    }
    if (hn) {
      const d = s.clientX - hn.x, h = s.clientY - hn.y;
      if (Math.sqrt(d * d + h * h) > tl) {
        hn = null;
        return;
      }
    }
    hn = null, Un = false, zi = false, lr.x = s.clientX / window.innerWidth * 2 - 1, lr.y = -(s.clientY / window.innerHeight) * 2 + 1, dl.setFromCamera(lr, Nn);
    const e = [];
    for (const d of Se) {
      if (d.isAnimating || d.isFalling) continue;
      const h = dl.intersectObjects(d.cubes, true);
      for (const f of h) e.push({
        intersection: f,
        block: d,
        distance: f.distance
      });
    }
    if (e.length === 0) return;
    e.sort((d, h) => d.distance - h.distance);
    const n = e[0].block, i = document.getElementById("settings-menu");
    if (i && i.classList.remove("show"), window.puzzleSolution && window.solutionStep < window.puzzleSolution.length) {
      const d = window.puzzleSolution[window.solutionStep];
      n === d ? console.log(`\u2713 Correct! Moving block at step ${window.solutionStep + 1}/${window.puzzleSolution.length}`) : (console.warn(`\u2717 Wrong block! Expected block at (${d.gridX}, ${d.gridZ}), clicked (${n.gridX}, ${n.gridZ})`), console.warn("  You can still move it, but it may not match the solution path"));
    }
    const r = Vi(Se, ue);
    if (!r.valid) {
      console.warn("Puzzle structure invalid before move, skipping:", r.reason), console.warn("This may indicate a bug in the movement logic or puzzle generation.");
      const d = Qa(Se, ue);
      if (d.fixed) console.warn(`Fixed ${d.movedBlocks.length} overlapping block(s). Please click again.`);
      else {
        d.failedOverlaps && d.failedOverlaps.length > 0 ? console.error(`Failed to fix ${d.failedOverlaps.length} overlap(s) - manual intervention may be needed.`, d.failedOverlaps) : console.error("Failed to fix overlaps - structure still invalid after fix attempt");
        const h = tt;
        console.warn(`Attempting to regenerate level ${h} to recover from invalid state...`), setTimeout(async () => {
          tt = h, await Jn(h), hl();
        }, 500);
      }
      return;
    }
    const o = typeof window < "u" && !!window.debugMoveMode, a = {
      gridX: n.gridX,
      gridZ: n.gridZ,
      yOffset: n.yOffset,
      direction: n.direction ? {
        ...n.direction
      } : null,
      length: n.length,
      isVertical: n.isVertical,
      isAnimating: n.isAnimating,
      isFalling: n.isFalling,
      isRemoved: n.isRemoved,
      removalStartTime: n.removalStartTime ?? null
    };
    let l = null;
    o && (window.debugMoveInfo = null);
    const c = n.canMove(Se), u = c === "fall";
    if (o && (l = Y1(window.debugMoveInfo)), n.move(Se, ue), o) {
      const d = {
        gridX: n.gridX,
        gridZ: n.gridZ,
        yOffset: n.yOffset,
        direction: n.direction ? {
          ...n.direction
        } : null,
        isAnimating: n.isAnimating,
        isFalling: n.isFalling,
        isRemoved: n.isRemoved,
        removalStartTime: n.removalStartTime ?? null
      };
      if (!(d.isAnimating || d.isFalling || d.gridX !== a.gridX || d.gridZ !== a.gridZ || !!d.removalStartTime)) {
        const f = $1(n, Se, a), m = {
          meta: {
            kind: "non_moving_block_click",
            timestamp: Date.now(),
            userAgent: typeof navigator < "u" ? navigator.userAgent : null
          },
          input: {
            click: {
              x: (s == null ? void 0 : s.clientX) ?? null,
              y: (s == null ? void 0 : s.clientY) ?? null
            }
          },
          canMoveResult: c,
          preAttempt: a,
          postAttempt: d,
          block: {
            gridX: n.gridX,
            gridZ: n.gridZ,
            yOffset: n.yOffset,
            length: n.length,
            isVertical: n.isVertical,
            direction: n.direction ? {
              ...n.direction
            } : null,
            isAnimating: n.isAnimating,
            isFalling: n.isFalling,
            isRemoved: n.isRemoved
          },
          support: {
            hasSupport: typeof _p == "function" ? _p(n, Se) : null
          },
          physics: {
            blockBody: Z1(n)
          },
          diagnostics: {
            canMoveDebugInfo: l,
            moveFirstStepApprox: f
          }
        };
        J1(m);
      }
    }
    setTimeout(() => {
      if (!Vi(Se, ue).valid) {
        console.warn("Overlap detected after move, attempting to fix...");
        const h = Qa(Se, ue);
        if (h.fixed) console.log(`Fixed ${h.movedBlocks.length} overlapping block(s)`);
        else {
          h.failedOverlaps && h.failedOverlaps.length > 0 ? console.error(`Failed to fix ${h.failedOverlaps.length} overlap(s) after move`, h.failedOverlaps) : console.error("Failed to fix overlaps after move - structure still invalid");
          const f = tt;
          console.warn(`Regenerating level ${f} to recover from post-move overlap...`), setTimeout(async () => {
            tt = f, await Jn(f), hl();
          }, 500);
        }
      }
    }, 100), setTimeout(() => {
      Po(Se), setTimeout(() => {
        Po(Se);
      }, 500);
    }, 400), Qn(), u && window.puzzleSolution && setTimeout(() => {
      (!Se.includes(n) || n.isFalling) && (window.solutionStep++, Jl());
    }, 1e3);
  }
  function _p(s, e) {
    if (s.yOffset === 0) return true;
    const t = En(s);
    for (const n of t) {
      let i = false;
      for (const r of e) {
        if (r === s || r.isFalling || r.isRemoved || r.yOffset >= s.yOffset) continue;
        const o = r.isVertical ? r.length * r.cubeSize : r.cubeSize;
        if (r.yOffset + o < s.yOffset - 0.01) continue;
        const l = En(r);
        for (const c of l) if (c.x === n.x && c.z === n.z) {
          i = true;
          break;
        }
        if (i) break;
      }
      if (i) return true;
    }
    return false;
  }
  function Po(s) {
    if (bt || window.supportCheckingEnabled === false) return;
    const e = s.filter((r) => r.isRemoved || r.isFalling || r.isAnimating ? false : r.yOffset > 0), t = /* @__PURE__ */ new Set();
    let n = true;
    for (; n; ) {
      n = false;
      for (const r of e) t.has(r) || Q1(r, s, t) || (t.add(r), n = true);
    }
    if (t.size === 0) return;
    const i = eT(s, t);
    for (const [r, o] of i.entries()) o >= r.yOffset || (console.log(`Block at (${r.gridX}, ${r.gridZ}) yOffset=${r.yOffset} lost support, falling to yOffset=${o}`), tT(r, o));
  }
  function Q1(s, e, t) {
    if (s.yOffset === 0) return true;
    const n = En(s);
    for (const i of n) {
      let r = false;
      for (const o of e) {
        if (o === s || o.isFalling || o.isRemoved || t && t.has(o) || o.yOffset >= s.yOffset) continue;
        const a = o.isVertical ? o.length * o.cubeSize : o.cubeSize;
        if (o.yOffset + a < s.yOffset - 0.01) continue;
        const c = En(o);
        for (const u of c) if (u.x === i.x && u.z === i.z) {
          r = true;
          break;
        }
        if (r) break;
      }
      if (r) return true;
    }
    return false;
  }
  function eT(s, e) {
    const t = Array.from(e);
    t.sort((r, o) => r.yOffset - o.yOffset);
    const n = /* @__PURE__ */ new Map(), i = (r) => {
      const o = n.has(r) ? n.get(r) : r.yOffset, a = r.isVertical ? r.length * r.cubeSize : r.cubeSize;
      return o + a;
    };
    for (const r of t) {
      const o = En(r);
      let a = 0;
      for (const l of o) {
        let c = 0;
        for (const u of s) {
          if (u === r || u.isFalling || u.isRemoved) continue;
          const d = e.has(u);
          if (d && !n.has(u) || (d ? n.get(u) : u.yOffset) >= r.yOffset) continue;
          const f = En(u);
          let m = false;
          for (const g of f) if (g.x === l.x && g.z === l.z) {
            m = true;
            break;
          }
          if (!m) continue;
          const v = i(u);
          v > c && (c = v);
        }
        c > a && (a = c);
      }
      a = Math.min(a, r.yOffset), n.set(r, a);
    }
    return n;
  }
  function tT(s, e) {
    if (s.isFalling || s.isRemoved || s.isAnimating || e >= s.yOffset) return;
    s.isAnimating = true;
    const t = s.yOffset, n = performance.now(), i = t - e, l = Math.min(450, Math.max(80, Math.sqrt(2 * Math.max(1e-4, i) / 85) * 1e3));
    let c = null;
    const u = () => {
      if (s.isRemoved || !Se.includes(s) || bt) {
        c !== null && cancelAnimationFrame(c), s.isAnimating = false;
        return;
      }
      const d = performance.now() - n, h = Math.min(d / l, 1), f = h * h;
      s.yOffset = t + (e - t) * f, s.updateWorldPosition(), h < 1 ? c = requestAnimationFrame(u) : (s.yOffset = e, s.updateWorldPosition(), s.isAnimating = false, c = null);
    };
    c = requestAnimationFrame(u);
  }
  window.addEventListener("click", (s) => {
  }, {
    capture: true,
    passive: true
  });
  window.addEventListener("touchstart", (s) => {
    if (s.touches.length === 1) {
      const e = s.touches[0];
      Wn = {
        x: e.clientX,
        y: e.clientY
      }, $u = performance.now();
    }
  }, {
    capture: true,
    passive: true
  });
  window.addEventListener("click", j1);
  let He = {
    isActive: false,
    touches: [],
    startDistance: 0,
    startCenter: null,
    lastCenter: null,
    isPinching: false,
    hadDoubleTouch: false
  };
  ot.domElement.addEventListener("touchstart", (s) => {
    if (s.preventDefault(), He.touches = Array.from(s.touches), He.isActive = true, He.hadDoubleTouch = false, He.touches.length === 1) {
      const e = He.touches[0];
      He.lastCenter = {
        x: e.clientX,
        y: e.clientY
      }, Wn = {
        x: e.clientX,
        y: e.clientY
      }, $u = performance.now(), Un = false;
    } else if (He.touches.length === 2) {
      He.hadDoubleTouch = true;
      const e = He.touches[0], t = He.touches[1], n = t.clientX - e.clientX, i = t.clientY - e.clientY;
      He.startDistance = Math.sqrt(n * n + i * i), He.startCenter = {
        x: (e.clientX + t.clientX) / 2,
        y: (e.clientY + t.clientY) / 2
      }, He.lastCenter = He.startCenter, He.isPinching = false;
    }
  }, {
    passive: false
  });
  ot.domElement.addEventListener("touchmove", (s) => {
    if (s.preventDefault(), !He.isActive) return;
    const e = Array.from(s.touches);
    if (e.length === 1 && He.touches.length === 1) {
      const t = e[0], n = He.touches[0], i = t.clientX - n.clientX, r = t.clientY - n.clientY;
      or += i * Kf, $n -= r * Kf, $n = Math.max(i0, Math.min(s0, $n)), He.touches = e, Wn && Math.sqrt(i * i + r * r) > tl && (Un = true);
    } else if (e.length === 2 && He.touches.length === 2) {
      He.hadDoubleTouch = true;
      const t = e[0], n = e[1], i = n.clientX - t.clientX, r = n.clientY - t.clientY, o = Math.sqrt(i * i + r * r), a = Math.abs(o - He.startDistance) / He.startDistance, l = {
        x: (t.clientX + n.clientX) / 2,
        y: (t.clientY + n.clientY) / 2
      };
      if (a > 0.05) {
        He.isPinching || (He.isPinching = true);
        const u = o / He.startDistance;
        Dn /= u, Dn = Math.max(Yl, Math.min(Hu, Dn)), He.startDistance = o;
      } else {
        He.isPinching = false;
        const u = l.y - He.lastCenter.y, d = Gu(Sn + u * o0);
        if (d !== Sn) {
          Sn = d, typeof window < "u" && (window.framingOffsetY = Sn), ql();
          try {
            localStorage.setItem("jarrows_framing", Sn.toString());
          } catch {
          }
        }
        He.startDistance = o;
      }
      He.lastCenter = l, He.touches = e;
    }
  }, {
    passive: false
  });
  ot.domElement.addEventListener("touchend", (s) => {
    s.preventDefault();
    const e = Array.from(s.touches);
    if (e.length === 0) He.isActive = false, He.touches = [], He.isPinching = false;
    else if (e.length === 1) {
      He.touches = e;
      const t = e[0];
      He.lastCenter = {
        x: t.clientX,
        y: t.clientY
      };
    }
  }, {
    passive: false
  });
  let Wn = null, $u = null;
  const nT = 5;
  function iT(s) {
    if (He.hadDoubleTouch) {
      s.touches.length === 0 && (He.hadDoubleTouch = false), Wn = null;
      return;
    }
    if (s.touches.length > 0 || s.changedTouches.length !== 1) {
      Wn = null;
      return;
    }
    const e = s.changedTouches[0];
    if (Wn) {
      const l = e.clientX - Wn.x, c = e.clientY - Wn.y, u = Math.sqrt(l * l + c * c), d = performance.now() - $u;
      if (u > nT || d > 300) {
        Wn = null;
        return;
      }
    }
    Wn = null, lr.x = e.clientX / window.innerWidth * 2 - 1, lr.y = -(e.clientY / window.innerHeight) * 2 + 1, dl.setFromCamera(lr, Nn);
    const t = [];
    for (const l of Se) {
      if (l.isAnimating || l.isFalling) continue;
      const c = dl.intersectObjects(l.cubes, true);
      for (const u of c) t.push({
        intersection: u,
        block: l,
        distance: u.distance
      });
    }
    if (t.length === 0) return;
    t.sort((l, c) => l.distance - c.distance);
    const i = t[0].block, r = document.getElementById("settings-menu");
    r && r.classList.remove("show");
    const o = Vi(Se, ue);
    o.valid || (console.warn("Puzzle structure invalid before move, skipping:", o.reason), console.warn("This may indicate a bug in the movement logic or puzzle generation."));
    const a = i.canMove(Se) === "fall";
    i.move(Se, ue), setTimeout(() => {
      if (!Vi(Se, ue).valid) {
        console.warn("Overlap detected after move, attempting to fix...");
        const c = Qa(Se, ue);
        if (c.fixed) console.log(`Fixed ${c.movedBlocks.length} overlapping block(s)`);
        else {
          c.failedOverlaps && c.failedOverlaps.length > 0 ? console.error(`Failed to fix ${c.failedOverlaps.length} overlap(s) after move`, c.failedOverlaps) : console.error("Failed to fix overlaps after move - structure still invalid");
          const u = tt;
          console.warn(`Regenerating level ${u} to recover from post-move overlap...`), setTimeout(async () => {
            tt = u, await Jn(u), hl();
          }, 500);
        }
      }
    }, 100), setTimeout(() => {
      Po(Se), setTimeout(() => {
        Po(Se);
      }, 500);
    }, 400), Qn(), a && window.puzzleSolution && setTimeout(() => {
      (!Se.includes(i) || i.isFalling) && (window.solutionStep++, Jl());
    }, 1e3);
  }
  window.addEventListener("touchend", iT, {
    passive: true
  });
  window.addEventListener("resize", () => {
    Nn.aspect = window.innerWidth / window.innerHeight, Nn.updateProjectionMatrix(), ot.setSize(window.innerWidth, window.innerHeight), !bt && Se.length === 0 && r0();
  });
  let gr = performance.now(), $c = false, yp = 0;
  const sT = 200;
  let Zu = 1e3 / Ms.activeFps, u0 = 1e3 / Ms.idleFps, Jh = Zu, fl = performance.now(), Fi = null, pi = null, vr = false, Mp = 0;
  const rT = 250;
  let pl = 0, Kh = It ? 80 : 33, ml = 0, jh = It ? 80 : 33, gl = 0;
  const d0 = It ? 600 : 350;
  let Zc = 0, Jc = performance.now(), oT = 500;
  const bp = document.getElementById("fps-counter");
  function f0(s) {
    ys = s === "battery" || s === "balanced" || s === "performance" ? s : "balanced", Ms = n0(ys), Zu = 1e3 / Ms.activeFps, u0 = 1e3 / Ms.idleFps, ot.setPixelRatio(Math.min(window.devicePixelRatio || 1, Ms.dprCap)), It && (ys === "performance" ? (Kh = 33, jh = 33, ot.shadowMap.type = xl, Ct && Ct.keyLight && Ct.keyLight.shadow && (Ct.keyLight.shadow.mapSize.set(2048, 2048), Ct.keyLight.shadow.radius = 3, Ct.keyLight.shadow.map && (Ct.keyLight.shadow.map.dispose(), Ct.keyLight.shadow.map = null), ot.shadowMap.needsUpdate = true)) : (Kh = 80, jh = 80, ot.shadowMap.type = Io, Ct && Ct.keyLight && Ct.keyLight.shadow && (Ct.keyLight.shadow.mapSize.set(1024, 1024), Ct.keyLight.shadow.radius = 1, Ct.keyLight.shadow.map && (Ct.keyLight.shadow.map.dispose(), Ct.keyLight.shadow.map = null), ot.shadowMap.needsUpdate = true)), gl = performance.now() + d0, pl = 0, ml = 0);
    try {
      localStorage.setItem("jarrows_quality", ys);
    } catch {
    }
  }
  typeof window < "u" && (window.applyQualityPreset = f0);
  f0(ys);
  function Kl() {
    if (!vr) if (It) {
      if (pi !== null) return;
      pi = window.setTimeout(() => {
        pi = null, Fi = requestAnimationFrame(Sp);
      }, Jh);
    } else Fi = requestAnimationFrame(Sp);
  }
  function Sp() {
    Kl();
    const s = performance.now();
    if (!It && s - fl < Jh - 0.5) return;
    fl = s;
    const e = (s - gr) / 1e3;
    if (gr = s, et() && Lt && !jn && !a0() && !bt && !vr && (Vt -= e, Vt <= 0 && (Vt = 0, Bn(), N1())), Yc.copy(qh).add(wo), pn.position.copy(Yc), pn.rotation.set(0, 0, 0), bt && Se.length > 0 && s - ep > _1) {
      ep = s, qc.makeEmpty();
      for (const w of Se) !w || !w.group || (w.group.updateMatrixWorld(true), qc.expandByObject(w.group));
      const g = qc.getSize(y1), p = Nn.fov * (Math.PI / 180), _ = Nn.aspect, x = (g.y + Zf) / (2 * Math.tan(p / 2)), E = (Math.sqrt(g.x * g.x + g.z * g.z) + Zf) / (2 * Math.tan(p / 2) * _), S = Math.max(x, E) * x1;
      Dn = Math.max(Yl, Math.min(Hu, S));
    }
    const t = bt ? 0.25 : 0.04;
    Ui += (Dn - Ui) * t, Ni += (or - Ni) * t, ci += ($n - ci) * t;
    const n = 1e-4, i = Math.abs(Dn - Ui), r = Math.abs(or - Ni), o = Math.abs($n - ci);
    i < n && (Ui = Dn), r < n && (Ni = or), o < n && (ci = $n), ql();
    const a = ys === "battery", l = mr || He && He.isActive;
    let c = false, u = false, d = false;
    for (const g of Se) if (g && (g.isFalling && (c = true, g.physicsBody && (d = true)), (g.isAnimating || g.removalStartTime && !g.isRemoved) && (u = true), c && u && d)) break;
    const h = i >= n || r >= n || o >= n;
    Jh = l || c || h || u || bt ? Zu : u0, (bt || l || h || !a && (c || u)) && (gl = s + d0);
    const v = s < gl;
    if (v && s - pl > Kh && (pl = s, w1(Ct, Ni, ci, Yc), ot.shadowMap && (ot.shadowMap.needsUpdate = true)), ot.shadowMap && v && s - ml > jh && (ml = s, ot.shadowMap.needsUpdate = true), s - Mp > rT && (Mp = s, Bn()), Zc++, s - Jc >= oT) {
      const g = Math.round(Zc * 1e3 / (s - Jc));
      bp && (bp.textContent = `FPS: ${g}`);
      const p = document.getElementById("block-value");
      p && (p.textContent = Se.length), Zc = 0, Jc = s;
    }
    if ($c = false, !$c && (d || w0() || c) && (T0(jt), $c = true), !ds() && !E0()) {
      for (const g of Se) !g || g.isRemoved || !g.isFalling || g.updateFromPhysics();
      for (const g of Se) g.updateHighlightAnimation && g.updateHighlightAnimation(e);
      for (const g of Se) if (g.updateMeltAnimation && g.removalStartTime && !g.isRemoved) try {
        g.updateMeltAnimation(e);
      } catch (p) {
        console.error("Error updating melt animation:", p, g);
      }
      s - yp > sT && (yp = s, Po(Se));
      for (let g = Se.length - 1; g >= 0; g--) {
        const p = Se[g];
        p.isRemoved && (!p.removalStartTime && (Ww(), P1(p.length)), p.group.parent && p.group.parent.remove(p.group), p.physicsBody && p.physicsBody.body && x0(async () => {
          const { removePhysicsBody: x } = await import("./physics-CelHDFek.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            removePhysicsBody: x
          };
        }, __vite__mapDeps([0,1])).then(({ removePhysicsBody: x }) => {
          x(jt, p.physicsBody.body);
        }), window.puzzleSolution && window.solutionStep < window.puzzleSolution.length && (window.solutionStep++, setTimeout(() => {
          Jl();
        }, 100)), Se.splice(g, 1));
      }
      if (Se.length === 0 && tt >= 0 && !bt && !il) {
        il = true, k1();
        try {
          const p = tt + 1;
          localStorage.setItem(Co, p.toString());
          const _ = parseInt(localStorage.getItem(Ro) || "0", 10);
          p > _ && localStorage.setItem(Ro, p.toString()), console.log(`Progress saved: Level ${p} (completed level ${tt})`);
        } catch (p) {
          console.warn("Failed to save progress on level completion:", p);
        }
        let g = Er;
        Gi && On !== null && (g += performance.now() / 1e3 - On), X1(tt), (async () => {
          try {
            const p = await Xw(g);
            et() && Lt && (p.timeCollectedLevel = Wo, p.timeCollectedAllTime = Xu, p.timeCarriedOverLevel = Eo);
            const _ = await jw(p);
            i1(p, _);
          } catch (p) {
            console.error("Error processing stats:", p);
          }
        })();
      }
    }
    ot.render(qe, Nn);
  }
  window.testBlockCounts = async function(s = 5) {
    console.log("\u{1F9EA} Testing block counts for levels 0-" + s), console.log("=".repeat(60));
    const e = [];
    for (let i = 0; i <= s; i++) {
      const r = qu(i);
      console.log(`
\u{1F4CA} Level ${i}: Target = ${r}`), await Jn(i), await new Promise((l) => setTimeout(l, 500));
      const o = Se.length, a = o === r;
      e.push({
        level: i,
        target: r,
        actual: o,
        match: a,
        difference: r - o
      }), a ? console.log(`\u2705 Level ${i}: PASS (${o} blocks)`) : console.error(`\u274C Level ${i}: FAIL - Expected ${r}, got ${o} (difference: ${r - o})`);
    }
    console.log(`
` + "=".repeat(60)), console.log("\u{1F4CB} SUMMARY:");
    const t = e.filter((i) => i.match).length, n = e.filter((i) => !i.match).length;
    return console.log(`\u2705 Passed: ${t}/${e.length}`), console.log(`\u274C Failed: ${n}/${e.length}`), n > 0 && (console.log(`
\u274C Failed levels:`), e.filter((i) => !i.match).forEach((i) => {
      console.log(`  Level ${i.level}: Expected ${i.target}, got ${i.actual} (diff: ${i.difference})`);
    })), e;
  };
  document.addEventListener("visibilitychange", () => {
    if (vr = document.hidden, nn("hidden", document.hidden), vr) {
      Fi !== null && cancelAnimationFrame(Fi), Fi = null, pi !== null && (clearTimeout(pi), pi = null);
      return;
    }
    gr = performance.now(), fl = gr, Kl();
  });
  Kl();
});
