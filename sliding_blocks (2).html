<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Block Puzzle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #block-counter {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            z-index: 1000;
        }
        #fps-counter {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="block-counter">Blocks: --</div>
    <div id="fps-counter">FPS: --</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        
        // Global arrow style
        let currentArrowStyle = 2;
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 8, 8);
        camera.lookAt(3, 0, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(3, 0, 3);
        controls.update();

        // Track camera drag state to prevent block clicks during camera movement
        let isCameraDragging = false;
        let mouseDownPos = null;
        const DRAG_THRESHOLD = 3; // pixels - minimum movement to consider it a drag

        renderer.domElement.addEventListener('mousedown', (event) => {
            mouseDownPos = { x: event.clientX, y: event.clientY };
            isCameraDragging = false;
        });

        renderer.domElement.addEventListener('mousemove', (event) => {
            if (mouseDownPos) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > DRAG_THRESHOLD) {
                    isCameraDragging = true;
                }
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            mouseDownPos = null;
            // Keep isCameraDragging true until next mousedown to prevent click after drag
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            mouseDownPos = null;
            isCameraDragging = false;
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -10;
        dirLight.shadow.camera.right = 10;
        dirLight.shadow.camera.top = 10;
        dirLight.shadow.camera.bottom = -10;
        scene.add(dirLight);

        // Grid base
        const gridSize = 7;
        const cubeSize = 1;
        const baseGeometry = new THREE.BoxGeometry(gridSize * cubeSize, 0.2, gridSize * cubeSize);
        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.set(gridSize * cubeSize / 2, -0.1, gridSize * cubeSize / 2);
        base.receiveShadow = true;
        scene.add(base);

        // Grid lines
        const gridHelper = new THREE.GridHelper(gridSize * cubeSize, gridSize, 0x888888, 0x666666);
        gridHelper.position.set(gridSize * cubeSize / 2, 0, gridSize * cubeSize / 2);
        scene.add(gridHelper);

        // Block class
        class Block {
            constructor(length, gridX, gridZ, direction, isVertical = false) {
                this.length = length; // 1, 2, or 3
                this.gridX = gridX;
                this.gridZ = gridZ;
                this.direction = direction; // {x: 0/±1, z: 0/±1}
                this.isVertical = isVertical; // If true, cubes stack vertically
                this.isAnimating = false;
                this.isFalling = false;
                
                this.group = new THREE.Group();
                
                // Create cubes with rounded edges
                const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 4, 4, 4);
                
                // Apply edge rounding by modifying geometry
                const positionAttribute = cubeGeometry.attributes.position;
                const vertex = new THREE.Vector3();
                const radius = 0.05; // Rounding radius
                
                for (let i = 0; i < positionAttribute.count; i++) {
                    vertex.fromBufferAttribute(positionAttribute, i);
                    
                    // Calculate distance from center for each axis
                    const signs = {
                        x: Math.sign(vertex.x),
                        y: Math.sign(vertex.y),
                        z: Math.sign(vertex.z)
                    };
                    
                    const absVertex = {
                        x: Math.abs(vertex.x),
                        y: Math.abs(vertex.y),
                        z: Math.abs(vertex.z)
                    };
                    
                    // Apply rounding to corners and edges
                    const halfSize = cubeSize / 2;
                    const threshold = halfSize - radius;
                    
                    if (absVertex.x > threshold && absVertex.y > threshold && absVertex.z > threshold) {
                        // Corner
                        const cornerDist = Math.sqrt(
                            Math.pow(absVertex.x - threshold, 2) +
                            Math.pow(absVertex.y - threshold, 2) +
                            Math.pow(absVertex.z - threshold, 2)
                        );
                        if (cornerDist > 0) {
                            const scale = radius / cornerDist;
                            vertex.x = signs.x * (threshold + (absVertex.x - threshold) * scale);
                            vertex.y = signs.y * (threshold + (absVertex.y - threshold) * scale);
                            vertex.z = signs.z * (threshold + (absVertex.z - threshold) * scale);
                        }
                    } else if (absVertex.x > threshold && absVertex.y > threshold) {
                        // Edge along Z
                        const edgeDist = Math.sqrt(
                            Math.pow(absVertex.x - threshold, 2) +
                            Math.pow(absVertex.y - threshold, 2)
                        );
                        if (edgeDist > 0) {
                            const scale = radius / edgeDist;
                            vertex.x = signs.x * (threshold + (absVertex.x - threshold) * scale);
                            vertex.y = signs.y * (threshold + (absVertex.y - threshold) * scale);
                        }
                    } else if (absVertex.x > threshold && absVertex.z > threshold) {
                        // Edge along Y
                        const edgeDist = Math.sqrt(
                            Math.pow(absVertex.x - threshold, 2) +
                            Math.pow(absVertex.z - threshold, 2)
                        );
                        if (edgeDist > 0) {
                            const scale = radius / edgeDist;
                            vertex.x = signs.x * (threshold + (absVertex.x - threshold) * scale);
                            vertex.z = signs.z * (threshold + (absVertex.z - threshold) * scale);
                        }
                    } else if (absVertex.y > threshold && absVertex.z > threshold) {
                        // Edge along X
                        const edgeDist = Math.sqrt(
                            Math.pow(absVertex.y - threshold, 2) +
                            Math.pow(absVertex.z - threshold, 2)
                        );
                        if (edgeDist > 0) {
                            const scale = radius / edgeDist;
                            vertex.y = signs.y * (threshold + (absVertex.y - threshold) * scale);
                            vertex.z = signs.z * (threshold + (absVertex.z - threshold) * scale);
                        }
                    }
                    
                    positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                
                cubeGeometry.computeVertexNormals();
                
                const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d];
                const cubeMaterial = new THREE.MeshStandardMaterial({ 
                    color: colors[length - 1],
                    roughness: 0.7,
                    metalness: 0.2
                });
                
                this.cubes = [];
                
                for (let i = 0; i < length; i++) {
                    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    
                    if (this.isVertical) {
                        // Stack cubes vertically
                        cube.position.set(0, cubeSize / 2 + i * cubeSize, 0);
                    } else {
                        // Place cubes horizontally based on direction
                        const isXAligned = Math.abs(direction.x) > 0;
                        
                        if (isXAligned) {
                            cube.position.set(i * cubeSize, cubeSize / 2, 0);
                        } else {
                            cube.position.set(0, cubeSize / 2, i * cubeSize);
                        }
                    }
                    
                    this.cubes.push(cube);
                    this.group.add(cube);
                }
                
                // Create arrow (uses global currentArrowStyle and block color)
                this.createArrow(currentArrowStyle, colors[length - 1]);
                
                // Position block on grid
                this.updateWorldPosition();
                
                scene.add(this.group);
            }
            
            createArrow(style = 1, blockColor = 0xffffff) {
                const arrowGroup = new THREE.Group();
                let arrowMesh, outline;
                
                // Helper function to create arrow geometry based on style
                const createArrowGeometry = (style) => {
                    let arrowShape, extrudeSettings, arrowGeometry, arrowMaterial;
                    
                    if (style === 1) {
                        // Style 1: Modern Chevron with glow
                        arrowShape = new THREE.Shape();
                        const width = 0.25;
                        const length = 0.35;
                        const thickness = 0.06;
                        
                        arrowShape.moveTo(0, length);
                        arrowShape.lineTo(width, length - width);
                        arrowShape.lineTo(width - thickness, length - width);
                        arrowShape.lineTo(0, length - thickness);
                        arrowShape.lineTo(-width + thickness, length - width);
                        arrowShape.lineTo(-width, length - width);
                        arrowShape.lineTo(0, length);
                        
                        arrowShape.moveTo(thickness / 2, length - width);
                        arrowShape.lineTo(thickness / 2, -length * 0.3);
                        arrowShape.lineTo(-thickness / 2, -length * 0.3);
                        arrowShape.lineTo(-thickness / 2, length - width);
                        
                        extrudeSettings = {
                            depth: 0.03,
                            bevelEnabled: true,
                            bevelThickness: 0.01,
                            bevelSize: 0.01,
                            bevelSegments: 2
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            emissive: blockColor,
                            emissiveIntensity: 0.3,
                            roughness: 0.3,
                            metalness: 0.6,
                            side: THREE.DoubleSide
                        });
                        
                    } else if (style === 2) {
                        // Style 2: Bold solid arrow with shadow
                        arrowShape = new THREE.Shape();
                        arrowShape.moveTo(0, 0.35);
                        arrowShape.lineTo(-0.2, 0);
                        arrowShape.lineTo(-0.06, 0);  // Reduced from -0.08
                        arrowShape.lineTo(-0.06, -0.25);  // Reduced from -0.08
                        arrowShape.lineTo(0.06, -0.25);  // Reduced from 0.08
                        arrowShape.lineTo(0.06, 0);  // Reduced from 0.08
                        arrowShape.lineTo(0.2, 0);
                        arrowShape.lineTo(0, 0.35);
                        
                        extrudeSettings = {
                            depth: 0.025,  // Reduced from 0.04
                            bevelEnabled: true,
                            bevelThickness: 0.01,  // Reduced from 0.015
                            bevelSize: 0.01,  // Reduced from 0.015
                            bevelSegments: 3
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            roughness: 0.4,
                            metalness: 0.3
                        });
                        
                    } else if (style === 3) {
                        // Style 3: Minimalist line arrow
                        arrowShape = new THREE.Shape();
                        const lineWidth = 0.05;
                        
                        arrowShape.moveTo(-lineWidth/2, -0.2);
                        arrowShape.lineTo(lineWidth/2, -0.2);
                        arrowShape.lineTo(lineWidth/2, 0.1);
                        arrowShape.lineTo(-lineWidth/2, 0.1);
                        
                        arrowShape.moveTo(0, 0.35);
                        arrowShape.lineTo(-0.15, 0.05);
                        arrowShape.lineTo(-0.08, 0.05);
                        arrowShape.lineTo(0, 0.2);
                        arrowShape.lineTo(0.08, 0.05);
                        arrowShape.lineTo(0.15, 0.05);
                        arrowShape.lineTo(0, 0.35);
                        
                        arrowGeometry = new THREE.ShapeGeometry(arrowShape);
                        arrowMaterial = new THREE.MeshBasicMaterial({ 
                            color: blockColor,
                            side: THREE.DoubleSide
                        });
                        
                    } else if (style === 4) {
                        // Style 4: Neon outline arrow
                        arrowShape = new THREE.Shape();
                        const outer = 0.3;
                        const inner = 0.22;
                        const thickness = 0.06;
                        
                        arrowShape.moveTo(0, outer);
                        arrowShape.lineTo(-outer, -0.05);
                        arrowShape.lineTo(-thickness, -0.05);
                        arrowShape.lineTo(-thickness, -0.25);
                        arrowShape.lineTo(thickness, -0.25);
                        arrowShape.lineTo(thickness, -0.05);
                        arrowShape.lineTo(outer, -0.05);
                        arrowShape.lineTo(0, outer);
                        
                        const hole = new THREE.Path();
                        hole.moveTo(0, inner);
                        hole.lineTo(-inner + 0.05, 0.02);
                        hole.lineTo(0, 0.12);
                        hole.lineTo(inner - 0.05, 0.02);
                        hole.lineTo(0, inner);
                        arrowShape.holes.push(hole);
                        
                        extrudeSettings = {
                            depth: 0.03,
                            bevelEnabled: false
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            emissive: blockColor,
                            emissiveIntensity: 0.5,
                            roughness: 0.2,
                            metalness: 0.8
                        });
                        
                    } else if (style === 5) {
                        // Style 5: Rounded bubble arrow
                        arrowShape = new THREE.Shape();
                        
                        arrowShape.moveTo(0, 0.35);
                        arrowShape.lineTo(-0.18, 0.05);
                        arrowShape.quadraticCurveTo(-0.18, 0, -0.12, 0);
                        arrowShape.lineTo(-0.07, 0);
                        arrowShape.lineTo(-0.07, -0.2);
                        arrowShape.quadraticCurveTo(-0.07, -0.25, 0, -0.25);
                        arrowShape.quadraticCurveTo(0.07, -0.25, 0.07, -0.2);
                        arrowShape.lineTo(0.07, 0);
                        arrowShape.lineTo(0.12, 0);
                        arrowShape.quadraticCurveTo(0.18, 0, 0.18, 0.05);
                        arrowShape.lineTo(0, 0.35);
                        
                        extrudeSettings = {
                            depth: 0.05,
                            bevelEnabled: true,
                            bevelThickness: 0.02,
                            bevelSize: 0.02,
                            bevelSegments: 5
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            roughness: 0.3,
                            metalness: 0.4
                        });
                        
                    } else if (style === 6) {
                        // Style 6: Smooth gradient purple arrow
                        arrowShape = new THREE.Shape();
                        
                        // Rounded head
                        arrowShape.moveTo(0, 0.38);
                        arrowShape.lineTo(-0.2, 0.05);
                        arrowShape.quadraticCurveTo(-0.2, -0.02, -0.1, -0.02);
                        arrowShape.lineTo(-0.09, -0.02);
                        arrowShape.lineTo(-0.09, -0.22);
                        arrowShape.quadraticCurveTo(-0.09, -0.28, 0, -0.28);
                        arrowShape.quadraticCurveTo(0.09, -0.28, 0.09, -0.22);
                        arrowShape.lineTo(0.09, -0.02);
                        arrowShape.lineTo(0.1, -0.02);
                        arrowShape.quadraticCurveTo(0.2, -0.02, 0.2, 0.05);
                        arrowShape.lineTo(0, 0.38);
                        
                        extrudeSettings = {
                            depth: 0.06,
                            bevelEnabled: true,
                            bevelThickness: 0.025,
                            bevelSize: 0.025,
                            bevelSegments: 4
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            emissive: blockColor,
                            emissiveIntensity: 0.2,
                            roughness: 0.4,
                            metalness: 0.3
                        });
                        
                    } else if (style === 7) {
                        // Style 7: Sleek teal arrow with modern cut
                        arrowShape = new THREE.Shape();
                        
                        arrowShape.moveTo(0, 0.36);
                        arrowShape.lineTo(-0.22, -0.02);
                        arrowShape.lineTo(-0.11, -0.02);
                        arrowShape.lineTo(-0.11, -0.06);
                        arrowShape.lineTo(-0.08, -0.06);
                        arrowShape.lineTo(-0.08, -0.24);
                        arrowShape.quadraticCurveTo(-0.08, -0.27, 0, -0.27);
                        arrowShape.quadraticCurveTo(0.08, -0.27, 0.08, -0.24);
                        arrowShape.lineTo(0.08, -0.06);
                        arrowShape.lineTo(0.11, -0.06);
                        arrowShape.lineTo(0.11, -0.02);
                        arrowShape.lineTo(0.22, -0.02);
                        arrowShape.lineTo(0, 0.36);
                        
                        extrudeSettings = {
                            depth: 0.05,
                            bevelEnabled: true,
                            bevelThickness: 0.02,
                            bevelSize: 0.02,
                            bevelSegments: 3
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            roughness: 0.35,
                            metalness: 0.4
                        });
                        
                    } else if (style === 8) {
                        // Style 8: Bold red arrow with sharp angles
                        arrowShape = new THREE.Shape();
                        
                        arrowShape.moveTo(0, 0.4);
                        arrowShape.lineTo(-0.24, 0.02);
                        arrowShape.lineTo(-0.1, 0.02);
                        arrowShape.lineTo(-0.1, -0.24);
                        arrowShape.lineTo(0.1, -0.24);
                        arrowShape.lineTo(0.1, 0.02);
                        arrowShape.lineTo(0.24, 0.02);
                        arrowShape.lineTo(0, 0.4);
                        
                        extrudeSettings = {
                            depth: 0.055,
                            bevelEnabled: true,
                            bevelThickness: 0.02,
                            bevelSize: 0.02,
                            bevelSegments: 2
                        };
                        
                        arrowGeometry = new THREE.ExtrudeGeometry(arrowShape, extrudeSettings);
                        arrowMaterial = new THREE.MeshStandardMaterial({ 
                            color: blockColor,
                            roughness: 0.45,
                            metalness: 0.25
                        });
                    }
                    
                    return { geometry: arrowGeometry, material: arrowMaterial };
                };
                
                const isXAligned = Math.abs(this.direction.x) > 0;
                const centerOffset = (this.length - 1) * cubeSize / 2;
                
                // Calculate arrow center offset for each style
                // Arrow geometries extend from negative Y (tail) to positive Y (head)
                // Origin is at y=0, center is at (tail + head) / 2
                let arrowCenterOffset = 0;
                if (style === 1) {
                    // Tail: -0.105, Head: 0.35, Center: (-0.105 + 0.35) / 2 = 0.1225
                    arrowCenterOffset = 0.1225;
                } else if (style === 2) {
                    // Tail: -0.25, Head: 0.35, Center: (-0.25 + 0.35) / 2 = 0.05
                    arrowCenterOffset = 0.05;
                } else if (style === 3) {
                    // Tail: -0.2, Head: 0.35, Center: (-0.2 + 0.35) / 2 = 0.075
                    arrowCenterOffset = 0.075;
                } else if (style === 4) {
                    // Tail: -0.25, Head: 0.3, Center: (-0.25 + 0.3) / 2 = 0.025
                    arrowCenterOffset = 0.025;
                } else if (style === 5) {
                    // Tail: -0.25, Head: 0.35, Center: (-0.25 + 0.35) / 2 = 0.05
                    arrowCenterOffset = 0.05;
                } else if (style === 6) {
                    // Tail: -0.28, Head: 0.38, Center: (-0.28 + 0.38) / 2 = 0.05
                    arrowCenterOffset = 0.05;
                } else if (style === 7) {
                    // Tail: -0.27, Head: 0.36, Center: (-0.27 + 0.36) / 2 = 0.045
                    arrowCenterOffset = 0.045;
                } else if (style === 8) {
                    // Tail: -0.24, Head: 0.4, Center: (-0.24 + 0.4) / 2 = 0.08
                    arrowCenterOffset = 0.08;
                }
                
                // TOP ARROW
                const topArrow = new THREE.Group();
                const topArrowData = createArrowGeometry(style);
                const topArrowMesh = new THREE.Mesh(topArrowData.geometry, topArrowData.material);
                
                if (style === 1) topArrowMesh.position.z = -0.015;
                else if (style === 2) topArrowMesh.position.z = -0.0125;
                else if (style === 4) topArrowMesh.position.z = -0.015;
                else if (style === 5) topArrowMesh.position.z = -0.025;
                else if (style === 6) topArrowMesh.position.z = -0.03;
                else if (style === 7) topArrowMesh.position.z = -0.025;
                else if (style === 8) topArrowMesh.position.z = -0.0275;
                
                // Offset arrow mesh in local Y direction to center it
                // Arrow center is at arrowCenterOffset in local +Y, so move it back by that amount
                topArrowMesh.position.y = -arrowCenterOffset;
                
                topArrow.add(topArrowMesh);
                
                if (this.isVertical) {
                    // Arrow on top of vertical stack
                    topArrow.position.set(0, this.length * cubeSize + 0.02, 0);
                } else {
                    // Arrow on top of horizontal block
                    // Position arrow group at block center
                    if (isXAligned) {
                        topArrow.position.set(centerOffset, cubeSize + 0.02, 0);
                    } else {
                        topArrow.position.set(0, cubeSize + 0.02, centerOffset);
                    }
                }
                
                topArrow.rotation.x = -Math.PI / 2;
                topArrow.rotation.z = Math.atan2(this.direction.x, this.direction.z) + Math.PI;
                arrowGroup.add(topArrow);
                
                
                this.group.add(arrowGroup);
                this.arrow = arrowGroup;
            }
            
            updateWorldPosition() {
                this.group.position.set(
                    this.gridX * cubeSize + cubeSize / 2,
                    0,
                    this.gridZ * cubeSize + cubeSize / 2
                );
            }
            
            canMove(blocks) {
                // Check if block can move one step in its direction
                const newGridX = this.gridX + this.direction.x;
                const newGridZ = this.gridZ + this.direction.z;
                
                // Vertical blocks only occupy one grid cell
                if (this.isVertical) {
                    // Check if out of bounds
                    if (newGridX < 0 || newGridX >= gridSize || newGridZ < 0 || newGridZ >= gridSize) {
                        return 'fall';
                    }
                    
                    // Check collision with other blocks
                    for (const other of blocks) {
                        if (other === this || other.isFalling) continue;
                        
                        if (other.isVertical) {
                            if (newGridX === other.gridX && newGridZ === other.gridZ) {
                                return 'blocked';
                            }
                        } else {
                            const otherIsXAligned = Math.abs(other.direction.x) > 0;
                            for (let j = 0; j < other.length; j++) {
                                let otherX = other.gridX;
                                let otherZ = other.gridZ;
                                
                                if (otherIsXAligned) {
                                    otherX += j;
                                } else {
                                    otherZ += j;
                                }
                                
                                if (newGridX === otherX && newGridZ === otherZ) {
                                    return 'blocked';
                                }
                            }
                        }
                    }
                    
                    return 'ok';
                }
                
                // Horizontal blocks - check all cubes
                const isXAligned = Math.abs(this.direction.x) > 0;
                
                for (let i = 0; i < this.length; i++) {
                    let checkX = newGridX;
                    let checkZ = newGridZ;
                    
                    if (isXAligned) {
                        checkX += i;
                    } else {
                        checkZ += i;
                    }
                    
                    // Check if out of bounds
                    if (checkX < 0 || checkX >= gridSize || checkZ < 0 || checkZ >= gridSize) {
                        return 'fall';
                    }
                    
                    // Check collision with other blocks
                    for (const other of blocks) {
                        if (other === this || other.isFalling) continue;
                        
                        if (other.isVertical) {
                            if (checkX === other.gridX && checkZ === other.gridZ) {
                                return 'blocked';
                            }
                        } else {
                            const otherIsXAligned = Math.abs(other.direction.x) > 0;
                            
                            for (let j = 0; j < other.length; j++) {
                                let otherX = other.gridX;
                                let otherZ = other.gridZ;
                                
                                if (otherIsXAligned) {
                                    otherX += j;
                                } else {
                                    otherZ += j;
                                }
                                
                                if (checkX === otherX && checkZ === otherZ) {
                                    return 'blocked';
                                }
                            }
                        }
                    }
                }
                
                return 'ok';
            }
            
            move() {
                if (this.isAnimating || this.isFalling) return;
                
                this.isAnimating = true;
                
                // Calculate total distance to move
                let stepsToMove = 0;
                let tempGridX = this.gridX;
                let tempGridZ = this.gridZ;
                
                // Count how many steps until blocked or edge
                while (true) {
                    tempGridX += this.direction.x;
                    tempGridZ += this.direction.z;
                    
                    let willFall = false;
                    let willBlock = false;
                    
                    if (this.isVertical) {
                        // Vertical block - only check one grid cell
                        if (tempGridX < 0 || tempGridX >= gridSize || tempGridZ < 0 || tempGridZ >= gridSize) {
                            willFall = true;
                        } else {
                            // Check collision
                            for (const other of blocks) {
                                if (other === this || other.isFalling) continue;
                                
                                if (other.isVertical) {
                                    if (tempGridX === other.gridX && tempGridZ === other.gridZ) {
                                        willBlock = true;
                                        break;
                                    }
                                } else {
                                    const otherIsXAligned = Math.abs(other.direction.x) > 0;
                                    for (let j = 0; j < other.length; j++) {
                                        let otherX = other.gridX;
                                        let otherZ = other.gridZ;
                                        
                                        if (otherIsXAligned) {
                                            otherX += j;
                                        } else {
                                            otherZ += j;
                                        }
                                        
                                        if (tempGridX === otherX && tempGridZ === otherZ) {
                                            willBlock = true;
                                            break;
                                        }
                                    }
                                }
                                if (willBlock) break;
                            }
                        }
                    } else {
                        // Horizontal block - check all cubes
                        const isXAligned = Math.abs(this.direction.x) > 0;
                        
                        for (let i = 0; i < this.length; i++) {
                            let checkX = tempGridX;
                            let checkZ = tempGridZ;
                            
                            if (isXAligned) {
                                checkX += i;
                            } else {
                                checkZ += i;
                            }
                            
                            // Check bounds
                            if (checkX < 0 || checkX >= gridSize || checkZ < 0 || checkZ >= gridSize) {
                                willFall = true;
                                break;
                            }
                            
                            // Check collision
                            for (const other of blocks) {
                                if (other === this || other.isFalling) continue;
                                
                                if (other.isVertical) {
                                    if (checkX === other.gridX && checkZ === other.gridZ) {
                                        willBlock = true;
                                        break;
                                    }
                                } else {
                                    const otherIsXAligned = Math.abs(other.direction.x) > 0;
                                    for (let j = 0; j < other.length; j++) {
                                        let otherX = other.gridX;
                                        let otherZ = other.gridZ;
                                        
                                        if (otherIsXAligned) {
                                            otherX += j;
                                        } else {
                                            otherZ += j;
                                        }
                                        
                                        if (checkX === otherX && checkZ === otherZ) {
                                            willBlock = true;
                                            break;
                                        }
                                    }
                                }
                                if (willBlock) break;
                            }
                            if (willBlock) break;
                        }
                    }
                    
                    if (willBlock) {
                        break; // Stop before this position
                    }
                    
                    stepsToMove++;
                    
                    if (willFall) {
                        break; // Move to edge then fall
                    }
                }
                
                if (stepsToMove === 0) {
                    this.isAnimating = false;
                    return;
                }
                
                // Animate smooth movement
                const startTime = Date.now();
                const duration = stepsToMove * 150; // ms per step
                
                const startX = this.group.position.x;
                const startZ = this.group.position.z;
                
                this.gridX += this.direction.x * stepsToMove;
                this.gridZ += this.direction.z * stepsToMove;
                
                const endX = this.gridX * cubeSize + cubeSize / 2;
                const endZ = this.gridZ * cubeSize + cubeSize / 2;
                
                const willFallOff = (
                    this.gridX < 0 || this.gridX >= gridSize || 
                    this.gridZ < 0 || this.gridZ >= gridSize
                );
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    this.group.position.x = startX + (endX - startX) * progress;
                    this.group.position.z = startZ + (endZ - startZ) * progress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.isAnimating = false;
                        if (willFallOff) {
                            this.fall();
                        }
                    }
                };
                
                animate();
            }
            
            fall() {
                if (this.isFalling) return;
                
                this.isFalling = true;
                const startTime = Date.now();
                const duration = 800;
                
                const startY = this.group.position.y;
                const endY = -10;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Accelerating fall
                    this.group.position.y = startY + (endY - startY) * progress * progress;
                    
                    // Slight rotation during fall
                    this.group.rotation.x += 0.05;
                    this.group.rotation.z += 0.03;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(this.group);
                    }
                };
                
                animate();
            }
        }

        // Create random blocks
        const blocks = [];
        const directions = [
            {x: 1, z: 0},   // East
            {x: -1, z: 0},  // West
            {x: 0, z: 1},   // South
            {x: 0, z: -1}   // North
        ];
        
        function createRandomBlocks() {
            const occupiedCells = new Set();
            
            function isCellOccupied(x, z) {
                return occupiedCells.has(`${x},${z}`);
            }
            
            function occupyCells(block) {
                if (block.isVertical) {
                    // Vertical blocks occupy single cell
                    occupiedCells.add(`${block.gridX},${block.gridZ}`);
                } else {
                    // Horizontal blocks occupy multiple cells
                    const isXAligned = Math.abs(block.direction.x) > 0;
                    for (let i = 0; i < block.length; i++) {
                        const x = block.gridX + (isXAligned ? i : 0);
                        const z = block.gridZ + (isXAligned ? 0 : i);
                        occupiedCells.add(`${x},${z}`);
                    }
                }
            }
            
            // Try to place 8-12 blocks
            const numBlocks = 8 + Math.floor(Math.random() * 5);
            let attempts = 0;
            const maxAttempts = 100;
            
            while (blocks.length < numBlocks && attempts < maxAttempts) {
                attempts++;
                
                const length = Math.floor(Math.random() * 3) + 1; // 1, 2, or 3
                const direction = directions[Math.floor(Math.random() * directions.length)];
                
                // 1x blocks are never vertical, 2x and 3x can be vertical 40% of the time
                const isVertical = length > 1 && Math.random() < 0.4;
                
                let gridX, gridZ;
                
                if (isVertical) {
                    // Vertical blocks only need one grid cell
                    gridX = Math.floor(Math.random() * gridSize);
                    gridZ = Math.floor(Math.random() * gridSize);
                    
                    if (!isCellOccupied(gridX, gridZ)) {
                        const block = new Block(length, gridX, gridZ, direction, isVertical);
                        blocks.push(block);
                        occupyCells(block);
                    }
                } else {
                    // Horizontal blocks
                    const isXAligned = Math.abs(direction.x) > 0;
                    const maxX = isXAligned ? gridSize - length : gridSize - 1;
                    const maxZ = isXAligned ? gridSize - 1 : gridSize - length;
                    
                    gridX = Math.floor(Math.random() * (maxX + 1));
                    gridZ = Math.floor(Math.random() * (maxZ + 1));
                    
                    // Check if all cells are free
                    let canPlace = true;
                    for (let i = 0; i < length; i++) {
                        const checkX = gridX + (isXAligned ? i : 0);
                        const checkZ = gridZ + (isXAligned ? 0 : i);
                        if (isCellOccupied(checkX, checkZ)) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        const block = new Block(length, gridX, gridZ, direction, isVertical);
                        blocks.push(block);
                        occupyCells(block);
                    }
                }
            }
        }
        
        createRandomBlocks();

        // Raycasting for clicks
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
            // Don't process block clicks if camera was being dragged
            if (isCameraDragging) {
                isCameraDragging = false; // Reset for next interaction
                return;
            }
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Check intersections with all cubes
            for (const block of blocks) {
                if (block.isAnimating || block.isFalling) continue;
                
                const intersects = raycaster.intersectObjects(block.cubes, true);
                
                if (intersects.length > 0) {
                    // Start moving - block will continue until blocked or falls
                    block.move();
                    break;
                }
            }
        }
        
        
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        let lastTime = performance.now();
        let fpsFrameCount = 0;
        let fpsLastUpdate = performance.now();
        const fpsElement = document.getElementById('fps-counter');
        const blockCountElement = document.getElementById('block-counter');

        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            fpsFrameCount++;
            
            if (currentTime - fpsLastUpdate >= 500) {
                const fps = Math.round((fpsFrameCount * 1000) / (currentTime - fpsLastUpdate));
                if (fpsElement) fpsElement.textContent = `FPS: ${fps}`;
                if (blockCountElement) {
                    // Filter blocks that are still in scene
                    const activeBlocks = blocks.filter(b => b.group.parent !== null);
                    blockCountElement.textContent = `Blocks: ${activeBlocks.length}`;
                }
                fpsFrameCount = 0;
                fpsLastUpdate = currentTime;
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
